{"version":3,"sources":["webpack://roosterjs/webpack/bootstrap","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/contains.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTagOfNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/Position.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/execCommand.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafSibling.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/createRange.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/applyInlineStyle.ts","webpack://roosterjs/./packages/roosterjs-html-sanitizer/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitParentNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/collapseNodes.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/wrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyTextStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/shouldSkipNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getComputedStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/cacheGetEventData.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/processList.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/fromHtml.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/Browser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeEmpty.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/ContentEditFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setBackgroundColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontName.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setTextColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBold.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleItalic.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleUnderline.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EditPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/hasFocus.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/undo/Undo.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/clearEventDataCache.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/formatTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/toggleTagCore.ts","webpack://roosterjs/./packages/roosterjs-html-sanitizer/lib/utils/cloneObject.ts","webpack://roosterjs/./packages/roosterjs-html-sanitizer/lib/utils/getInheritableStyles.ts","webpack://roosterjs/./packages/roosterjs-html-sanitizer/lib/utils/htmlToDom.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/CustomData.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/LevelLists.ts","webpack://roosterjs/./packages/roosterjs/lib/index.ts","webpack://roosterjs/./packages/roosterjs/lib/createEditor.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/HyperLink/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/changeElementTag.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/extractClipboardEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/matchLink.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/queryElements.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/unwrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/table/VTable.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getPositionRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/features/autoLinkFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearBlockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/createLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/getFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/Editor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/createEditorCore.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/attachDomEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/editWithUndo.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/focus.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/getCustomData.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/getSelectionRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/insertNode.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/select.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/triggerEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/undo/UndoSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/cacheGetContentSearcher.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/cacheGetElementAtCursor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertImage.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/insertTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/editTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/removeLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/replaceWithNode.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setAlignment.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setDirection.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setImageAltText.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setIndentation.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBullet.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleNumbering.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBlockQuote.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleCodeBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleStrikethrough.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSubscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSuperscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleHeader.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/features/shortcutFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/features/tableFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/features/listFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/features/quoteFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/buildClipboardData.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/fragmentHandler.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/excelConverter/convertPastedContentFromExcel.ts","webpack://roosterjs/./packages/roosterjs-html-sanitizer/lib/sanitizer/HtmlSanitizer.ts","webpack://roosterjs/./packages/roosterjs-html-sanitizer/lib/utils/getAllowedValues.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/convertPastedContentFromWord.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/wordConverter.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/WordConverterArguments.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/converterUtils.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/textToHtml.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Watermark/Watermark.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/TableResize/TableResize.ts","webpack://roosterjs/./packages/roosterjs-plugin-image-resize/lib/index.ts","webpack://roosterjs/./packages/roosterjs-plugin-image-resize/lib/ImageResize.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","NodeBlockElement_1","NodeBlockElement","default","getBlockElementAtNode_1","getBlockElementAtNode","getFirstLastBlockElement_1","getFirstLastBlockElement","StartEndBlockElement_1","StartEndBlockElement","ContentTraverser_1","ContentTraverser","PositionContentSearcher_1","PositionContentSearcher","getInlineElementAtNode_1","getInlineElementAtNode","ImageInlineElement_1","ImageInlineElement","LinkInlineElement_1","LinkInlineElement","NodeInlineElement_1","NodeInlineElement","PartialInlineElement_1","PartialInlineElement","applyTextStyle_1","applyTextStyle","Browser_1","Browser","getBrowserInfo","applyFormat_1","applyFormat","changeElementTag_1","changeElementTag","collapseNodes_1","collapseNodes","contains_1","contains","extractClipboardEvent_1","extractClipboardEvent","findClosestElementAncestor_1","findClosestElementAncestor","fromHtml_1","fromHtml","getComputedStyles_1","getComputedStyles","getComputedStyle","getTagOfNode_1","getTagOfNode","isBlockElement_1","isBlockElement","isNodeEmpty_1","isNodeEmpty","isVoidHtmlElement_1","isVoidHtmlElement","matchLink_1","matchLink","queryElements_1","queryElements","splitParentNode_1","splitParentNode","splitBalancedNodeRange","unwrap_1","unwrap","wrap_1","wrap","getLeafSibling_1","getNextLeafSibling","getPreviousLeafSibling","getLeafNode_1","getFirstLeafNode","getLastLeafNode","VTable_1","VTable","Position_1","Position","createRange_1","createRange","getPositionRect_1","getPositionRect","isPositionAtBeginningOf_1","isPositionAtBeginningOf","getSelectionPath_1","getSelectionPath","getRangeFromSelectionPath","container","contained","treatSameNodeAsContain","Node","commonAncestorContainer","nodeType","parentNode","node","tagName","toUpperCase","isNodeAfter_1","nodeOrPosition","offsetOrPosType","this","offset","getIndexOfNode","isAtEnd","nextSibling","getEndOffset","endOffset","Math","max","min","element","normalize","firstChild","newOffset","lastChild","childNodes","equalTo","position","isAfter","move","getStart","range","startContainer","startOffset","getEnd","endContainer","previousSibling","nodeValue","length","editor","command","focus","formatter","getDocument","execCommand","getSelectionRange","collapsed","addUndoSnapshot","Editor_1","Editor","Undo_1","Undo","EditPlugin_1","EditPlugin","MouseUpPlugin_1","MouseUpPlugin","DOMEventPlugin_1","DOMEventPlugin","TypeInContainerPlugin_1","TypeInContainerPlugin","cacheGetEventData_1","cacheGetEventData","clearEventDataCache_1","clearEventDataCache","cacheGetContentSearcher_1","cacheGetContentSearcher","clearContentSearcherCache","cacheGetElementAtCursor_1","cacheGetElementAtCursor","findHeadTailLeafNode","containerBlockNode","isTail","result","sibling","rootNode","getBlockContext","headNode","tailNode","nodes","shouldSkipNode_1","getLeafSibling","startNode","isNext","getSibling","getChild","curNode","shouldContinue","changeFontSize_1","changeFontSize","FONT_SIZES","clearBlockFormat_1","clearBlockFormat","TAGS_TO_UNWRAP","TAGS_TO_STOP_UNWRAP","ATTRIBUTES_TO_PRESERVE","clearFormat_1","clearFormat","createLink_1","createLink","getFormatState_1","getFormatState","insertImage_1","insertImage","insertTable_1","insertTable","editTable_1","editTable","formatTable_1","formatTable","removeLink_1","removeLink","replaceWithNode_1","replaceWithNode","setAlignment_1","setAlignment","setBackgroundColor_1","setBackgroundColor","setTextColor_1","setTextColor","setDirection_1","setDirection","setFontName_1","setFontName","setFontSize_1","setFontSize","setImageAltText_1","setImageAltText","setIndentation_1","setIndentation","toggleBold_1","toggleBold","toggleBullet_1","toggleBullet","toggleItalic_1","toggleItalic","toggleNumbering_1","toggleNumbering","toggleBlockQuote_1","toggleBlockQuote","toggleCodeBlock_1","toggleCodeBlock","toggleStrikethrough_1","toggleStrikethrough","toggleSubscript_1","toggleSubscript","toggleSuperscript_1","toggleSuperscript","toggleUnderline_1","toggleUnderline","toggleHeader_1","toggleHeader","node1","node2","compareDocumentPosition","parent","parentBlock","inlineElement","nodeChain","parent_1","push","currentNode","tag","resolveInlineElement","getFocusablePosition","start","end","ownerDocument","setStart","setEnd","roosterjs_editor_dom_1","ZERO_WIDTH_SPACE","callback","createTextNode","insertNode","select","firstNode","lastNode","contentTraverser","getSelectionTraverser","currentInlineElement","nextInlineElement","getNextInlineElement","applyStyle","HtmlSanitizer_1","HtmlSanitizer","htmlToDom_1","htmlToDom","splitWithFragment","getInheritableStyles_1","getInheritableStyles","splitBefore","newParent","cloneNode","removeAttribute","appendChild","innerHTML","insertBefore","Array","temp","containerNode","getTextContent","textContent","getContainerNode","getParentBlock","getStartPosition","getEndPosition","isTextualInlineElement","pos","styler","getDecoratedInline","toString","thisStart","otherEnd","from","to","nextNode","previousNode","collapseToSingleElement","getStartNode","getEndNode","equals","blockElement","collapse","root","ref","isStart","canSplitParent","slice","startIndex","indexOf","endIndex","BLOCK_ELEMENT_TAGS","split","BLOCK_DISPLAY_STYLES","style","display","wrapper","Element","document_1","test","createElement","_i","nodes_1","STYLETAGS","splitTextNode","textNode","returnFirstPart","firstPart","substr","secondPart","newNode","formatNodes","formatNode","parentTag","every","newNode_1","shift","forEach","removeChild","selector","closest","matches","msMatchesSelector","parentElement","CRLF","styleNames","styles","defaultView","window","styleNames_1","getPropertyValue","toLowerCase","px2Pt","px","round","parseFloat","styleName","getInlineElementBeforeAfter","isPartial","getInlineElementBefore","getInlineElementAfter","event","eventDataCache","TEMP_NODE_CLASS","TEMP_NODE_HTML","applyListFormat","formats","fontFamily","fontSize","textColor","backgroundColor","isChrome","traverser","block","currentBlockElement","tempNode","getNextBlockElement","workaroundForChrome","getElementAtCursor","currentFormat","existingList","deleteNode","newList","LIs","filter","LIs_1","li","HyperLink_1","HyperLink","ContentEdit_1","ContentEdit","Paste_1","Paste","ContentEditFeatures_1","getDefaultContentEditFeatures","Watermark_1","Watermark","TableResize_1","TableResize","STRUCTURE_NODE_TAGS","endNode","blockContext","html","isFirst","getFirstBlockElement","getLastBlockElement","BodyScoper_1","EmptyInlineElement_1","SelectionBlockScoper_1","SelectionScoper_1","getInlineElementBeforeAfter_1","scoper","createBodyTraverser","createSelectionTraverser","createBlockTraverser","currentBlock","getStartBlockElement","getPreviousNextBlockElement","getPreviousBlockElement","current","leaf","newBlock","isBlockInScope","currentInline","getStartInlineElement","getPreviousNextInlineElement","getPreviousInlineElement","newInline","previousInlineElement","getNextPreviousInlineElement","trimInlineElement","getFirstInlineElement","getLastInlineElement","_super","__extends","getLeafNode","EmptyInlineElement","HTML_VOID_ELEMENTS","userAgent","appVersion","isIE11OrGreater","isIE","isFirefox","isSafari","isEdge","isWebKit","isMac","isWin","isIEOrEdge","navigator","VISIBLE_ELEMENT_TAGS","VISIBLE_CHILD_ELEMENT_SELECTOR","join","trim","replace","trimContent","querySelectorAll","autoLink","indentWhenTab","outdentWhenShiftTab","outdentWhenBackspaceOnEmptyFirstLine","outdentWhenEnterOnEmptyLine","mergeInNewLineWhenBackspaceOnFirstChar","unquoteWhenBackspaceOnEmptyFirstLine","unquoteWhenEnterOnEmptyLine","autoBullet","tabInTable","upDownInTable","defaultShortcut","unlinkWhenBackspaceAfterLink","smartOrderedList","smartOrderedListStyles","isEmptyBlockUnderTR","forEachCallback","blocks","applyInlineStyle_1","color","fontName","lineHeight","execCommand_1","disableRestoreSelectionOnFocus","_this","inIme","onNativeEvent","e","runAsync","type","getName","initialize","disposer","addDomEventHandler","_a","compositionstart","compositionend","triggerEvent","eventType","rawEvent","saveSelectionRange","restoreSavedRange","drop","cut","dispose","isInIME","currentFeature","featureMap","autoCompleteSnapshot","autoCompleteChangeSource","addFeature","keys","shouldHandleEvent","handleEvent","preventDefault","setContent","onPluginEvent","contentChanged","source","findFeature","feature","willHandleEventExclusively","array","performAutoComplete","changeSource","snapshot","data","features","hasFunctionKey","ctrlKey","altKey","metaKey","which","allowFunctionKeys","core","activeElement","document","contentDiv","onMouseUp","removeMouseUpEventListener","mouseUpEventListerAdded","addEventListener","removeEventListener","onKeyPress","ensureTypeInElement","shouldSetNodeStyles","wasNodeJustCreatedByKeyboardEvent","updateCursor","replaceSelection","insertOnNewLine","getDefaultFormat","tryNormalizeTyping","target","innerText","UndoSnapshots_1","preserveSnapshots","maxBufferSize","clear","onKeyDown","clearRedoForInput","isRestoring","undoSnapshots","hasNewContent","undo","restoreSnapshot","redo","canUndo","getSnapshotsManager","canMove","canRedo","getContent","addSnapshot","delta","evt","selectionRange","lastKeyPress","clearRedo","format","table","vtable","writeBack","UNWRAPPABLE_NODES","DEFAULT_STYLER","_","wrapFunction","unwrapFunction","startBlock","endBlock","tag_1","some","cloneObject","assign","existingObj","INHERITABLE_PROPERTIES","win","START_FRAGMENT","END_FRAGMENT","lastIndexOf","before","after","substring","preserveFragmentOnly","fragmentHandler","doc","DOMParser","parseFromString","body","sourceHtml","NODE_ID_ATTRIBUTE_NAME","getAndSetNodeId","customData","id","getAttribute","nextNodeId","setAttribute","createCustomData","dict","setObject","getObject","createLevelLists","listsMetadata","currentUniqueListId","createEditor_1","createEditor","__export","roosterjs_editor_plugins_1","roosterjs_editor_core_1","additionalPlugins","initialContent","plugins","concat","options","defaultFormat","getTooltipCallback","onLinkClick","href","onMouse","a","srcElement","tryGetHref","setEditorDomAttribute","mouseover","mouseout","anchor","open","getFirstLastInlineElement_1","BodyScoper","SelectionBlockScoper","startFrom","Range","blockNode","getFirstLastInlineElementFromBlockElement","startInline","SelectionScoper","inScope","selStartBlock","selEndBlock","inline","startPartial","endPartial","WHITESPACE_REGEX","text","inlineElements","getWordBefore","word","traverse","inlineBefore","inlineAfter","getSubStringBefore","getRangeFromText","exactMatch","startPosition","endPosition","textIndex","forEachTextInlineElement","textInline","nodeContent","nodeIndex","charCodeAt","getNearestNonTextInlineElement","nearestNonTextInlineElement","traversingComplete","previousInline","exec","elementStyle","bold","italic","underline","fontWeight","fontStyle","textDecoration","newTag","newElement","attributes","attr","marginTop","marginBottom","replaceChild","CLIPBOARD_HTML_HEADER_REGEX","getImage","dataTransfer","fileCount","items","item","getAsFile","files","file","workaroundForEdge","headerValues","parseInt","clipboardData","types","getData","image","undefined","getAsString","httpExcludeRegEx","domainPortWithUrlRegEx","domainPortRegEx","linkMatchRules","http","match","RegExp","except","normalizeUrl","url","https","mailto","notes","unc","ftp","news","telnet","gopher","wais","schema","rule","scheme","originalUrl","normalizedUrl","checkPosition","targets","scope","elements","nodeContainedByRangeOnly","targetPositions","isIntersectWithNodeRange","trs","HTMLTableElement","td","getTableFromTd","currentTd_1","rows","cells","map","row","tr","rowIndex","sourceCol","targetCol","col","colSpan","rowSpan","spanLeft","spanAbove","moveChildren","cell","recalcSpans","borderCollapse","bgColorOdd","bgColorEven","borderTop","getBorderStyle","topBorderColor","borderBottom","bottomBorderColor","borderLeft","verticalBorderColor","borderRight","edit","operation","currentRow","currentCell","splice","cloneCell","newRow_1","countSpanAbove","colIndex","nextCell","getCell","newCell","getTd","forEachCellOfCurrentColumn","newCol_1","countSpanLeft","forEachCellOfColumn","forEachCellOfCurrentRow","rowStep","aboveCell","belowCell","colStep","leftCell","rightCell","splitRow","forEachCellOfRow","getCurrentTd","HTMLTableCellElement","fromNode","toNode","normalizeRect","clientRect","left","right","top","bottom","rect","getBoundingClientRect","rects","getClientRects","span","areAllPrevousNodesEmpty","targetNode","getPositionFromPath","path","getPositionPath","unshift","isPreviousText","autoLinkFeatures_1","shortcutFeatures_1","tableFeatures_1","listFeatures_1","quoteFeatures_1","featureSet","getFilteredFeatures","addContentEditFeature","allFeatures","IndentWhenTab","OutdentWhenShiftTab","OutdentWhenBackOn1stEmptyLine","OutdentWhenEnterOnEmptyLine","MergeInNewLine","UnquoteWhenBackOnEmpty1stLine","UnquoteWhenEnterOnEmptyLine","TabInTable","UpDownInTable","AutoBullet","AutoLink","UnlinkWhenBackspaceAfterLink","DefaultShortcut","getSmartOrderedList","roosterjs_editor_api_1","TRAILING_PUNCTUATION_REGEX","MINIMUM_LENGTH","cacheGetLinkData","searcher","trailingPunctuation","candidate_1","str","linkData","MIN_FONT_SIZE","MAX_FONT_SIZE","getNewFontSize","pt","changeBase","fontSizes","floor","ceil","last","change","collapseSelectedBlocks_1","canCollapse","tagsToStopUnwrap","tagsToUnwrap","attributesToPreserve","groups","stopUnwrapSelector","group","first","clearNodeFormat","allChildrenAreBlock","reduce","previousValue","returnBlockElement","clearAttribute","styleArray","STYLES_TO_REMOVE","isDefaultFormatEmpty","removeProperty","URI_REGEX","MAILTO_REGEX","FTP_REGEX","TEMP_TITLE","getAnchorNodeAtCursor","updateAnchorDisplayText","displayText","link","altText","normalizedUrl_1","prefix","search","applyLinkPrefix","originalUrl_1","title","listTag","headerTag","isBold","queryCommandState","isItalic","isUnderline","isStrikeThrough","isSubscript","isSuperscript","isBullet","isNumbering","headerLevel","canUnlink","canAddImageAltText","isBlockQuote","createEditorCore_1","roosterjs_editor_dom_2","Error","plugin","eventDisposers","api","attachDomEvent","additionalEditFeatures","omitContentEditableAttributeChanges","isContentEditable","userSelect","msUserSelect","webkitUserSelect","contenteditableChanged","corePlugins","typeInContainer","isDisposed","option","replaceNode","existingNode","arg","scopeOrCallback","Function","isEmpty","triggerExtractContentEvent","includeSelectionMarker","selectionPath","content","JSON","stringify","extractContentEvent","triggerContentChangedEvent","pathComment","parse","insertContent","allNodes","hasFocus","arg1","arg2","arg3","arg4","getSelection","cachedSelectionRange","getFocusedPosition","sel","focusNode","focusOffset","getCursorRect","nameOrMap","handler","handlers_1","eventName","x","pluginEvent","broadcast","editWithUndo","getCustomData","domEvent","getBodyTraverser","getBlockTraverser","getContentSearcherOfCursor","requestAnimationFrame","attachDomEvent_1","editWithUndo_1","focus_1","getCustomData_1","getSelectionRange_1","hasFocus_1","insertNode_1","select_1","triggerEvent_1","calcDefaultFormat","baseFormat","createCoreApiMap","mouseUp","allPlugins","eventHandlerPlugins","currentUndoSnapshot","coreApiOverride","defaultApi","pluginEventType","beforeDispatch","onEvent","isNested","event_1","tryGetFromCache","selection","rangeCount","getRangeAt","isBegin","insertedNode","refNode","deleteContents","clonedRange","cloneRange","position_1","setEndAfter","nodeToInsert","rootNodeToInsert","rootNodes","shouldInsertListAsText","listNode","setEndBefore","div","newRange","preprocessNode","nodeForCursor","needAddRange","currentRange","removeAllRanges","addRange","handledExclusively","MAXSIZELIMIT","UndoSnapshots","maxSize","snapshots","totalSize","currentIndex","newIndex","removeCount","removedSize","CONTENTSEARCHER_KEY","CACHE_KEY_PREFIX","imageFile","reader","FileReader","onload","src","maxWidth","readAsDataURL","getTableCellWidth","columns","fragment","createDocumentFragment","cellSpacing","cellPadding","j","width","textOrRange","backupRange","alignment","align","textAlign","direction","processList_1","indentation","toggleTagCore_1","BLOCKQUOTE_TAG","borderColor","paddingLeft","PRE_TAG","CODE_TAG","CODE_NODE_TAG","codeBlock","level","wrapped","header","createCommand","winKey","macKey","action","commands","cacheGetCommand","shiftKey","cmd","stopPropagation","cacheGetTableCell","firstTd","step","isUp","targetTd","newContainer","toggleListAndPreventDefault","listInfo","cacheGetListElement","listElement","br","textBeforeCursor","rangeToDelete","tempBr","styleList","HTMLOListElement","ol","parentOl","listStyle","QUOTE_TAG","STRUCTURED_TAGS","cacheGetQuoteChild","quote","splitQuote","childOfQuote","buildClipboardData_1","fragmentHandler_1","textToHtml_1","roosterjs_editor_api_2","roosterjs_html_sanitizer_1","preserved","attributeCallbacks","onPaste","pasteOriginal","snapshotBeforePaste","originalFormat","getCurrentFormat","rawHtml","sanitizeHtml","sanitizer","pasteDisposer","paste","detectPasteOption","pasteText","pasteAndMergeFormat","pasteOption","mergeCurrentFormat","applyTextFormat","internalPaste","parents","parents_1","convertGlobalCssToInlineCss","currentStyles","sanitize","CONTAINER_HTML","originalSelectionRange","tempDiv","pasteDiv","getTempDivForPaste","retrieveHtmlViaTempDiv","convertPastedContentFromExcel_1","convertPastedContentFromWord_1","WORD_ATTRIBUTE_NAME","WORD_ATTRIBUTE_VALUE","EXCEL_ATTRIBUTE_NAME","EXCEL_ATTRIBUTE_VALUE","LAST_TD_END_REGEX","LAST_TR_END_REGEX","LAST_TR_REGEX","LAST_TABLE_REGEX","querySelector","trMatch","tableMatch","styleCallbacks","border","additionalAllowAttributes","styleNode","cloneObject_1","getAllowedValues_1","elementCallbacks","getStyleCallbacks","allowedTags","getAllowedTags","additionalAllowedTags","allowedAttributes","getAllowedAttributes","defaultStyleValues","getDefaultStyleValues","additionalDefaultStyleValues","additionalGlobalStyleNodes","allowPreserveWhiteSpace","convertInlineCss","additionalStyleNodes","currentElementOrStyle","HTMLElement","convertCssOnly","processNode","styleNodes","toArray","styleSheets_1","reverse","sheet","styleSheet","styleRule","cssRules","cssText","CSSRule","STYLE_RULE","selectorText","currentStyle","context","isElement","ELEMENT_NODE","isText","TEXT_NODE","allowElement","insidePRE","thisStyle","processAttributes","processCss","child","next","getAttributeNode","pair","isInheritable","keep","attribute","name_1","list","ALLOWED_HTML_TAGS","ALLOWED_HTML_ATTRIBUTES","DEFAULT_STYLE_VALUES","background-color","border-bottom-color","border-bottom-style","border-bottom-width","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-left-color","border-left-style","border-left-width","border-right-color","border-right-style","border-right-width","border-top-color","border-top-style","border-top-width","outline-color","outline-style","outline-width","overflow","text-decoration","-webkit-text-stroke-width","word-wrap","margin-left","margin-right","padding","padding-top","padding-left","padding-right","padding-bottom","border-top","border-left","border-right","border-bottom","vertical-align","float","removeValue","removeWidthForLiAndDiv","unique","index","self","additionalTags","additionalAttributes","toLocaleLowerCase","additionalDefaultStyles","callbacks","wordConverter_1","WordConverterArguments_1","converterUtils_1","wordConverter","createWordConverter","wordConverterArgs","createWordConverterArguments","processNodesDiscovery","processNodeConvert","CustomData_1","nextUniqueId","numBulletsConverted","numNumberedConverted","LevelLists_1","lists","listItems","currentListIdsByLevels","lastProcessedItem","LOOKUP_DEPTH","UNIQUE_LIST_ID_CUSTOM_DATA","MSO_LIST_STYLE_NAME","LINE_BREAKS","getOrCreateListForNode","metadata","listMetadata","recurringGetOrCreateListAtNode","possibleList","getRealPreviousSibling","listId","uniqueListId","convertListIfNeeded","cleanupListIgnore","levels","nodesToRemove","isEmptySpan","fixWordListComments","isIgnoreNode","getListItemMetadata","listatt","getStyleValue","listprops","wordListId","originalNode","isFakeBullet","fakeBullet","getFakeBulletText","removeComments","nextElement","endComment","getRealNextSibling","newSpan","prevSibling","isEmptyTextNode","textStyle","inStyles","nvpair","resetCurrentLists","args","ll","itemMetadata","levelInfo","ignore","numberOfItems","secondFakeBullet","firstFakeBullet","className","parseLink","lines","lineEnd_1","line","WATERMARK_REGEX","watermark","handleWatermark","showHideWatermark","blur","hideWatermark","isWatermarkShowing","removeWartermarkFromHtml","ignoreCachedState","showWatermark","watermarkNode","pageX","onMouseOver","calcAndShowHandle","onMouseDown","initialPageX","attachMouseEvents","getResizeHandle","borderWidth","cancelEvent","onMouseMove","adjustHandle","detachMouseEvents","isNaN","newWidth_1","clientWidth","isRtl","setTableColumnWidth","onMouseOverDisposer","clickIntoCurrentTd","getPosition","top_1","handle","offsetLeft","offsetWidth","height","offsetHeight","offsetParent","scrollLeft","offsetTop","scrollTop","document_2","ImageResize_1","ImageResize","BEGIN_TAG","END_TAG","EXTRACT_HTML_REGEX","minWidth","minHeight","selectionBorderColor","forcePreserveRatio","resizableImageSelector","startResize","img","getSelectedImage","startPageX","startPageY","pageY","startWidth","startHeight","clientHeight","doResize","finishResize","cursor","stopEvent","widthChange","heightChange","newWidth","isWest","newHeight","isNorth","ratio","resizeDiv","removeResizeDivIfAny","previous","removeResizeDiv","onBlur","hideResizeHandle","onDragStart","dragstart","contentEditable","currentImg","showResizeHandle","event_2","event_3","extractHtml","createResizeDiv","selectImageAfterUnSelect","referenceNode","createComment","pointerEvents","comment","arguments","getElementsByTagName"],"mappings":"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","file":"rooster-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 64);\n","export { default as NodeBlockElement } from './blockElements/NodeBlockElement';\r\nexport { default as getBlockElementAtNode } from './blockElements/getBlockElementAtNode';\r\nexport { default as getFirstLastBlockElement } from './blockElements/getFirstLastBlockElement';\r\nexport { default as StartEndBlockElement } from './blockElements/StartEndBlockElement';\r\n\r\nexport { default as ContentTraverser } from './contentTraverser/ContentTraverser';\r\nexport { default as PositionContentSearcher } from './contentTraverser/PositionContentSearcher';\r\n\r\nexport { default as getInlineElementAtNode } from './inlineElements/getInlineElementAtNode';\r\nexport { default as ImageInlineElement } from './inlineElements/ImageInlineElement';\r\nexport { default as LinkInlineElement } from './inlineElements/LinkInlineElement';\r\nexport { default as NodeInlineElement } from './inlineElements/NodeInlineElement';\r\nexport { default as PartialInlineElement } from './inlineElements/PartialInlineElement';\r\n\r\nexport { default as applyTextStyle } from './utils/applyTextStyle';\r\nexport { default as Browser, getBrowserInfo } from './utils/Browser';\r\nexport { default as applyFormat } from './utils/applyFormat';\r\nexport { default as changeElementTag } from './utils/changeElementTag';\r\nexport { default as collapseNodes } from './utils/collapseNodes';\r\nexport { default as contains } from './utils/contains';\r\nexport { default as extractClipboardEvent } from './utils/extractClipboardEvent';\r\nexport { default as findClosestElementAncestor } from './utils/findClosestElementAncestor';\r\nexport { default as fromHtml } from './utils/fromHtml';\r\nexport { default as getComputedStyles, getComputedStyle } from './utils/getComputedStyles';\r\nexport { default as getTagOfNode } from './utils/getTagOfNode';\r\nexport { default as isBlockElement } from './utils/isBlockElement';\r\nexport { default as isNodeEmpty } from './utils/isNodeEmpty';\r\nexport { default as isVoidHtmlElement } from './utils/isVoidHtmlElement';\r\nexport { default as matchLink } from './utils/matchLink';\r\nexport { default as queryElements } from './utils/queryElements';\r\nexport { default as splitParentNode, splitBalancedNodeRange } from './utils/splitParentNode';\r\nexport { default as unwrap } from './utils/unwrap';\r\nexport { default as wrap } from './utils/wrap';\r\nexport { getNextLeafSibling, getPreviousLeafSibling } from './utils/getLeafSibling';\r\nexport { getFirstLeafNode, getLastLeafNode } from './utils/getLeafNode';\r\n\r\nexport { default as VTable, VCell } from './table/VTable';\r\n\r\nexport { default as Position } from './selection/Position';\r\nexport { default as createRange } from './selection/createRange';\r\nexport { default as getPositionRect } from './selection/getPositionRect';\r\nexport { default as isPositionAtBeginningOf } from './selection/isPositionAtBeginningOf';\r\nexport {\r\n    default as getSelectionPath,\r\n    getRangeFromSelectionPath,\r\n} from './selection/getSelectionPath';\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Test if a node contains another node\r\n * @param container The container node\r\n * @param contained The node to check if it is inside container\r\n * @param treatSameNodeAsContain When container and contained are the same node,\r\n * return true if this param is set to true, otherwise return false. Default value is false\r\n * @returns True if contained is insied container, or they are the same node when treatSameNodeAsContain is true.\r\n * Otherwise false.\r\n */\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean;\r\n\r\n/**\r\n * Test if a node contains a given range\r\n * @param container The container node\r\n * @param contained The range to check if it is inside container\r\n * @returns True if contained is insied container, otherwise false\r\n */\r\nexport default function contains(container: Node, contained: Range): boolean;\r\n\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node | Range,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean {\r\n    if (!container || !contained) {\r\n        return false;\r\n    }\r\n\r\n    if (treatSameNodeAsContain && container == contained) {\r\n        return true;\r\n    }\r\n\r\n    if (!(contained instanceof Node)) {\r\n        contained = contained && contained.commonAncestorContainer;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (contained && contained.nodeType == NodeType.Text) {\r\n        contained = contained.parentNode;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (container.nodeType != NodeType.Element) {\r\n        return !!treatSameNodeAsContain && container == contained;\r\n    }\r\n\r\n    return !!(treatSameNodeAsContain || container != contained) && container.contains(contained);\r\n}\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the html tag of a node, or empty if it is not an element\r\n * @param node The node to get tag of\r\n * @returns Tag name in upper case if the given node is an Element, or empty string otherwise\r\n */\r\nexport default function getTagOfNode(node: Node): string {\r\n    return node && node.nodeType == NodeType.Element ? (<Element>node).tagName.toUpperCase() : '';\r\n}\r\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a position in DOM tree by the node and its offset index\r\n */\r\nexport default class Position implements NodePosition {\r\n    readonly node: Node;\r\n    readonly element: HTMLElement;\r\n    readonly offset: number;\r\n    readonly isAtEnd: boolean;\r\n\r\n    /**\r\n     * Clone and validate a position from existing position.\r\n     * If the given position has invalid offset, this function will return a corrected value.\r\n     * @param position The original position to clone from\r\n     */\r\n    constructor(position: NodePosition);\r\n\r\n    /**\r\n     * Create a Position from node and an offset number\r\n     * @param node The node of this position\r\n     * @param offset Offset of this position\r\n     */\r\n    constructor(node: Node, offset: number);\r\n\r\n    /**\r\n     * Create a Position from node and a type of position\r\n     * @param node The node of this position\r\n     * @param positionType Type of the postion, can be Begin, End, Before, After\r\n     */\r\n    constructor(node: Node, positionType: PositionType);\r\n\r\n    constructor(nodeOrPosition: Node | NodePosition, offsetOrPosType?: number) {\r\n        if ((<NodePosition>nodeOrPosition).node) {\r\n            this.node = (<NodePosition>nodeOrPosition).node;\r\n            offsetOrPosType = (<NodePosition>nodeOrPosition).offset;\r\n        } else {\r\n            this.node = <Node>nodeOrPosition;\r\n        }\r\n\r\n        switch (offsetOrPosType) {\r\n            case PositionType.Before:\r\n                this.offset = getIndexOfNode(this.node);\r\n                this.node = this.node.parentNode;\r\n                this.isAtEnd = false;\r\n                break;\r\n\r\n            case PositionType.After:\r\n                this.offset = getIndexOfNode(this.node) + 1;\r\n                this.isAtEnd = !this.node.nextSibling;\r\n                this.node = this.node.parentNode;\r\n                break;\r\n\r\n            case PositionType.End:\r\n                this.offset = getEndOffset(this.node);\r\n                this.isAtEnd = true;\r\n                break;\r\n\r\n            default:\r\n                let endOffset = getEndOffset(this.node);\r\n                this.offset = Math.max(0, Math.min(<number>offsetOrPosType, endOffset));\r\n                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;\r\n                break;\r\n        }\r\n\r\n        this.element = findClosestElementAncestor(this.node);\r\n    }\r\n\r\n    /**\r\n     * Normalize this position to the leaf node, return the normalize result.\r\n     * If current position is already using leaf node, return this position object itself\r\n     */\r\n    normalize(): NodePosition {\r\n        if (this.node.nodeType == NodeType.Text || !this.node.firstChild) {\r\n            return this;\r\n        }\r\n\r\n        let node = this.node;\r\n        let newOffset: number | PositionType.Begin | PositionType.End = this.isAtEnd\r\n            ? PositionType.End\r\n            : this.offset;\r\n        while (node.nodeType == NodeType.Element && node.firstChild) {\r\n            node =\r\n                newOffset == PositionType.Begin\r\n                    ? node.firstChild\r\n                    : newOffset == PositionType.End\r\n                    ? node.lastChild\r\n                    : node.childNodes[<number>newOffset];\r\n            newOffset = this.isAtEnd ? PositionType.End : PositionType.Begin;\r\n        }\r\n        return new Position(node, newOffset);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is equal to the given position\r\n     * @param position The position to check\r\n     */\r\n    equalTo(position: NodePosition): boolean {\r\n        return (\r\n            position &&\r\n            (this == position ||\r\n                (this.node == position.node &&\r\n                    this.offset == position.offset &&\r\n                    this.isAtEnd == position.isAtEnd))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if this position is after the given position\r\n     */\r\n    isAfter(position: NodePosition): boolean {\r\n        return this.node == position.node\r\n            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset\r\n            : isNodeAfter(this.node, position.node);\r\n    }\r\n\r\n    /**\r\n     * Move this position with offset, returns a new position with a valid offset in the same node\r\n     * @param offset Offset to move with\r\n     */\r\n    move(offset: number) {\r\n        return new Position(this.node, Math.max(this.offset + offset, 0));\r\n    }\r\n\r\n    /**\r\n     * Get start position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getStart(range: Range) {\r\n        return new Position(range.startContainer, range.startOffset);\r\n    }\r\n\r\n    /**\r\n     * Get end position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getEnd(range: Range) {\r\n        return new Position(range.endContainer, range.endOffset);\r\n    }\r\n}\r\n\r\nfunction getIndexOfNode(node: Node): number {\r\n    let i = 0;\r\n    while ((node = node.previousSibling)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nfunction getEndOffset(node: Node): number {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return node.nodeValue.length;\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return node.childNodes.length;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n","import { ChangeSource, DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Execute a document command\r\n * @param editor The editor instance\r\n * @param command The command to execute\r\n * @param addUndoSnapshotWhenCollapsed Optional, set to true to always add undo snapshot even current selection is collapsed.\r\n * Default value is false.\r\n * @param doWorkaroundForList Optional, set to true to do workaround for list in order to keep current format.\r\n * Default value is false.\r\n */\r\nexport default function execCommand(editor: Editor, command: DocumentCommand) {\r\n    editor.focus();\r\n    let formatter = () => editor.getDocument().execCommand(command, false, null);\r\n\r\n    let range = editor.getSelectionRange();\r\n    if (range && range.collapsed) {\r\n        editor.addUndoSnapshot();\r\n        formatter();\r\n    } else {\r\n        editor.addUndoSnapshot(formatter, ChangeSource.Format);\r\n    }\r\n}\r\n","// Interfaces\r\nexport {\r\n    default as ContentEditFeature,\r\n    GenericContentEditFeature,\r\n    Keys,\r\n} from './interfaces/ContentEditFeature';\r\nexport {\r\n    default as EditorCore,\r\n    CorePlugins,\r\n    CoreApiMap,\r\n    AttachDomEvent,\r\n    EditWithUndo,\r\n    Focus,\r\n    GetCustomData,\r\n    GetSelectionRange,\r\n    HasFocus,\r\n    InsertNode,\r\n    Select,\r\n    TriggerEvent,\r\n} from './interfaces/EditorCore';\r\nexport { default as EditorOptions } from './interfaces/EditorOptions';\r\nexport { default as EditorPlugin } from './interfaces/EditorPlugin';\r\nexport { default as UndoService } from './interfaces/UndoService';\r\nexport { default as UndoSnapshotsService } from './interfaces/UndoSnapshotsService';\r\n\r\n// Classes\r\nexport { default as Editor } from './editor/Editor';\r\nexport { default as Undo } from './undo/Undo';\r\n\r\n// Core Plugins\r\nexport { default as EditPlugin } from './corePlugins/EditPlugin';\r\nexport { default as MouseUpPlugin } from './corePlugins/MouseUpPlugin';\r\nexport { default as DOMEventPlugin } from './corePlugins/DOMEventPlugin';\r\nexport { default as TypeInContainerPlugin } from './corePlugins/TypeInContainerPlugin';\r\n\r\n// Event APIs\r\nexport { default as cacheGetEventData } from './eventApi/cacheGetEventData';\r\nexport { default as clearEventDataCache } from './eventApi/clearEventDataCache';\r\nexport {\r\n    cacheGetContentSearcher,\r\n    clearContentSearcherCache,\r\n} from './eventApi/cacheGetContentSearcher';\r\nexport { default as cacheGetElementAtCursor } from './eventApi/cacheGetElementAtCursor';\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport NodeBlockElement from './NodeBlockElement';\r\nimport StartEndBlockElement from './StartEndBlockElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This produces a block element from a a node\r\n * It needs to account for various HTML structure. Examples:\r\n * 1) <root><div>abc</div></root>\r\n *   This is most common the case, user passes in a node pointing to abc, and get back a block representing <div>abc</div>\r\n * 2) <root><p><br></p></root>\r\n *   Common content for empty block, user passes node pointing to <br>, and get back a block representing <p><br></p>\r\n * 3) <root>abc</root>\r\n *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc\r\n *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node\r\n * 4) <root><div>abc<br>123</div></root>\r\n *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a <BR> to create a link break. There're two blocks:\r\n *   block1: 1) abc<br> block2: 123\r\n * 5) <root><div>abc<div>123</div></div></root>\r\n *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) <div>123</div>\r\n * 6) <root><div>abc<span>123<br>456</span></div></root>\r\n *   This is really tricky. Essentially there is a <BR> in middle of a span breaking the span into two blocks;\r\n *   block1: abc<span>123<br> block2: 456\r\n * In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:\r\n * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered\r\n * 2) same for identifying tail\r\n * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node\r\n * @param rootNode Root node of the scope, the block element will be inside of this node\r\n * @param node The node to get BlockElement start from\r\n */\r\nexport default function getBlockElementAtNode(rootNode: Node, node: Node): BlockElement {\r\n    if (!contains(rootNode, node)) {\r\n        return null;\r\n    }\r\n\r\n    // Identify the containing block. This serves as ceiling for traversing down below\r\n    // NOTE: this container block could be just the rootNode,\r\n    // which cannot be used to create block element. We will special case handle it later on\r\n    let containerBlockNode = StartEndBlockElement.getBlockContext(node);\r\n    if (containerBlockNode == node) {\r\n        return new NodeBlockElement(containerBlockNode);\r\n    }\r\n\r\n    // Find the head and leaf node in the block\r\n    let headNode = findHeadTailLeafNode(node, containerBlockNode, false /*isTail*/);\r\n    let tailNode = findHeadTailLeafNode(node, containerBlockNode, true /*isTail*/);\r\n\r\n    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to\r\n    // 1) <root><div>hello<br></div></root>, head: hello, tail: <br>\r\n    // 2) <root><div>hello<span style=\"font-family: Arial\">world</span></div></root>, head: hello, tail: world\r\n    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block\r\n    // So we shall try to collapse as much as we can to the nearest common ancester\r\n    let nodes = collapseNodes(rootNode, headNode, tailNode, false /*canSplitParent*/);\r\n    headNode = nodes[0];\r\n    tailNode = nodes[nodes.length - 1];\r\n\r\n    if (headNode.parentNode != tailNode.parentNode) {\r\n        // Un-Balanced start and end, create a start-end block\r\n        return new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    } else {\r\n        // Balanced start and end (point to same parent), need to see if further collapsing can be done\r\n        while (!headNode.previousSibling && !tailNode.nextSibling) {\r\n            let parentNode = headNode.parentNode;\r\n            if (parentNode == containerBlockNode) {\r\n                // Has reached the container block\r\n                if (containerBlockNode != rootNode) {\r\n                    // If the container block is not the root, use the container block\r\n                    headNode = tailNode = parentNode;\r\n                }\r\n                break;\r\n            } else {\r\n                // Continue collapsing to parent\r\n                headNode = tailNode = parentNode;\r\n            }\r\n        }\r\n\r\n        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block\r\n        return headNode == tailNode && isBlockElement(headNode)\r\n            ? new NodeBlockElement(headNode as HTMLElement)\r\n            : new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    }\r\n}\r\n\r\n/**\r\n * Given a node and container block, identify the first/last leaf node\r\n * A leaf node is defined as deepest first/last node in a block\r\n * i.e. <div><span style=\"font-family: Arial\">abc</span></div>, abc is the head leaf of the block\r\n * Often <br> or a child <div> is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf\r\n * i.e. <div>123<br>abc</div>, abc is the head of a block because of a previous sibling <br>\r\n * i.e. <div><div>123</div>abc</div>, abc is also the head of a block because of a previous sibling <div>\r\n */\r\nfunction findHeadTailLeafNode(node: Node, containerBlockNode: Node, isTail: boolean): Node {\r\n    let result = node;\r\n\r\n    if (getTagOfNode(result) == 'BR' && isTail) {\r\n        return result;\r\n    }\r\n\r\n    while (result) {\r\n        let sibling = node;\r\n        while (!(sibling = isTail ? node.nextSibling : node.previousSibling)) {\r\n            node = node.parentNode;\r\n            if (node == containerBlockNode) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        while (sibling) {\r\n            if (isBlockElement(sibling)) {\r\n                return result;\r\n            } else if (getTagOfNode(sibling) == 'BR') {\r\n                return isTail ? sibling : result;\r\n            }\r\n\r\n            node = sibling;\r\n            sibling = isTail ? node.firstChild : node.lastChild;\r\n        }\r\n\r\n        result = node;\r\n    }\r\n    return result;\r\n}\r\n","import contains from './contains';\r\nimport shouldSkipNode from './shouldSkipNode';\r\n\r\n/**\r\n * This walks forwards/backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node\r\n */\r\nexport function getLeafSibling(rootNode: Node, startNode: Node, isNext: boolean): Node {\r\n    let result = null;\r\n    let getSibling = isNext\r\n        ? (node: Node) => node.nextSibling\r\n        : (node: Node) => node.previousSibling;\r\n    let getChild = isNext ? (node: Node) => node.firstChild : (node: Node) => node.lastChild;\r\n    if (contains(rootNode, startNode)) {\r\n        let curNode = startNode;\r\n        let shouldContinue = true;\r\n\r\n        while (shouldContinue) {\r\n            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent\r\n            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)\r\n            let parentNode = curNode.parentNode;\r\n            curNode = getSibling(curNode);\r\n            while (!curNode && parentNode != rootNode) {\r\n                curNode = getSibling(parentNode);\r\n                parentNode = parentNode.parentNode;\r\n            }\r\n\r\n            // Now traverse down to get first/last child\r\n            while (curNode && getChild(curNode)) {\r\n                curNode = getChild(curNode);\r\n            }\r\n\r\n            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so\r\n            shouldContinue = curNode && shouldSkipNode(curNode);\r\n            if (!shouldContinue) {\r\n                // Found a good leaf node, assign and exit\r\n                result = curNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This walks forwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n */\r\nexport function getNextLeafSibling(rootNode: Node, startNode: Node): Node {\r\n    return getLeafSibling(rootNode, startNode, true /*isNext*/);\r\n}\r\n\r\n/**\r\n * This walks backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n */\r\nexport function getPreviousLeafSibling(rootNode: Node, startNode: Node): Node {\r\n    return getLeafSibling(rootNode, startNode, false /*isNext*/);\r\n}\r\n","export { default as changeFontSize, FONT_SIZES } from './format/changeFontSize';\r\nexport {\r\n    default as clearBlockFormat,\r\n    TAGS_TO_UNWRAP,\r\n    TAGS_TO_STOP_UNWRAP,\r\n    ATTRIBUTES_TO_PRESERVE,\r\n} from './format/clearBlockFormat';\r\nexport { default as clearFormat } from './format/clearFormat';\r\nexport { default as createLink } from './format/createLink';\r\nexport { default as getFormatState } from './format/getFormatState';\r\nexport { default as insertImage } from './format/insertImage';\r\nexport { default as insertTable } from './table/insertTable';\r\nexport { default as editTable } from './table/editTable';\r\nexport { default as formatTable } from './table/formatTable';\r\nexport { default as removeLink } from './format/removeLink';\r\nexport { default as replaceWithNode } from './format/replaceWithNode';\r\nexport { default as setAlignment } from './format/setAlignment';\r\nexport { default as setBackgroundColor } from './format/setBackgroundColor';\r\nexport { default as setTextColor } from './format/setTextColor';\r\nexport { default as setDirection } from './format/setDirection';\r\nexport { default as setFontName } from './format/setFontName';\r\nexport { default as setFontSize } from './format/setFontSize';\r\nexport { default as setImageAltText } from './format/setImageAltText';\r\nexport { default as setIndentation } from './format/setIndentation';\r\nexport { default as toggleBold } from './format/toggleBold';\r\nexport { default as toggleBullet } from './format/toggleBullet';\r\nexport { default as toggleItalic } from './format/toggleItalic';\r\nexport { default as toggleNumbering } from './format/toggleNumbering';\r\nexport { default as toggleBlockQuote } from './format/toggleBlockQuote';\r\nexport { default as toggleCodeBlock } from './format/toggleCodeBlock';\r\nexport { default as toggleStrikethrough } from './format/toggleStrikethrough';\r\nexport { default as toggleSubscript } from './format/toggleSubscript';\r\nexport { default as toggleSuperscript } from './format/toggleSuperscript';\r\nexport { default as toggleUnderline } from './format/toggleUnderline';\r\nexport { default as toggleHeader } from './format/toggleHeader';\r\n","import { DocumentPosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Checks if node1 is after node2\r\n * @param node1 The node to check if it is after another node\r\n * @param node2 The node to check if another node is after this one\r\n * @returns True if node1 is after node2, otherwise false\r\n */\r\nexport default function isNodeAfter(node1: Node, node2: Node): boolean {\r\n    return !!(\r\n        node1 &&\r\n        node2 &&\r\n        (node2.compareDocumentPosition(node1) & DocumentPosition.Following) ==\r\n            DocumentPosition.Following\r\n    );\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport ImageInlineElement from './ImageInlineElement';\r\nimport LinkInlineElement from './LinkInlineElement';\r\nimport NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param rootNode The root node of current scope\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(rootNode: Node, node: Node): InlineElement;\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param parentBlock Parent BlockElement of this node\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(\r\n    parentBlock: BlockElement,\r\n    node: Node\r\n): InlineElement;\r\n\r\nexport default function getInlineElementAtNode(\r\n    parent: Node | BlockElement,\r\n    node: Node\r\n): InlineElement {\r\n    // An inline element has to be in a block element, get the block first and then resolve through the factory\r\n    let parentBlock = parent instanceof Node ? getBlockElementAtNode(parent, node) : parent;\r\n    return node && parentBlock && resolveInlineElement(node, parentBlock);\r\n}\r\n\r\n/**\r\n * Resolve an inline element by a leaf node\r\n * @param node The node to resolve from\r\n * @param parentBlock The parent block element\r\n */\r\nfunction resolveInlineElement(node: Node, parentBlock: BlockElement): InlineElement {\r\n    let nodeChain = [node];\r\n    for (\r\n        let parent = node.parentNode;\r\n        parent && parentBlock.contains(parent);\r\n        parent = parent.parentNode\r\n    ) {\r\n        nodeChain.push(parent);\r\n    }\r\n\r\n    let inlineElement: InlineElement;\r\n\r\n    for (let i = nodeChain.length - 1; i >= 0 && !inlineElement; i--) {\r\n        let currentNode = nodeChain[i];\r\n        let tag = getTagOfNode(currentNode);\r\n        if (tag == 'A') {\r\n            inlineElement = new LinkInlineElement(currentNode, parentBlock);\r\n        } else if (tag == 'IMG') {\r\n            inlineElement = new ImageInlineElement(currentNode, parentBlock);\r\n        }\r\n    }\r\n\r\n    return inlineElement || new NodeInlineElement(node, parentBlock);\r\n}\r\n","import isVoidHtmlElement from '../utils/isVoidHtmlElement';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create a Range object with the given Node(s)\r\n * @param node The node to select\r\n * @param endNode The optional end node to select. When specified, range will start before the node and end after endNode\r\n */\r\nexport default function createRange(node: Node, endNode?: Node): Range;\r\n\r\n/**\r\n * Create a Range object using start and end position\r\n * @param start The start position\r\n * @param end The end position\r\n */\r\nexport default function createRange(start: NodePosition, end?: NodePosition): Range;\r\n\r\nexport default function createRange(start: NodePosition | Node, end?: NodePosition | Node): Range {\r\n    if (!start) {\r\n        return null;\r\n    } else if (start instanceof Node) {\r\n        end = new Position(<Node>end || start, PositionType.After);\r\n        start = new Position(start, PositionType.Before);\r\n    } else {\r\n        end = <NodePosition>end || start;\r\n    }\r\n\r\n    let range = start.node.ownerDocument.createRange();\r\n    start = getFocusablePosition(start);\r\n    end = getFocusablePosition(end);\r\n    range.setStart(start.node, start.offset);\r\n    range.setEnd(end.node, end.offset);\r\n\r\n    return range;\r\n}\r\n\r\n/**\r\n * Convert to focusable position\r\n * If current node is a void element, we need to move up one level to put cursor outside void element\r\n */\r\nfunction getFocusablePosition(position: NodePosition) {\r\n    return position.node.nodeType == NodeType.Element && isVoidHtmlElement(position.node)\r\n        ? new Position(position.node, position.isAtEnd ? PositionType.After : PositionType.Before)\r\n        : position;\r\n}\r\n","import { applyTextStyle, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { ChangeSource, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\nconst ZERO_WIDTH_SPACE = '\\u200B';\r\n\r\n/**\r\n * Apply inline style to current selection\r\n * @param editor The editor instance\r\n * @param callback The callback function to apply style\r\n */\r\nexport default function applyInlineStyle(editor: Editor, callback: (element: HTMLElement) => any) {\r\n    editor.focus();\r\n    let range = editor.getSelectionRange();\r\n\r\n    if (range && range.collapsed) {\r\n        let node = range.startContainer;\r\n        let isEmptySpan =\r\n            getTagOfNode(node) == 'SPAN' &&\r\n            (!node.firstChild ||\r\n                (getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));\r\n        if (isEmptySpan) {\r\n            editor.addUndoSnapshot();\r\n            callback(node as HTMLElement);\r\n        } else {\r\n            let isZWSNode =\r\n                node &&\r\n                node.nodeType == NodeType.Text &&\r\n                node.nodeValue == ZERO_WIDTH_SPACE &&\r\n                getTagOfNode(node.parentNode) == 'SPAN';\r\n\r\n            if (!isZWSNode) {\r\n                editor.addUndoSnapshot();\r\n                // Create a new text node to hold the selection.\r\n                // Some content is needed to position selection into the span\r\n                // for here, we inject ZWS - zero width space\r\n                node = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);\r\n                range.insertNode(node);\r\n            }\r\n\r\n            applyTextStyle(node, callback);\r\n            editor.select(node, PositionType.End);\r\n        }\r\n    } else {\r\n        // This is start and end node that get the style. The start and end needs to be recorded so that selection\r\n        // can be re-applied post-applying style\r\n        editor.addUndoSnapshot(() => {\r\n            let firstNode: Node;\r\n            let lastNode: Node;\r\n            let contentTraverser = editor.getSelectionTraverser();\r\n            let inlineElement = contentTraverser && contentTraverser.currentInlineElement;\r\n            while (inlineElement) {\r\n                let nextInlineElement = contentTraverser.getNextInlineElement();\r\n                inlineElement.applyStyle(element => {\r\n                    callback(element);\r\n                    firstNode = firstNode || element;\r\n                    lastNode = element;\r\n                });\r\n                inlineElement = nextInlineElement;\r\n            }\r\n            if (firstNode && lastNode) {\r\n                editor.select(firstNode, PositionType.Before, lastNode, PositionType.After);\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","export { default as HtmlSanitizer } from './sanitizer/HtmlSanitizer';\r\nexport { default as HtmlSanitizerOptions } from './types/HtmlSanitizerOptions';\r\nexport { default as SanitizeHtmlOptions } from './types/SanitizeHtmlOptions';\r\nexport { default as htmlToDom, splitWithFragment } from './utils/htmlToDom';\r\nexport { default as getInheritableStyles } from './utils/getInheritableStyles';\r\nexport {\r\n    AttributeCallback,\r\n    AttributeCallbackMap,\r\n    ElementCallback,\r\n    Map,\r\n    StringMap,\r\n    StyleCallback,\r\n    StyleCallbackMap,\r\n    ElementCallbackMap,\r\n} from './types/maps';\r\n","import isNodeAfter from './isNodeAfter';\r\n\r\n/**\r\n * Split parent node of the given node before/after the given node.\r\n * When a parent node contains [A,B,C] and pass B as the given node,\r\n * If split before, the new nodes will be [A][B,C] and returns [A];\r\n * otherwise, it will be [A,B][C] and returns [C].\r\n * @param node The node to split before/after\r\n * @param splitBefore Whether split before or after\r\n * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),\r\n * we remove it. @default false\r\n * @returns The new parent node\r\n */\r\nexport default function splitParentNode(node: Node, splitBefore: boolean): Node {\r\n    if (!node || !node.parentNode) {\r\n        return null;\r\n    }\r\n\r\n    let parentNode = node.parentNode;\r\n    let newParent = parentNode.cloneNode(false /*deep*/) as HTMLElement;\r\n    newParent.removeAttribute('id');\r\n    if (splitBefore) {\r\n        while (parentNode.firstChild && parentNode.firstChild != node) {\r\n            newParent.appendChild(parentNode.firstChild);\r\n        }\r\n    } else {\r\n        while (node.nextSibling) {\r\n            newParent.appendChild(node.nextSibling);\r\n        }\r\n    }\r\n\r\n    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true\r\n    if (newParent.firstChild && newParent.innerHTML != '') {\r\n        parentNode.parentNode.insertBefore(\r\n            newParent,\r\n            splitBefore ? parentNode : parentNode.nextSibling\r\n        );\r\n    } else {\r\n        newParent = null;\r\n    }\r\n\r\n    return newParent;\r\n}\r\n\r\n/**\r\n * Split parent node by a balanced node range\r\n * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.\r\n * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored\r\n * @returns The parent node of the given node range if the given nodes are balanced, otherwise null\r\n */\r\nexport function splitBalancedNodeRange(nodes: Node | Node[]): HTMLElement {\r\n    let start = nodes instanceof Array ? nodes[0] : nodes;\r\n    let end = nodes instanceof Array ? nodes[nodes.length - 1] : nodes;\r\n    let parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;\r\n    if (parentNode) {\r\n        if (isNodeAfter(start, end)) {\r\n            let temp = end;\r\n            end = start;\r\n            start = temp;\r\n        }\r\n        splitParentNode(start, true /*splitBefore*/);\r\n        splitParentNode(end, false /*splitBefore*/);\r\n    }\r\n\r\n    return parentNode as HTMLElement;\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport Position from '../selection/Position';\r\nimport {\r\n    BlockElement,\r\n    InlineElement,\r\n    NodePosition,\r\n    NodeType,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents an inline element that can be reprented by a single html node.\r\n * This serves as base for most inline element as it contains most implentation\r\n * of all operations that can happen on an inline element. Other sub inline elements mostly\r\n * just identify themself for a certain type\r\n */\r\nclass NodeInlineElement implements InlineElement {\r\n    constructor(private containerNode: Node, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * The text content for this inline element\r\n     */\r\n    public getTextContent(): string {\r\n        // nodeValue is better way to retrieve content for a text. Others, just use textContent\r\n        return this.containerNode.nodeType == NodeType.Text\r\n            ? this.containerNode.nodeValue\r\n            : this.containerNode.textContent;\r\n    }\r\n\r\n    /**\r\n     * Get the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.containerNode;\r\n    }\r\n\r\n    // Get the parent block\r\n    public getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of the inline element\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest first child node from the container\r\n        return new Position(this.containerNode, 0).normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the end position of the inline element\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest last child node from the container\r\n        return new Position(this.containerNode, PositionType.End).normalize();\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.containerNode && this.containerNode.nodeType == NodeType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks if an inline element is after the current inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if the given position is contained in the inline element\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        let start = this.getStartPosition();\r\n        let end = this.getEndPosition();\r\n        return pos && pos.isAfter(start) && end.isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to an inline element\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement) => any): void {\r\n        applyTextStyle(this.containerNode, styler);\r\n    }\r\n}\r\n\r\nexport default NodeInlineElement;\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { BlockElement, InlineElement, NodePosition, PositionType } from 'roosterjs-editor-types';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * This is a special version of inline element that identifies a section of an inline element\r\n * We often have the need to cut an inline element in half and perform some operation only on half of an inline element\r\n * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element\r\n * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter\r\n * It also offers some special methods that others don't have, i.e. nextInlineElement etc.\r\n */\r\nclass PartialInlineElement implements InlineElement {\r\n    constructor(\r\n        private inlineElement: InlineElement,\r\n        private start?: NodePosition,\r\n        private end?: NodePosition\r\n    ) {}\r\n\r\n    /**\r\n     * Get the full inline element that this partial inline decorates\r\n     */\r\n    public getDecoratedInline(): InlineElement {\r\n        return this.inlineElement;\r\n    }\r\n\r\n    /**\r\n     * Gets the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.inlineElement.getContainerNode();\r\n    }\r\n\r\n    /**\r\n     * Gets the parent block\r\n     */\r\n    public getParentBlock(): BlockElement {\r\n        return this.inlineElement.getParentBlock();\r\n    }\r\n\r\n    /**\r\n     * Gets the text content\r\n     */\r\n    public getTextContent(): string {\r\n        let range = createRange(this.getStartPosition(), this.getEndPosition());\r\n\r\n        return range.toString();\r\n    }\r\n\r\n    /**\r\n     * Get start position of this inline element.\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        return this.start || this.inlineElement.getStartPosition();\r\n    }\r\n\r\n    /**\r\n     * Get end position of this inline element.\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        return this.end || this.inlineElement.getEndPosition();\r\n    }\r\n\r\n    /**\r\n     * Get next partial inline element if it is not at the end boundary yet\r\n     */\r\n    public get nextInlineElement(): PartialInlineElement {\r\n        return this.end && new PartialInlineElement(this.inlineElement, this.end, null);\r\n    }\r\n\r\n    /**\r\n     * Get previous partial inline element if it is not at the begin boundary yet\r\n     */\r\n    public get previousInlineElement(): PartialInlineElement {\r\n        return this.start && new PartialInlineElement(this.inlineElement, null, this.start);\r\n    }\r\n\r\n    /**\r\n     * Checks if it contains a position\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.inlineElement && this.inlineElement.isTextualInlineElement();\r\n    }\r\n\r\n    /**\r\n     * Check if this inline element is after the other inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        let thisStart = this.getStartPosition();\r\n        let otherEnd = inlineElement && inlineElement.getEndPosition();\r\n        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));\r\n    }\r\n\r\n    /**\r\n     * apply style\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement) => any) {\r\n        let from = this.getStartPosition().normalize();\r\n        let to = this.getEndPosition().normalize();\r\n        let container = this.getContainerNode();\r\n\r\n        if (from.isAtEnd) {\r\n            let nextNode = getNextLeafSibling(container, from.node);\r\n            from = nextNode ? new Position(nextNode, PositionType.Begin) : null;\r\n        }\r\n        if (to.offset == 0) {\r\n            let previousNode = getPreviousLeafSibling(container, to.node);\r\n            to = previousNode ? new Position(previousNode, PositionType.End) : null;\r\n        }\r\n\r\n        applyTextStyle(container, styler, from, to);\r\n    }\r\n}\r\n\r\nexport default PartialInlineElement;\r\n","import contains from '../utils/contains';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents a content block that can be reprented by a single html block type element.\r\n * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.\r\n */\r\nexport default class NodeBlockElement implements BlockElement {\r\n    constructor(private element: HTMLElement) {}\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the start node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the end node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Checks if it refers to same block\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        // Ideally there is only one unique way to generate a block so we only need to compare the startNode\r\n        return this.element == blockElement.getStartNode();\r\n    }\r\n\r\n    /**\r\n     * Checks if a block is after the current block\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        // if the block's startNode is after current node endEnd, we say it is after\r\n        return isNodeAfter(this.element, blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if a certain html node is within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return contains(this.element, node, true /*treatSameNodeAsContain*/);\r\n    }\r\n}\r\n","import contains from './contains';\r\nimport splitParentNode from './splitParentNode';\r\n\r\n/**\r\n * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n * split parent nodes if necessary\r\n * @param root The root node of the scope\r\n * @param start The start node\r\n * @param end The end node\r\n * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n * and the returned nodes will be all nodes from start trhough end after splitting\r\n * False to disallow split parent\r\n * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n * otherwise just return start and end\r\n */\r\nexport default function collapseNodes(\r\n    root: Node,\r\n    start: Node,\r\n    end: Node,\r\n    canSplitParent: boolean\r\n): Node[] {\r\n    if (!contains(root, start) || !contains(root, end)) {\r\n        return [];\r\n    }\r\n\r\n    start = collapse(root, start, end, true /*isStart*/, canSplitParent);\r\n    end = collapse(root, end, start, false /*isStart*/, canSplitParent);\r\n\r\n    if (contains(start, end, true /*treateSameNodeAsContain*/)) {\r\n        return [start];\r\n    } else if (contains(end, start)) {\r\n        return [end];\r\n    } else if (start.parentNode == end.parentNode) {\r\n        let nodes = [].slice.call(start.parentNode.childNodes) as Node[];\r\n        let startIndex = nodes.indexOf(start);\r\n        let endIndex = nodes.indexOf(end);\r\n        return nodes.slice(startIndex, endIndex + 1);\r\n    } else {\r\n        return [start, end];\r\n    }\r\n}\r\n\r\nfunction collapse(\r\n    root: Node,\r\n    node: Node,\r\n    ref: Node,\r\n    isStart: boolean,\r\n    canSplitParent: boolean\r\n): Node {\r\n    while (node.parentNode != root && !contains(node.parentNode, ref)) {\r\n        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {\r\n            if (!canSplitParent) {\r\n                break;\r\n            }\r\n            splitParentNode(node, isStart);\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return node;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\nconst BLOCK_ELEMENT_TAGS = 'ADDRESS,ARTICLE,ASIDE,BLOCKQUOTE,CANVAS,DD,DIV,DL,DT,FIELDSET,FIGCAPTION,FIGURE,FOOTER,FORM,H1,H2,H3,H4,H5,H6,HEADER,HR,LI,MAIN,NAV,NOSCRIPT,OL,OUTPUT,P,PRE,SECTION,TABLE,TD,TH,TFOOT,UL,VIDEO'.split(\r\n    ','\r\n);\r\nconst BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table-cell'];\r\n\r\n/**\r\n * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.\r\n * @param node The node to check\r\n * @returns True if the node is a block element, otherwise false\r\n */\r\nexport default function isBlockElement(node: Node): boolean {\r\n    let tag = getTagOfNode(node);\r\n    return !!(\r\n        tag &&\r\n        (BLOCK_DISPLAY_STYLES.indexOf((<HTMLElement>node).style.display) >= 0 ||\r\n            BLOCK_ELEMENT_TAGS.indexOf(tag) >= 0)\r\n    );\r\n}\r\n","import fromHtml from './fromHtml';\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML tag name\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap<T extends keyof HTMLElementTagNameMap>(\r\n    nodes: Node | Node[],\r\n    wrapper?: T\r\n): HTMLElementTagNameMap[T];\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML string, default value is DIV\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string): HTMLElement;\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML element, default value is a new DIV element\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: HTMLElement): HTMLElement;\r\n\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string | HTMLElement): HTMLElement {\r\n    nodes = !nodes ? [] : nodes instanceof Node ? [nodes] : nodes;\r\n    if (nodes.length == 0 || !nodes[0]) {\r\n        return null;\r\n    }\r\n\r\n    if (!(wrapper instanceof Element)) {\r\n        let document = nodes[0].ownerDocument;\r\n        wrapper = wrapper || 'div';\r\n        wrapper = /^\\w+$/.test(wrapper)\r\n            ? document.createElement(wrapper)\r\n            : (fromHtml(wrapper, document)[0] as HTMLElement);\r\n    }\r\n\r\n    let parentNode = nodes[0].parentNode;\r\n\r\n    if (parentNode) {\r\n        parentNode.insertBefore(wrapper, nodes[0]);\r\n    }\r\n\r\n    for (let node of nodes) {\r\n        wrapper.appendChild(node);\r\n    }\r\n\r\n    return wrapper;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport Position from '../selection/Position';\r\nimport wrap from './wrap';\r\nimport { getNextLeafSibling } from './getLeafSibling';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst STYLETAGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL'.split(',');\r\n\r\nexport default function applyTextStyle(\r\n    container: Node,\r\n    styler: (node: HTMLElement) => any,\r\n    from: NodePosition = new Position(container, PositionType.Begin).normalize(),\r\n    to: NodePosition = new Position(container, PositionType.End).normalize()\r\n) {\r\n    let formatNodes: Node[] = [];\r\n\r\n    while (from && to && to.isAfter(from)) {\r\n        let formatNode = from.node;\r\n        let parentTag = getTagOfNode(formatNode.parentNode);\r\n\r\n        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node\r\n        let nextNode = getNextLeafSibling(container, formatNode);\r\n\r\n        if (formatNode.nodeType == NodeType.Text && ['TR', 'TABLE'].indexOf(parentTag) < 0) {\r\n            if (formatNode == to.node && !to.isAtEnd) {\r\n                formatNode = splitTextNode(formatNode, to.offset, true /*returnFirstPart*/);\r\n            }\r\n\r\n            if (from.offset > 0) {\r\n                formatNode = splitTextNode(formatNode, from.offset, false /*returnFirstPart*/);\r\n            }\r\n\r\n            formatNodes.push(formatNode);\r\n        }\r\n\r\n        from = nextNode && new Position(nextNode, PositionType.Begin);\r\n    }\r\n\r\n    if (formatNodes.length > 0) {\r\n        if (formatNodes.every(node => node.parentNode == formatNodes[0].parentNode)) {\r\n            let newNode = formatNodes.shift();\r\n            formatNodes.forEach(node => {\r\n                newNode.nodeValue += node.nodeValue;\r\n                node.parentNode.removeChild(node);\r\n            });\r\n            formatNodes = [newNode];\r\n        }\r\n\r\n        formatNodes.forEach(node => {\r\n            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them\r\n            // So that the inner style tag such as U, STRIKE can inherit the style we added\r\n            while (\r\n                getTagOfNode(node) != 'SPAN' &&\r\n                STYLETAGS.indexOf(getTagOfNode(node.parentNode)) >= 0\r\n            ) {\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n            styler(getTagOfNode(node) == 'SPAN' ? <HTMLElement>node : wrap(node, 'span'));\r\n        });\r\n    }\r\n}\r\n\r\nfunction splitTextNode(textNode: Node, offset: number, returnFirstPart: boolean) {\r\n    let firstPart = textNode.nodeValue.substr(0, offset);\r\n    let secondPart = textNode.nodeValue.substr(offset);\r\n    let newNode = textNode.ownerDocument.createTextNode(returnFirstPart ? firstPart : secondPart);\r\n    textNode.nodeValue = returnFirstPart ? secondPart : firstPart;\r\n    textNode.parentNode.insertBefore(newNode, returnFirstPart ? textNode : textNode.nextSibling);\r\n    return newNode;\r\n}\r\n","import contains from './contains';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\ninterface HTMLElementForIE extends HTMLElement {\r\n    msMatchesSelector: (selector: string) => boolean;\r\n}\r\n\r\n/**\r\n * Find closest element ancestor start from the given node which matches the given selector\r\n * @param node Find ancestor start from this node\r\n * @param root Root node where the search should stop at. The return value can never be this node\r\n * @param selector The expected selector. If null, return the first HTML Element found from start node\r\n * @returns An HTML element which matches the given selector. If the given start node matches the selector,\r\n * returns the given node\r\n */\r\nexport default function findClosestElementAncestor(\r\n    node: Node,\r\n    root?: Node,\r\n    selector?: string\r\n): HTMLElement {\r\n    node = !node ? null : node.nodeType == NodeType.Element ? node : node.parentNode;\r\n    let element = node && node.nodeType == NodeType.Element ? <HTMLElement>node : null;\r\n\r\n    if (element && selector) {\r\n        if (element.closest) {\r\n            element = element.closest(selector) as HTMLElement;\r\n        } else {\r\n            while (\r\n                element &&\r\n                element != root &&\r\n                !(element.matches || (<HTMLElementForIE>element).msMatchesSelector).call(\r\n                    element,\r\n                    selector\r\n                )\r\n            ) {\r\n                element = element.parentElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    return !root || contains(root, element) ? element : null;\r\n}\r\n","import { getComputedStyle } from './getComputedStyles';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst CRLF = /^[\\r\\n]+$/gm;\r\n\r\n/**\r\n * Skip a node when any of following conditions are true\r\n * - it is neither Element nor Text\r\n * - it is a text node but is empty\r\n * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)\r\n * - has a display:none\r\n */\r\nexport default function shouldSkipNode(node: Node): boolean {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return !node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue);\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return getComputedStyle(node, 'display') == 'none';\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n","import findClosestElementAncestor from './findClosestElementAncestor';\r\n\r\n/**\r\n * Get computed styles of a node\r\n * @param node The node to get computed styles from\r\n * @param styleNames Names of style to get, can be a single name or an array.\r\n * Default value is font-family, font-size, color, background-color\r\n * @returns An array of the computed styles\r\n */\r\nexport default function getComputedStyles(\r\n    node: Node,\r\n    styleNames: string | string[] = ['font-family', 'font-size', 'color', 'background-color']\r\n): string[] {\r\n    let element = findClosestElementAncestor(node);\r\n    let result: string[] = [];\r\n    styleNames = styleNames instanceof Array ? styleNames : [styleNames];\r\n    if (element) {\r\n        let win = element.ownerDocument.defaultView || window;\r\n        let styles = win.getComputedStyle(element);\r\n\r\n        if (styles) {\r\n            for (let style of styleNames) {\r\n                let value = (styles.getPropertyValue(style) || '').toLowerCase();\r\n                value = style == 'font-size' ? px2Pt(value) : value;\r\n                result.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * A shortcut for getComputedStyles() when only one style is to be retrieved\r\n * @param node The node to get style from\r\n * @param styleName The style name\r\n * @returns The style value\r\n */\r\nexport function getComputedStyle(node: Node, styleName: string): string {\r\n    return getComputedStyles(node, styleName)[0] || '';\r\n}\r\n\r\nfunction px2Pt(px: string) {\r\n    if (px && px.indexOf('px') == px.length - 2) {\r\n        // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value\r\n        // So add 0.05 to fix it\r\n        return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';\r\n    }\r\n    return px;\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport PartialInlineElement from './PartialInlineElement';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport { InlineElement, NodePosition, NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get inline element before a position\r\n * This is mostly used when we want to get the inline element before selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement before\r\n */\r\nexport function getInlineElementBefore(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);\r\n}\r\n\r\n/**\r\n * Get inline element after a position\r\n * This is mostly used when we want to get the inline element after selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement after\r\n */\r\nexport function getInlineElementAfter(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);\r\n}\r\n\r\nexport function getInlineElementBeforeAfter(root: Node, position: NodePosition, isAfter: boolean) {\r\n    if (!root || !position || !position.node) {\r\n        return null;\r\n    }\r\n\r\n    position = position.normalize();\r\n    let { node, offset, isAtEnd } = position;\r\n    let isPartial = false;\r\n\r\n    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    } else if (\r\n        node.nodeType == NodeType.Text &&\r\n        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))\r\n    ) {\r\n        isPartial = true;\r\n    }\r\n\r\n    if (node && shouldSkipNode(node)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    }\r\n\r\n    let inlineElement = getInlineElementAtNode(root, node);\r\n\r\n    if (inlineElement && (isPartial || inlineElement.contains(position))) {\r\n        inlineElement = isAfter\r\n            ? new PartialInlineElement(inlineElement, position, null)\r\n            : new PartialInlineElement(inlineElement, null, position);\r\n    }\r\n\r\n    return inlineElement;\r\n}\r\n","import { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Gets the cached event data by cache key from event object if there is already one.\r\n * Otherwise, call getter function to create one, and cache it.\r\n * @param event The event object\r\n * @param key Cache key string, need to be unique\r\n * @param getter Getter function to get the object when it is not in cache yet\r\n */\r\nexport default function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T {\r\n    let result =\r\n        event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)\r\n            ? <T>event.eventDataCache[key]\r\n            : getter();\r\n    if (event) {\r\n        event.eventDataCache = event.eventDataCache || {};\r\n        event.eventDataCache[key] = result;\r\n    }\r\n\r\n    return result;\r\n}\r\n","import { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    fromHtml,\r\n    isVoidHtmlElement,\r\n    isBlockElement,\r\n    Browser,\r\n    isNodeEmpty,\r\n    getTagOfNode,\r\n    getComputedStyles,\r\n    applyFormat,\r\n    getFirstLeafNode,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst TEMP_NODE_CLASS = 'ROOSTERJS_TEMP_NODE_FOR_LIST';\r\nconst TEMP_NODE_HTML = `<img class=\"${TEMP_NODE_CLASS}\">`;\r\n\r\n/**\r\n * Browsers don't handle bullet/numbering list well, especially the formats when switching list statue\r\n * So we workaround it by always adding format to list element\r\n */\r\nexport default function processList(editor: Editor, command: DocumentCommand): Node {\r\n    if (Browser.isChrome) {\r\n        workaroundForChrome(editor);\r\n    }\r\n\r\n    let currentNode = editor.getElementAtCursor();\r\n    let currentFormat = getComputedStyles(currentNode);\r\n    let existingList = editor.getElementAtCursor('OL,UL');\r\n    editor.getDocument().execCommand(command, false, null);\r\n    editor.queryElements('.' + TEMP_NODE_CLASS, node => editor.deleteNode(node));\r\n    let newList = editor.getElementAtCursor('OL,UL');\r\n    if (newList == existingList) {\r\n        newList = null;\r\n    }\r\n\r\n    // If this is in a new number list, need to adjust the format of numbers according to its content\r\n    if (newList && getTagOfNode(newList) == 'OL') {\r\n        let LIs = ([].slice.call(newList.childNodes) as Node[]).filter(\r\n            node => getTagOfNode(node) == 'LI'\r\n        );\r\n\r\n        if (LIs.length == 1 && isNodeEmpty(LIs[0], true /*trim*/)) {\r\n            // When there's only one LI child element which has empty content, it means this LI is just created.\r\n            // We just format it with current format\r\n            applyListFormat(LIs[0], currentFormat);\r\n        } else {\r\n            // Otherwise, apply the format of first child non-empty element (if any) to LI node\r\n            for (let li of LIs) {\r\n                let formatNode = getFirstLeafNode(li);\r\n                if (formatNode) {\r\n                    applyListFormat(li, getComputedStyles(formatNode));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return newList;\r\n}\r\n\r\nfunction applyListFormat(node: Node, formats: string[]) {\r\n    applyFormat(node as HTMLElement, {\r\n        fontFamily: formats[0],\r\n        fontSize: formats[1],\r\n        textColor: formats[2],\r\n        backgroundColor: formats[3],\r\n    });\r\n}\r\n\r\nfunction workaroundForChrome(editor: Editor) {\r\n    let traverser = editor.getSelectionTraverser();\r\n    let block = traverser && traverser.currentBlockElement;\r\n    while (block) {\r\n        let container = block.getStartNode();\r\n\r\n        if (container && !isNodeEmpty(container)) {\r\n            // Add a temp <IMG> tag before all other nodes in the block to avoid Chrome remove existing format when toggle list\r\n            let tempNode = fromHtml(TEMP_NODE_HTML, editor.getDocument())[0];\r\n            if (isVoidHtmlElement(container) || !isBlockElement(container)) {\r\n                container.parentNode.insertBefore(tempNode, container);\r\n            } else {\r\n                container.insertBefore(tempNode, container.firstChild);\r\n            }\r\n        }\r\n\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n}\r\n","export { default as HyperLink } from './HyperLink/HyperLink';\r\nexport { default as ContentEdit } from './ContentEdit/ContentEdit';\r\nexport { default as Paste } from './Paste/Paste';\r\nexport {\r\n    default as ContentEditFeatures,\r\n    getDefaultContentEditFeatures,\r\n} from './ContentEdit/ContentEditFeatures';\r\nexport { default as Watermark } from './Watermark/Watermark';\r\nexport { default as TableResize } from './TableResize/TableResize';\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport wrap from '../utils/wrap';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\r\n\r\nconst STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];\r\n\r\n/**\r\n * This reprents a block that is identified by a start and end node\r\n * This is for cases like <root>Hello<BR>World</root>\r\n * in that case, Hello<BR> is a block, World is another block\r\n * Such block cannot be represented by a NodeBlockElement since they don't chained up\r\n * to a single parent node, instead they have a start and end\r\n * This start and end must be in same sibling level and have same parent in DOM tree\r\n */\r\nexport default class StartEndBlockElement implements BlockElement {\r\n    constructor(private rootNode: Node, private startNode: Node, private endNode: Node) {}\r\n\r\n    static getBlockContext(node: Node): HTMLElement {\r\n        while (node && !isBlockElement(node)) {\r\n            node = node.parentNode;\r\n        }\r\n        return node as HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        let nodes = collapseNodes(\r\n            StartEndBlockElement.getBlockContext(this.startNode),\r\n            this.startNode,\r\n            this.endNode,\r\n            true /*canSplitParent*/\r\n        );\r\n        let blockContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        while (\r\n            nodes[0] &&\r\n            nodes[0] != blockContext &&\r\n            nodes[0].parentNode != this.rootNode &&\r\n            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0\r\n        ) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n        return nodes.length == 1 && isBlockElement(nodes[0])\r\n            ? (nodes[0] as HTMLElement)\r\n            : wrap(nodes);\r\n    }\r\n\r\n    /**\r\n     * Gets the start node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.startNode;\r\n    }\r\n\r\n    /**\r\n     * Gets the end node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.endNode;\r\n    }\r\n\r\n    /**\r\n     * Checks equals of two blocks\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        return (\r\n            this.startNode == blockElement.getStartNode() &&\r\n            this.endNode == blockElement.getEndNode()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if another block is after this current\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if an Html node is contained within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return (\r\n            contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||\r\n            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||\r\n            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node))\r\n        );\r\n    }\r\n}\r\n","/**\r\n * Creates an HTML node array from html\r\n * @param html the html string to create HTML elements from\r\n * @param ownerDocument Owner document of the result HTML elements\r\n * @returns An HTML node array to represent the given html string\r\n */\r\nexport default function fromHtml(html: string, ownerDocument: HTMLDocument): Node[] {\r\n    let element = ownerDocument.createElement('DIV');\r\n    element.innerHTML = html;\r\n\r\n    return [].slice.call(element.childNodes);\r\n}\r\n","import getBlockElementAtNode from './getBlockElementAtNode';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first/last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n * @param isFirst True to get first BlockElement, false to get last BlockElement\r\n */\r\nexport default function getFirstLastBlockElement(rootNode: Node, isFirst: boolean): BlockElement {\r\n    let node = rootNode;\r\n    do {\r\n        node = node && (isFirst ? node.firstChild : node.lastChild);\r\n    } while (node && node.firstChild);\r\n    return node && getBlockElementAtNode(rootNode, node);\r\n}\r\n\r\n/**\r\n * Get the first BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n */\r\nexport function getFirstBlockElement(rootNode: Node): BlockElement {\r\n    return getFirstLastBlockElement(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n */\r\nexport function getLastBlockElement(rootNode: Node): BlockElement {\r\n    return getFirstLastBlockElement(rootNode, false /*isFirst*/);\r\n}\r\n","import BodyScoper from './BodyScoper';\r\nimport EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport SelectionBlockScoper from './SelectionBlockScoper';\r\nimport SelectionScoper from './SelectionScoper';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementBeforeAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * The provides traversing of content inside editor.\r\n * There are two ways to traverse, block by block, or inline element by inline element\r\n * Block and inline traversing is independent from each other, meanning if you traverse block by block, it does not change\r\n * the current inline element position\r\n */\r\nexport default class ContentTraverser {\r\n    private currentInline: InlineElement;\r\n    private currentBlock: BlockElement;\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param scoper Traversing scoper object to help scope the traversing\r\n     */\r\n    private constructor(private scoper: TraversingScoper) {}\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param rootNode The root node to traverse in\r\n     */\r\n    public static createBodyTraverser(rootNode: Node): ContentTraverser {\r\n        return new ContentTraverser(new BodyScoper(rootNode));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for the given selection\r\n     * @param rootNode The root node to traverse in\r\n     * @param range The selection range to scope the traversing\r\n     */\r\n    public static createSelectionTraverser(rootNode: Node, range: Range): ContentTraverser {\r\n        return new ContentTraverser(new SelectionScoper(rootNode, range));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for a block element which contains the given position\r\n     * @param rootNode The root node to traverse in\r\n     * @param position A position inside a block, traversing will be scoped within this block.\r\n     * If passing a range, the start position of this range will be used\r\n     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart\r\n     */\r\n    public static createBlockTraverser(\r\n        rootNode: Node,\r\n        position: NodePosition | Range,\r\n        start: ContentPosition = ContentPosition.SelectionStart\r\n    ): ContentTraverser {\r\n        return new ContentTraverser(new SelectionBlockScoper(rootNode, position, start));\r\n    }\r\n\r\n    /**\r\n     * Get current block\r\n     */\r\n    public get currentBlockElement(): BlockElement {\r\n        // Prepare currentBlock from the scoper\r\n        if (!this.currentBlock) {\r\n            this.currentBlock = this.scoper.getStartBlockElement();\r\n        }\r\n\r\n        return this.currentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get next block element\r\n     */\r\n    public getNextBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous block element\r\n     */\r\n    public getPreviousBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextBlockElement(isNext: boolean): BlockElement {\r\n        let current = this.currentBlockElement;\r\n        let leaf = getLeafSibling(\r\n            this.scoper.rootNode,\r\n            isNext ? current.getEndNode() : current.getStartNode(),\r\n            isNext\r\n        );\r\n        let newBlock = leaf ? getBlockElementAtNode(this.scoper.rootNode, leaf) : null;\r\n\r\n        // Make sure this is right block:\r\n        // 1) the block is in scope per scoper\r\n        // 2) the block is after (for next) or before (for previous) the current block\r\n        // Then:\r\n        // 1) Re-position current block to newly found block\r\n        if (\r\n            newBlock &&\r\n            this.scoper.isBlockInScope(newBlock) &&\r\n            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))\r\n        ) {\r\n            this.currentBlock = newBlock;\r\n            return this.currentBlock;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current inline element getter\r\n     */\r\n    public get currentInlineElement(): InlineElement {\r\n        // Retrieve a start inline from scoper\r\n        if (!this.currentInline) {\r\n            this.currentInline = this.scoper.getStartInlineElement();\r\n        }\r\n\r\n        return this.currentInline instanceof EmptyInlineElement ? null : this.currentInline;\r\n    }\r\n\r\n    /**\r\n     * Get next inline element\r\n     */\r\n    public getNextInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous inline element\r\n     */\r\n    public getPreviousInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextInlineElement(isNext: boolean): InlineElement {\r\n        let current = this.currentInlineElement || this.currentInline;\r\n        let newInline: InlineElement;\r\n\r\n        if (current instanceof EmptyInlineElement) {\r\n            newInline = getInlineElementBeforeAfter(\r\n                this.scoper.rootNode,\r\n                current.getStartPosition(),\r\n                isNext\r\n            );\r\n            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {\r\n                newInline = null;\r\n            }\r\n        } else {\r\n            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);\r\n            newInline =\r\n                newInline &&\r\n                current &&\r\n                ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))\r\n                    ? newInline\r\n                    : null;\r\n        }\r\n\r\n        // For inline, we need to make sure:\r\n        // 1) it is really next/previous to current\r\n        // 2) pass on the new inline to this.scoper to do the triming and we still get back an inline\r\n        // Then\r\n        // 1) re-position current inline\r\n        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {\r\n            this.currentInline = newInline;\r\n            return this.currentInline;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getNextPreviousInlineElement(\r\n    rootNode: Node,\r\n    current: InlineElement,\r\n    isNext: boolean\r\n): InlineElement {\r\n    if (!current) {\r\n        return null;\r\n    }\r\n    if (current instanceof PartialInlineElement) {\r\n        // if current is partial, get the the othe half of the inline unless it is no more\r\n        let result = isNext ? current.nextInlineElement : current.previousInlineElement;\r\n\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get a leaf node after startNode and use that base to find next inline\r\n    let startNode = current.getContainerNode();\r\n    startNode = getLeafSibling(rootNode, startNode, isNext);\r\n    return getInlineElementAtNode(rootNode, startNode);\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport { getFirstLeafNode, getLastLeafNode } from '../utils/getLeafNode';\r\nimport { InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first inline element inside the given node\r\n */\r\nexport function getFirstInlineElement(rootNode: Node): InlineElement {\r\n    // getFirstLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getFirstLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n\r\n/**\r\n * Get the last inline element inside the given node\r\n */\r\nexport function getLastInlineElement(rootNode: Node): InlineElement {\r\n    // getLastLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getLastLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is an inline element representing an Html image\r\n */\r\nexport default class ImageInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is inline element presenting an html hyperlink\r\n */\r\nexport default class LinkInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import shouldSkipNode from './shouldSkipNode';\r\nimport { getLeafSibling } from './getLeafSibling';\r\n\r\n/**\r\n * Get first/last leaf node of the given root node.\r\n * @param rootNode Root node to get leaf node from\r\n * @param isFirst True to get first leaf node, false to get last leaf node\r\n */\r\nfunction getLeafNode(rootNode: Node, isFirst: boolean): Node {\r\n    let getChild = (node: Node): Node => (isFirst ? node.firstChild : node.lastChild);\r\n    let result = getChild(rootNode);\r\n    while (result && getChild(result)) {\r\n        result = getChild(result);\r\n    }\r\n\r\n    if (result && shouldSkipNode(result)) {\r\n        result = getLeafSibling(rootNode, result, isFirst);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Get the first meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getFirstLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getLastLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, false /*isFirst*/);\r\n}\r\n","import { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represents an empty InlineElement.\r\n * This is used for ContentTraverser internally only.\r\n * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element\r\n */\r\nexport default class EmptyInlineElement implements InlineElement {\r\n    constructor(private position: NodePosition, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string {\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node {\r\n        return this.position.node;\r\n    }\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element.\r\n     */\r\n    applyStyle(styler: (element: HTMLElement) => any): void {}\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * HTML void elements\r\n * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes\r\n * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside\r\n * void elements so users don't accidently create child nodes in them\r\n */\r\nconst HTML_VOID_ELEMENTS = 'AREA,BASE,BR,COL,COMMAND,EMBED,HR,IMG,INPUT,KEYGEN,LINK,META,PARAM,SOURCE,TRACK,WBR'.split(\r\n    ','\r\n);\r\n\r\n/**\r\n * Check if the given node is html void element. Void element cannot have childen\r\n * @param node The node to check\r\n */\r\nexport default function isVoidHtmlElement(node: Node): boolean {\r\n    return !!node && HTML_VOID_ELEMENTS.indexOf(getTagOfNode(node)) >= 0;\r\n}\r\n","import { BrowserInfo } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get current browser information from user agent string\r\n * @param userAgent The userAgent string of a browser\r\n * @param appVersion The appVersion string of a browser\r\n * @returns The BrowserInfo object calculated from the given userAgent and appVersion\r\n */\r\nexport function getBrowserInfo(userAgent: string, appVersion: string): BrowserInfo {\r\n    // checks whether the browser is running in IE\r\n    // IE11 will use rv in UA instead of MSIE. Unfortunately Firefox also uses this. We should also look for \"Trident\" to confirm this.\r\n    // There have been cases where companies using older version of IE and custom UserAgents have broken this logic (e.g. IE 10 and KellyServices)\r\n    // therefore we should check that the Trident/rv combo is not just from an older IE browser\r\n    let isIE11OrGreater = userAgent.indexOf('rv:') != -1 && userAgent.indexOf('Trident') != -1;\r\n    let isIE = userAgent.indexOf('MSIE') != -1 || isIE11OrGreater;\r\n\r\n    // IE11+ may also have 'Chrome', 'Firefox' and 'Safari' in user agent. But it will have 'trident' as well\r\n    let isChrome = false;\r\n    let isFirefox = false;\r\n    let isSafari = false;\r\n    let isEdge = false;\r\n    let isWebKit = userAgent.indexOf('WebKit') != -1;\r\n\r\n    if (!isIE) {\r\n        isChrome = userAgent.indexOf('Chrome') != -1;\r\n        isFirefox = userAgent.indexOf('Firefox') != -1;\r\n        if (userAgent.indexOf('Safari') != -1) {\r\n            // Android and Chrome have Safari in the user string\r\n            isSafari = userAgent.indexOf('Chrome') == -1 && userAgent.indexOf('Android') == -1;\r\n        }\r\n\r\n        // Sample Edge UA: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10121\r\n        isEdge = userAgent.indexOf('Edge') != -1;\r\n\r\n        // When it is edge, it should not be chrome or firefox. and it is also not webkit\r\n        if (isEdge) {\r\n            isWebKit = isChrome = isFirefox = false;\r\n        }\r\n    }\r\n\r\n    let isMac = appVersion.indexOf('Mac') != -1;\r\n    let isWin = appVersion.indexOf('Win') != -1 || appVersion.indexOf('NT') != -1;\r\n\r\n    return {\r\n        isMac,\r\n        isWin,\r\n        isWebKit,\r\n        isIE,\r\n        isIE11OrGreater,\r\n        isSafari,\r\n        isChrome,\r\n        isFirefox,\r\n        isEdge,\r\n        isIEOrEdge: isIE || isEdge,\r\n    };\r\n}\r\n\r\nconst Browser = window\r\n    ? getBrowserInfo(window.navigator.userAgent, window.navigator.appVersion)\r\n    : {};\r\n\r\nexport default Browser;\r\n","import getTagOfNode from './getTagOfNode';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst VISIBLE_ELEMENT_TAGS = ['IMG'];\r\nconst VISIBLE_CHILD_ELEMENT_SELECTOR = ['TABLE', 'IMG', 'LI'].join(',');\r\nconst ZERO_WIDTH_SPACE = /\\u200b/g;\r\n\r\n/**\r\n * Check if a given node has no visible content\r\n * @param node The node to check\r\n * @param trimContent Whether trim the text content so that spaces will be treated as empty.\r\n * Default value is false\r\n * @returns True if there isn't any visible element inside node, otherwise false\r\n */\r\nexport default function isNodeEmpty(node: Node, trimContent?: boolean) {\r\n    if (!node) {\r\n        return false;\r\n    } else if (node.nodeType == NodeType.Text) {\r\n        return trim(node.nodeValue, trimContent) == '';\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        let element = node as Element;\r\n        let textContent = trim(element.textContent, trimContent);\r\n        if (\r\n            textContent != '' ||\r\n            VISIBLE_ELEMENT_TAGS.indexOf(getTagOfNode(element)) >= 0 ||\r\n            element.querySelectorAll(VISIBLE_CHILD_ELEMENT_SELECTOR)[0]\r\n        ) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction trim(s: string, trim: boolean) {\r\n    s = s.replace(ZERO_WIDTH_SPACE, '');\r\n    return trim ? s.trim() : s;\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Feature set for ContentEdit plugin.\r\n * Call getDefaultContentEditFeatures() to get default feature set.\r\n */\r\ninterface ContentEditFeatures {\r\n    /**\r\n     * When press Tab in a list, indent current list item\r\n     * @default true\r\n     */\r\n    indentWhenTab: boolean;\r\n\r\n    /**\r\n     * When press Shift+Tab in a list, outdent current list item\r\n     * @default true\r\n     */\r\n    outdentWhenShiftTab: boolean;\r\n\r\n    /**\r\n     * When press BaskSpace on empty line which is the first item of a list, outdent current list item\r\n     * @default true\r\n     */\r\n    outdentWhenBackspaceOnEmptyFirstLine: boolean;\r\n\r\n    /**\r\n     * When press Enter on empty line in a list, outdent current list item\r\n     * @default true for IE, false for other browsers since they have already had the behavior\r\n     */\r\n    outdentWhenEnterOnEmptyLine: boolean;\r\n\r\n    /**\r\n     * When press Backspace on first char in a list, make current item a new line of previous list item\r\n     * @default false\r\n     */\r\n    mergeInNewLineWhenBackspaceOnFirstChar: boolean;\r\n\r\n    /**\r\n     * When press BAckspace on empty line which is the first line of a blockquote, unquote current line\r\n     * @default true\r\n     */\r\n    unquoteWhenBackspaceOnEmptyFirstLine: boolean;\r\n\r\n    /**\r\n     * When press Enter on empty line in a blockquote, unquote current line\r\n     * @default true\r\n     */\r\n    unquoteWhenEnterOnEmptyLine: boolean;\r\n\r\n    /**\r\n     * When press space after an asterik or number in an empty line, toggle bullet/numbering\r\n     * @default true\r\n     */\r\n    autoBullet: boolean;\r\n\r\n    /**\r\n     * When press TAB or SHIFT+TAB key in table cell, jump to next/previous table cell\r\n     * @default true\r\n     */\r\n    tabInTable: boolean;\r\n\r\n    /**\r\n     * When press Up or Down in table cell, jump to the table cell above/below\r\n     * @default true\r\n     */\r\n    upDownInTable: boolean;\r\n\r\n    /**\r\n     * When press Space or Enter after a hyperlink-like string, convert the string to a hyperlink\r\n     * @default true\r\n     */\r\n    autoLink: boolean;\r\n\r\n    /**\r\n     * Respond to default common keyboard short, i.e. Ctrl+B, Ctrl+I, Ctrl+U, Ctrl+Z, Ctrl+Y\r\n     * @default true\r\n     */\r\n    defaultShortcut: boolean;\r\n\r\n    /**\r\n     * Unlink when backspace right after a hyperlink\r\n     * @default false\r\n     */\r\n    unlinkWhenBackspaceAfterLink: boolean;\r\n\r\n    /**\r\n     * When generate ordered list, the list bullet will variare according its nesting level, in a loop of '1', 'a', 'i'\r\n     * @default false\r\n     */\r\n    smartOrderedList: boolean;\r\n\r\n    /**\r\n     * A style list for smart ordered list. This value is only effective when smartOrderedList is true\r\n     * @default ['lower-alpha', 'lower-roman', 'decimal']\r\n     */\r\n    smartOrderedListStyles: string[];\r\n}\r\n\r\nexport default ContentEditFeatures;\r\n\r\n/**\r\n * Get default feature set of ContentEdit plugin\r\n */\r\nexport function getDefaultContentEditFeatures(): ContentEditFeatures {\r\n    return {\r\n        autoLink: true,\r\n        indentWhenTab: true,\r\n        outdentWhenShiftTab: true,\r\n        outdentWhenBackspaceOnEmptyFirstLine: true,\r\n        outdentWhenEnterOnEmptyLine: Browser.isIE,\r\n        mergeInNewLineWhenBackspaceOnFirstChar: false,\r\n        unquoteWhenBackspaceOnEmptyFirstLine: true,\r\n        unquoteWhenEnterOnEmptyLine: true,\r\n        autoBullet: true,\r\n        tabInTable: true,\r\n        upDownInTable: true,\r\n        defaultShortcut: true,\r\n        unlinkWhenBackspaceAfterLink: false,\r\n        smartOrderedList: false,\r\n        smartOrderedListStyles: ['lower-alpha', 'lower-roman', 'decimal'],\r\n    };\r\n}\r\n","import { BlockElement, NodeType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getTagOfNode, StartEndBlockElement } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Collapse all selected blocks, return single HTML elements for each block\r\n * @param editor The editor instance\r\n * @param forEachCallback A callback function to invoke for each of the collapsed element\r\n */\r\nexport default function collapseSelectedBlocked(\r\n    editor: Editor,\r\n    forEachCallback: (element: HTMLElement) => any\r\n) {\r\n    let traverser = editor.getSelectionTraverser();\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let blocks: BlockElement[] = [];\r\n    while (block) {\r\n        if (!isEmptyBlockUnderTR(block)) {\r\n            blocks.push(block);\r\n        }\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    blocks.forEach(block => {\r\n        let element = block.collapseToSingleElement();\r\n        forEachCallback(element);\r\n    });\r\n}\r\n\r\nfunction isEmptyBlockUnderTR(block: BlockElement): boolean {\r\n    let startNode = block.getStartNode();\r\n\r\n    return (\r\n        block instanceof StartEndBlockElement &&\r\n        startNode == block.getEndNode() &&\r\n        startNode.nodeType == NodeType.Text &&\r\n        ['TR', 'TABLE'].indexOf(getTagOfNode(startNode.parentNode)) >= 0\r\n    );\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set background color at current selection\r\n * @param editor The editor instance\r\n * @param color The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setBackgroundColor(editor: Editor, color: string) {\r\n    color = color.trim();\r\n    applyInlineStyle(editor, element => (element.style.backgroundColor = color));\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set font name at selection\r\n * @param editor The editor instance\r\n * @param fontName The fontName string, should be a valid CSS font-family style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontName(editor: Editor, fontName: string) {\r\n    fontName = fontName.trim();\r\n    // The browser provided execCommand creates a HTML <font> tag with face attribute. <font> is not HTML5 standard\r\n    // (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-family style\r\n    applyInlineStyle(editor, element => (element.style.fontFamily = fontName));\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Set font size at selection\r\n * @param editor The editor instance\r\n * @param fontSize The fontSize string, should be a valid CSS font-size style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontSize(editor: Editor, fontSize: string) {\r\n    fontSize = fontSize.trim();\r\n    // The browser provided execCommand only accepts 1-7 point value. In addition, it uses HTML <font> tag with size attribute.\r\n    // <font> is not HTML5 standard (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-size style\r\n    applyInlineStyle(editor, element => {\r\n        element.style.fontSize = fontSize;\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set text color at selection\r\n * @param editor The editor instance\r\n * @param color The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setTextColor(editor: Editor, color: string) {\r\n    color = color.trim();\r\n    applyInlineStyle(editor, element => (element.style.color = color));\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle bold at selection\r\n * If selection is collapsed, it will only affect the following input after caret\r\n * If selection contains only bold text, the bold style will be removed\r\n * If selection contains only normal text, bold style will be added to the whole selected text\r\n * If selection contains both bold and normal text, bold stle will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBold(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Bold);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle italic at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only italic text, the italic style will be removed\r\n * If selection contains only normal text, italic style will be added to the whole selected text\r\n * If selection contains both italic and normal text, italic stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleItalic(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Italic);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle underline at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only underlined text, the underline style will be removed\r\n * If selection contains only normal text, underline style will be added to the whole selected text\r\n * If selection contains both underlined and normal text, the underline style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleUnderline(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Underline);\r\n}\r\n","import Editor from '../editor/Editor';\nimport EditorPlugin from '../interfaces/EditorPlugin';\nimport { Browser } from 'roosterjs-editor-dom';\nimport { ChangeSource, PluginCompositionEvent, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * DOMEventPlugin handles customized DOM events, including:\n * 1. IME state management\n * 2. Selection management\n * 3. Cut and Drop management\n */\nexport default class DOMEventPlugin implements EditorPlugin {\n    private editor: Editor;\n    private inIme = false;\n    private disposer: () => void;\n\n    constructor(private disableRestoreSelectionOnFocus: boolean) {}\n\n    getName() {\n        return 'DOMEvent';\n    }\n\n    initialize(editor: Editor) {\n        this.editor = editor;\n\n        this.disposer = editor.addDomEventHandler({\n            // 1. IME state management\n            compositionstart: () => (this.inIme = true),\n            compositionend: (e: CompositionEvent) => {\n                this.inIme = false;\n                editor.triggerEvent(<PluginCompositionEvent>{\n                    eventType: PluginEventType.CompositionEnd,\n                    rawEvent: e,\n                });\n            },\n\n            // 2. Selection mangement\n            [Browser.isIEOrEdge ? 'beforedeactivate' : 'blur']: () => editor.saveSelectionRange(),\n            focus: !this.disableRestoreSelectionOnFocus && (() => editor.restoreSavedRange()),\n\n            // 3. Cut and drop management\n            drop: this.onNativeEvent,\n            cut: this.onNativeEvent,\n        });\n    }\n\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Check if editor is in IME input sequence\n     * @returns True if editor is in IME input sequence, otherwise false\n     */\n    public isInIME() {\n        return this.inIme;\n    }\n\n    private onNativeEvent = (e: UIEvent) => {\n        this.editor.runAsync(() => {\n            this.editor.addUndoSnapshot(\n                () => {},\n                e.type == 'cut' ? ChangeSource.Cut : ChangeSource.Drop\n            );\n        });\n    };\n}\n","import Editor from '../editor/Editor';\nimport { GenericContentEditFeature, Keys } from '../interfaces/ContentEditFeature';\nimport {\n    ChangeSource,\n    PluginEvent,\n    PluginEventType,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * Edit Component helps handle Content edit features\n */\nexport default class EditPlugin implements EditPlugin {\n    private editor: Editor;\n    private currentFeature: GenericContentEditFeature<PluginEvent> = null;\n    private featureMap: { [key: number]: GenericContentEditFeature<PluginEvent>[] } = {};\n\n    private autoCompleteSnapshot: string = null;\n    private autoCompleteChangeSource: string = null;\n\n    getName() {\n        return 'Edit';\n    }\n\n    initialize(editor: Editor) {\n        this.editor = editor;\n        this.addFeature({\n            keys: [Keys.BACKSPACE],\n            shouldHandleEvent: () => this.autoCompleteSnapshot !== null,\n            handleEvent: (event: PluginKeyboardEvent, editor: Editor) => {\n                event.rawEvent.preventDefault();\n                editor.setContent(this.autoCompleteSnapshot, false /*triggerContentChangedEvent*/);\n            },\n        });\n    }\n\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        let contentChanged = false;\n\n        switch (event.eventType) {\n            case PluginEventType.ContentChanged:\n                if (this.autoCompleteChangeSource != event.source) {\n                    contentChanged = true;\n                }\n                if (!this.currentFeature) {\n                    this.findFeature(event);\n                }\n                break;\n            case PluginEventType.MouseDown:\n                contentChanged = true;\n                break;\n            case PluginEventType.KeyDown:\n                contentChanged = true;\n                break;\n        }\n\n        if (this.currentFeature) {\n            let feature = this.currentFeature;\n            this.currentFeature = null;\n            feature.handleEvent(event, this.editor);\n        }\n\n        if (contentChanged) {\n            this.autoCompleteSnapshot = null;\n            this.autoCompleteChangeSource = null;\n        }\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * Handle an event exclusively means other plugin will not receive this event in\n     * onPluginEvent method.\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\n     * the final result depends on the order of the plugins are added into editor\n     * @param event The event to check\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        this.findFeature(event);\n        return !!this.currentFeature;\n    }\n\n    /**\n     * Add a Content Edit feature\n     * @param feature The feature to add\n     */\n    addFeature(feature: GenericContentEditFeature<PluginEvent>) {\n        if (feature.initialize) {\n            feature.initialize(this.editor);\n        }\n\n        feature.keys.forEach(key => {\n            let array = this.featureMap[key] || [];\n            array.push(feature);\n            this.featureMap[key] = array;\n        });\n    }\n\n    /**\n     * Perform an auto complete action in the callback, save a snapsnot of content before the action,\n     * and trigger ContentChangedEvent with the change source if specified\n     * @param callback The auto complete callback, return value will be used as data field of ContentChangedEvent\n     * @param changeSource Chagne source of ContentChangedEvent. If not passed, no ContentChangedEvent will be  triggered\n     */\n    performAutoComplete(callback: () => any, changeSource?: ChangeSource | string) {\n        this.editor.addUndoSnapshot((start, end, snapshot) => {\n            let data = callback();\n            this.autoCompleteSnapshot = snapshot;\n            this.autoCompleteChangeSource = changeSource;\n            return data;\n        }, changeSource);\n    }\n\n    private findFeature(event: PluginEvent) {\n        let hasFunctionKey = false;\n        let features: GenericContentEditFeature<PluginEvent>[];\n\n        if (event.eventType == PluginEventType.KeyDown) {\n            let rawEvent = event.rawEvent;\n            hasFunctionKey = rawEvent.ctrlKey || rawEvent.altKey || rawEvent.metaKey;\n            features = this.featureMap[rawEvent.which];\n        } else if (event.eventType == PluginEventType.ContentChanged) {\n            features = this.featureMap[Keys.CONTENTCHANGED];\n        }\n        this.currentFeature =\n            features &&\n            features.filter(\n                feature =>\n                    (feature.allowFunctionKeys || !hasFunctionKey) &&\n                    feature.shouldHandleEvent(event, this.editor)\n            )[0];\n    }\n}\n","import EditorCore, { HasFocus } from '../interfaces/EditorCore';\r\nimport { contains } from 'roosterjs-editor-dom';\r\n\r\nconst hasFocus: HasFocus = (core: EditorCore) => {\r\n    let activeElement = core.document.activeElement;\r\n    return (\r\n        activeElement && contains(core.contentDiv, activeElement, true /*treatSameNodeAsContain*/)\r\n    );\r\n};\r\n\r\nexport default hasFocus;\r\n","import Editor from '../editor/Editor';\nimport { EditorPlugin } from '..';\nimport { PluginEvent, PluginEventType, PluginMouseUpEvent } from 'roosterjs-editor-types';\n\n/**\n * MouseUp Component helps handle mouse up event\n * this can trigger mouse up event after mousedown happens in editor\n * even mouse up is happening outside editor\n */\nexport default class MouseUpPlugin implements EditorPlugin {\n    private mouseUpEventListerAdded: boolean;\n    private editor: Editor;\n\n    getName() {\n        return 'MouseUp';\n    }\n\n    initialize(editor: Editor) {\n        this.editor = editor;\n    }\n\n    dispose() {\n        this.removeMouseUpEventListener();\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.MouseDown && !this.mouseUpEventListerAdded) {\n            this.editor\n                .getDocument()\n                .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);\n            this.mouseUpEventListerAdded = true;\n        }\n    }\n\n    private removeMouseUpEventListener() {\n        if (this.mouseUpEventListerAdded) {\n            this.mouseUpEventListerAdded = false;\n            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);\n        }\n    }\n\n    private onMouseUp = (e: MouseEvent) => {\n        if (this.editor) {\n            this.removeMouseUpEventListener();\n            this.editor.triggerEvent(<PluginMouseUpEvent>{\n                eventType: PluginEventType.MouseUp,\n                rawEvent: e,\n            });\n        }\n    };\n}\n","import Editor from '../editor/Editor';\nimport EditorPlugin from '../interfaces/EditorPlugin';\nimport {\n    applyFormat,\n    Browser,\n    findClosestElementAncestor,\n    fromHtml,\n    isNodeEmpty,\n    Position,\n} from 'roosterjs-editor-dom';\nimport {\n    ContentPosition,\n    NodePosition,\n    PluginKeyboardEvent,\n    PositionType,\n    PluginEvent,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\n/**\n * Typing Component helps to ensure typing is always happening under a DOM container\n */\nexport default class TypeInContainerPlugin implements EditorPlugin {\n    private editor: Editor;\n\n    getName() {\n        return 'TypeInContainer';\n    }\n\n    initialize(editor: Editor) {\n        this.editor = editor;\n    }\n\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.KeyPress) {\n            this.onKeyPress(event);\n        }\n    }\n\n    /**\n     * Ensure we are typing in an HTML Element inside editor, and apply default format if current block is empty\n     * @param node Current node\n     * @param event (optional) The keyboard event that we are ensuring is typing in an element.\n     * @returns A new position to select\n     */\n    ensureTypeInElement(position: NodePosition, event?: PluginKeyboardEvent): NodePosition {\n        let result = position.normalize();\n        let block = this.editor.getBlockElementAtNode(result.node);\n        let formatNode: HTMLElement;\n\n        if (block) {\n            formatNode = block.collapseToSingleElement();\n\n            // if the block is empty, apply default format\n            // Otherwise, leave it as it is as we don't want to change the style for existing data\n            // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)\n            const shouldSetNodeStyles =\n                isNodeEmpty(formatNode) ||\n                (event && this.wasNodeJustCreatedByKeyboardEvent(event, formatNode));\n            formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;\n        } else {\n            // Only reason we don't get the selection block is that we have an empty content div\n            // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)\n            // The fix is to add a DIV wrapping, apply default format and move cursor over\n            formatNode = fromHtml(\n                Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>',\n                this.editor.getDocument()\n            )[0] as HTMLElement;\n            this.editor.insertNode(formatNode, {\n                position: ContentPosition.End,\n                updateCursor: false,\n                replaceSelection: false,\n                insertOnNewLine: false,\n            });\n\n            // element points to a wrapping node we added \"<div><br></div>\". We should move the selection left to <br>\n            result = new Position(formatNode.firstChild, PositionType.Begin);\n        }\n\n        if (formatNode) {\n            applyFormat(formatNode, this.editor.getDefaultFormat());\n        }\n\n        return result;\n    }\n\n    private onKeyPress(event: PluginKeyboardEvent) {\n        // If normalization was not possible before the keypress,\n        // check again after the keyboard event has been processed by browser native behaviour.\n        //\n        // This handles the case where the keyboard event that first inserts content happens when\n        // there is already content under the selection (e.g. Ctrl+a -> type new content).\n        //\n        // Only scheudle when the range is not collapsed to catch this edge case.\n        let range = this.editor.getSelectionRange();\n        let shouldNormalizeTypingNow =\n            range &&\n            range.collapsed &&\n            !this.editor.contains(findClosestElementAncestor(range.startContainer));\n        if (shouldNormalizeTypingNow) {\n            this.tryNormalizeTyping(event, range);\n        } else if (!range.collapsed) {\n            this.editor.runAsync(() => {\n                this.tryNormalizeTyping(event);\n            });\n        }\n    }\n\n    /**\n     * When typing goes directly under content div, many things can go wrong\n     * We fix it by wrapping it with a div and reposition cursor within the div\n     */\n    private tryNormalizeTyping(event: PluginKeyboardEvent, range?: Range) {\n        let position = this.ensureTypeInElement(\n            Position.getStart(range || this.editor.getSelectionRange()),\n            event\n        );\n        this.editor.select(position);\n    }\n\n    private wasNodeJustCreatedByKeyboardEvent(event: PluginKeyboardEvent, formatNode: HTMLElement) {\n        return (\n            event.rawEvent.target instanceof Node &&\n            event.rawEvent.target.contains(formatNode) &&\n            event.rawEvent.key === formatNode.innerText\n        );\n    }\n}\n","import Editor from '../editor/Editor';\r\nimport UndoService from '../interfaces/UndoService';\r\nimport UndoSnapshots from './UndoSnapshots';\r\nimport UndoSnapshotsService from '../interfaces/UndoSnapshotsService';\r\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\nconst KEY_BACKSPACE = 8;\r\nconst KEY_DELETE = 46;\r\nconst KEY_SPACE = 32;\r\nconst KEY_ENTER = 13;\r\nconst KEY_PAGEUP = 33;\r\nconst KEY_DOWN = 40;\r\n\r\n/**\r\n * Provides snapshot based undo service for Editor\r\n */\r\nexport default class Undo implements UndoService {\r\n    private editor: Editor;\r\n    private isRestoring: boolean;\r\n    private hasNewContent: boolean;\r\n    private lastKeyPress: number;\r\n\r\n    protected undoSnapshots: UndoSnapshotsService;\r\n\r\n    /**\r\n     * Create an instance of Undo\r\n     * @param preserveSnapshots True to preserve the snapshots after dispose, this allows\r\n     * this object to be reused when editor is disposed and created again\r\n     * @param maxBufferSize The max buffer size for snapshots. Default value is 10MB\r\n     */\r\n    constructor(private preserveSnapshots?: boolean, private maxBufferSize: number = 1e7) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Undo';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: Editor): void {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.editor = null;\r\n\r\n        if (!this.preserveSnapshots) {\r\n            this.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    public onPluginEvent(event: PluginEvent): void {\r\n        // if editor is in IME, don't do anything\r\n        if (this.editor.isInIME()) {\r\n            return;\r\n        }\r\n\r\n        switch (event.eventType) {\r\n            case PluginEventType.EditorReady:\r\n                this.addUndoSnapshot();\r\n                break;\r\n            case PluginEventType.KeyDown:\r\n                this.onKeyDown(event.rawEvent);\r\n                break;\r\n            case PluginEventType.KeyPress:\r\n                this.onKeyPress(event.rawEvent);\r\n                break;\r\n            case PluginEventType.CompositionEnd:\r\n                this.clearRedoForInput();\r\n                this.addUndoSnapshot();\r\n                break;\r\n            case PluginEventType.ContentChanged:\r\n                if (!this.isRestoring) {\r\n                    this.clearRedoForInput();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all existing undo snapshots\r\n     */\r\n    public clear() {\r\n        this.undoSnapshots = null;\r\n        this.hasNewContent = false;\r\n    }\r\n\r\n    /**\r\n     * Restore an undo snapshot to editor\r\n     */\r\n    public undo(): void {\r\n        if (this.hasNewContent) {\r\n            this.addUndoSnapshot();\r\n        }\r\n\r\n        this.restoreSnapshot(-1 /*previousSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Restore a redo snapshot to editor\r\n     */\r\n    public redo(): void {\r\n        this.restoreSnapshot(1 /*nextSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Whether there is a snapshot for undo\r\n     */\r\n    public canUndo(): boolean {\r\n        return this.hasNewContent || this.getSnapshotsManager().canMove(-1 /*previousSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Whether there is a snapshot for redo\r\n     */\r\n    public canRedo(): boolean {\r\n        return this.getSnapshotsManager().canMove(1 /*nextSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Add an undo snapshot\r\n     */\r\n    public addUndoSnapshot(): string {\r\n        let snapshot = this.editor.getContent(\r\n            false /*triggerExtractContentEvent*/,\r\n            true /*markSelection*/\r\n        );\r\n        this.getSnapshotsManager().addSnapshot(snapshot);\r\n        this.hasNewContent = false;\r\n        return snapshot;\r\n    }\r\n\r\n    protected getSnapshotsManager(): UndoSnapshotsService {\r\n        if (!this.undoSnapshots) {\r\n            this.undoSnapshots = new UndoSnapshots(this.maxBufferSize);\r\n        }\r\n        return this.undoSnapshots;\r\n    }\r\n\r\n    private restoreSnapshot(delta: number) {\r\n        let snapshot = this.getSnapshotsManager().move(delta);\r\n\r\n        if (snapshot != null) {\r\n            try {\r\n                this.isRestoring = true;\r\n                this.editor.setContent(snapshot);\r\n            } finally {\r\n                this.isRestoring = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private onKeyDown(evt: KeyboardEvent): void {\r\n        // Handle backspace/delete when there is a selection to take a snapshot\r\n        // since we want the state prior to deletion restorable\r\n        if (evt.which == KEY_BACKSPACE || evt.which == KEY_DELETE) {\r\n            let selectionRange = this.editor.getSelectionRange();\r\n\r\n            // Add snapshot when\r\n            // 1. Something has been selected (not collapsed), or\r\n            // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\r\n            // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\r\n            if (\r\n                selectionRange &&\r\n                (!selectionRange.collapsed ||\r\n                    this.lastKeyPress != evt.which ||\r\n                    evt.ctrlKey ||\r\n                    evt.metaKey)\r\n            ) {\r\n                this.addUndoSnapshot();\r\n            }\r\n\r\n            // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\r\n            this.hasNewContent = true;\r\n            this.lastKeyPress = evt.which;\r\n        } else if (evt.which >= KEY_PAGEUP && evt.which <= KEY_DOWN) {\r\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\r\n            if (this.hasNewContent) {\r\n                this.addUndoSnapshot();\r\n            }\r\n            this.lastKeyPress = 0;\r\n        }\r\n    }\r\n\r\n    private onKeyPress(evt: KeyboardEvent): void {\r\n        if (evt.metaKey) {\r\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\r\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\r\n            return;\r\n        }\r\n\r\n        let range = this.editor.getSelectionRange();\r\n        if (\r\n            (range && !range.collapsed) ||\r\n            (evt.which == KEY_SPACE && this.lastKeyPress != KEY_SPACE) ||\r\n            evt.which == KEY_ENTER\r\n        ) {\r\n            this.addUndoSnapshot();\r\n            if (evt.which == KEY_ENTER) {\r\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\r\n                // we restore the snapshot before ENTER\r\n                this.hasNewContent = true;\r\n            }\r\n        } else {\r\n            this.clearRedoForInput();\r\n        }\r\n\r\n        this.lastKeyPress = evt.which;\r\n    }\r\n\r\n    private clearRedoForInput() {\r\n        this.getSnapshotsManager().clearRedo();\r\n        this.lastKeyPress = 0;\r\n        this.hasNewContent = true;\r\n    }\r\n}\r\n","import { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear a cached object by its key from an event object\r\n * @param event The event object\r\n * @param key The cache key\r\n */\r\nexport default function clearEventDataCache(event: PluginEvent, key: string): void {\r\n    if (event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)) {\r\n        delete event.eventDataCache[key];\r\n    }\r\n}\r\n","import { ChangeSource, TableFormat } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Format table\r\n * @param editor The editor which contains the table to format\r\n * @param format A TableFormat object contains format information we want to apply to the table\r\n * @param table The table to format. This is optional. When not passed, the current table (if any) will be formatted\r\n */\r\nexport default function formatTable(\r\n    editor: Editor,\r\n    format: Partial<TableFormat>,\r\n    table?: HTMLTableElement\r\n) {\r\n    table = table || (editor.getElementAtCursor('TABLE') as HTMLTableElement);\r\n    if (table) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(table);\r\n            vtable.applyFormat(format);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n            editor.select(start, end);\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, PositionType, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    Browser,\r\n    Position,\r\n    wrap,\r\n    unwrap,\r\n    fromHtml,\r\n    getTagOfNode,\r\n    splitBalancedNodeRange,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst ZERO_WIDTH_SPACE = '&#8203;';\r\nconst UNWRAPPABLE_NODES = 'LI,THEAD,TBODY,TR,TD,TH'.split(',');\r\nconst DEFAULT_STYLER = (_: HTMLElement) => {};\r\n\r\n/**\r\n * Toggle a tag at selection, if selection already contains elements of such tag,\r\n * the elements will be untagge and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param tag The tag name\r\n * @param styler (Optional) The styler for setting the style for the blockquote element\r\n * @param wrapFunction (Optional) The wrap function\r\n * @param unwrapFunction (Optional) The unwrap function\r\n */\r\nexport default function toggleTagCore<T extends keyof HTMLElementTagNameMap>(\r\n    editor: Editor,\r\n    tag: T,\r\n    styler?: (element: HTMLElement) => void,\r\n    wrapFunction: (nodes: Node[]) => HTMLElement = nodes => wrap(nodes, tag),\r\n    unwrapFunction: (node: Node) => Node = unwrap\r\n): void {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        let result: HTMLElement;\r\n        let range = editor.getSelectionRange();\r\n        if (\r\n            range &&\r\n            editor.queryElements(tag, QueryScope.OnSelection, unwrapFunction).length == 0\r\n        ) {\r\n            let startNode = Position.getStart(range).normalize().node;\r\n            let startBlock = editor.getBlockElementAtNode(startNode);\r\n            let endNode = Position.getEnd(range).normalize().node;\r\n            let endBlock = editor.getBlockElementAtNode(endNode);\r\n            let nodes =\r\n                startBlock && endBlock\r\n                    ? editor.collapseNodes(\r\n                          startBlock.getStartNode(),\r\n                          endBlock.getEndNode(),\r\n                          true /*canSplitParent*/\r\n                      )\r\n                    : [];\r\n\r\n            if (nodes.length == 0) {\r\n                // Selection is collapsed and blockElement is null, we need to create an empty div.\r\n                // In case of IE and Edge, we insert ZWS to put cursor in the div, otherwise insert BR node.\r\n                nodes = fromHtml(\r\n                    `<DIV>${Browser.isIEOrEdge ? ZERO_WIDTH_SPACE : '<BR>'}</DIV>`,\r\n                    editor.getDocument()\r\n                );\r\n                editor.insertNode(nodes[0]);\r\n                editor.select(nodes[0], PositionType.Begin);\r\n            } else if (nodes.length == 1) {\r\n                let tag = getTagOfNode(nodes[0]);\r\n                if (tag == 'BR') {\r\n                    nodes = [wrap(nodes[0])];\r\n                } else if (tag == 'LI' || tag == 'TD') {\r\n                    nodes = [].slice.call(nodes[0].childNodes) as Node[];\r\n                }\r\n            } else {\r\n                while (\r\n                    nodes[0] &&\r\n                    editor.contains(nodes[0].parentNode) &&\r\n                    nodes.some(node => UNWRAPPABLE_NODES.indexOf(getTagOfNode(node)) >= 0)\r\n                ) {\r\n                    nodes = [splitBalancedNodeRange(nodes)];\r\n                }\r\n            }\r\n\r\n            result = wrapFunction(nodes);\r\n            (styler || DEFAULT_STYLER)(result);\r\n        }\r\n\r\n        if (!editor.select(start, end) && result) {\r\n            editor.select(result);\r\n        }\r\n\r\n        return result;\r\n    }, ChangeSource.Format);\r\n}\r\n","import { Map } from '../types/maps';\r\n\r\nfunction nativeClone<T>(source: Map<T>, existingObj?: Map<T>): Map<T> {\r\n    return Object.assign(existingObj || {}, source);\r\n}\r\n\r\nfunction customClone<T>(source: Map<T>, existingObj?: Map<T>): Map<T> {\r\n    let result: Map<T> = existingObj || {};\r\n    if (source) {\r\n        for (let key of Object.keys(source)) {\r\n            result[key] = source[key];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nconst cloneObject = Object.assign ? nativeClone : customClone;\r\n\r\nexport default cloneObject;\r\n","import { StringMap } from '../types/maps';\r\n\r\n// Inheritable CSS properties\r\n// Ref: https://www.w3.org/TR/CSS21/propidx.html\r\nconst INHERITABLE_PROPERTIES = (\r\n    'border-spacing,caption-side,color,' +\r\n    'cursor,direction,empty-cells,font-family,font-size,font-style,font-variant,font-weight,' +\r\n    'font,letter-spacing,line-height,list-style-image,list-style-position,list-style-type,' +\r\n    'list-style,orphans,quotes,text-align,text-indent,text-transform,visibility,white-space,' +\r\n    'widows,word-spacing'\r\n).split(',');\r\n\r\n/**\r\n * Get inheritable CSS style values from the given element\r\n * @param element The element to get style from\r\n */\r\nexport default function getInheritableStyles(element: HTMLElement): StringMap {\r\n    let win = element && element.ownerDocument && element.ownerDocument.defaultView;\r\n    let styles = win && win.getComputedStyle(element);\r\n    let result: StringMap = {};\r\n    INHERITABLE_PROPERTIES.forEach(\r\n        name => (result[name] = (styles && styles.getPropertyValue(name)) || '')\r\n    );\r\n    return result;\r\n}\r\n","const START_FRAGMENT = '<!--StartFragment-->';\r\nconst END_FRAGMENT = '<!--EndFragment-->';\r\n\r\n/**\r\n * Build DOM tree from the given HTML string\r\n * @param html Source HTML string\r\n * @param preserveFragmentOnly If there is fragment markup (<!--StartFragment--> and <!--EndFragment-->),\r\n * only preserve content between these markups\r\n * @param fragmentHandler An optional callback to do customized fragment handling\r\n */\r\nexport default function htmlToDom(\r\n    html: string,\r\n    preserveFragmentOnly: boolean,\r\n    fragmentHandler?: (doc: HTMLDocument, sourceHtml: string) => void\r\n): HTMLDocument {\r\n    let parser = new DOMParser();\r\n    let doc = parser.parseFromString(html || '', 'text/html');\r\n\r\n    if (doc && doc.body && doc.body.firstChild) {\r\n        // 1. Filter out html code outside of Fragment tags if need\r\n        if (preserveFragmentOnly) {\r\n            (fragmentHandler || defaultFragmentTrimmer)(doc, html);\r\n        }\r\n\r\n        return doc;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction defaultFragmentTrimmer(doc: HTMLDocument, sourceHtml: string) {\r\n    let [html] = splitWithFragment(sourceHtml);\r\n    doc.body.innerHTML = html;\r\n}\r\n\r\n/**\r\n * Split the HTML string using its fragment info\r\n * @param html Source html string\r\n * @returns [String within fragment, String before fragment, String after fragment]\r\n */\r\nexport function splitWithFragment(html: string): [string, string, string] {\r\n    let startIndex = html.indexOf(START_FRAGMENT);\r\n    let endIndex = html.lastIndexOf(END_FRAGMENT);\r\n    if (startIndex >= 0 && endIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {\r\n        let before = html.substr(0, startIndex);\r\n        let after = html.substr(endIndex + END_FRAGMENT.length);\r\n        html = html.substring(startIndex + START_FRAGMENT.length, endIndex);\r\n        return [html, before, after];\r\n    } else {\r\n        return [html, null, null];\r\n    }\r\n}\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/** NodeId attribute */\r\nconst NODE_ID_ATTRIBUTE_NAME = 'NodeId';\r\n\r\n/** Custom data for dom elements */\r\nexport default interface CustomData {\r\n    /** The dict storing custom data, key is element Id, value is dictionary */\r\n    dict: { [key: string]: { [key: string]: number } };\r\n\r\n    /** Next node Id to use */\r\n    nextNodeId: number;\r\n}\r\n\r\n/** create an empty CustomData */\r\nexport function createCustomData(): CustomData {\r\n    return {\r\n        dict: {},\r\n        nextNodeId: 1,\r\n    };\r\n}\r\n\r\n/**\r\n * Sets the specified object data\r\n */\r\nexport function setObject(customData: CustomData, element: Node, key: string, value: any) {\r\n    // Get the id for the element\r\n    if (element.nodeType == NodeType.Element) {\r\n        let id = getAndSetNodeId(customData, element as HTMLElement);\r\n        if (id != '') {\r\n            // Get the values for the element\r\n            if (!customData.dict[id]) {\r\n                // First time dictionary creation\r\n                customData.dict[id] = {};\r\n            }\r\n            customData.dict[id][key] = value;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Reads the specified object data\r\n */\r\nexport function getObject(customData: CustomData, element: Node, key: string): any {\r\n    if (element.nodeType == NodeType.Element) {\r\n        let id = getAndSetNodeId(customData, element as HTMLElement);\r\n        if (id != '') {\r\n            return customData.dict[id] && customData.dict[id][key];\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/** Get the unique id for the specified node... */\r\nfunction getAndSetNodeId(customData: CustomData, element: HTMLElement): string {\r\n    let id = element.getAttribute(NODE_ID_ATTRIBUTE_NAME);\r\n    if (!id) {\r\n        id = customData.nextNodeId.toString();\r\n        customData.nextNodeId++;\r\n        element.setAttribute(NODE_ID_ATTRIBUTE_NAME, id);\r\n    }\r\n    return id;\r\n}\r\n","import ListMetadata from './ListMetadata';\r\n\r\n/** Holds the ids for the lists already seen for a specified level */\r\nexport default interface LevelLists {\r\n    /**\r\n     * The metadata for the lists seen at  this level\r\n     * key: word list id, value: list metadata\r\n     */\r\n    listsMetadata: { [key: string]: ListMetadata };\r\n\r\n    /** Unique id of the list currently at this level */\r\n    currentUniqueListId: number;\r\n}\r\n\r\n/** create an empty LevelLists */\r\nexport function createLevelLists(): LevelLists {\r\n    return {\r\n        listsMetadata: {},\r\n        currentUniqueListId: -1,\r\n    };\r\n}\r\n","export { default as createEditor } from './createEditor';\r\nexport * from 'roosterjs-editor-types';\r\nexport * from 'roosterjs-editor-dom';\r\nexport * from 'roosterjs-editor-core';\r\nexport * from 'roosterjs-editor-api';\r\nexport * from 'roosterjs-editor-plugins';\r\nexport * from 'roosterjs-plugin-image-resize';\r\nexport * from 'roosterjs-html-sanitizer';\r\n","import { ContentEdit, HyperLink, Paste } from 'roosterjs-editor-plugins';\r\nimport { Editor, EditorOptions, EditorPlugin } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Create an editor instance with most common options\r\n * @param contentDiv The html div element needed for creating the editor\r\n * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are\r\n * DefalutShortcut, HyperLink, Paste, and ContentEdit, user don't need to add those.\r\n * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.\r\n * @returns The editor instance\r\n */\r\nexport default function createEditor(\r\n    contentDiv: HTMLDivElement,\r\n    additionalPlugins?: EditorPlugin[],\r\n    initialContent?: string\r\n): Editor {\r\n    let plugins: EditorPlugin[] = [new HyperLink(), new Paste(), new ContentEdit()];\r\n\r\n    if (additionalPlugins) {\r\n        plugins = plugins.concat(additionalPlugins);\r\n    }\r\n\r\n    let options: EditorOptions = {\r\n        plugins: plugins,\r\n        initialContent: initialContent,\r\n        defaultFormat: {\r\n            fontFamily: 'Calibri,Arial,Helvetica,sans-serif',\r\n            fontSize: '11pt',\r\n            textColor: '#000000',\r\n        },\r\n    };\r\n    return new Editor(contentDiv, options);\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * An editor plugin that show a tooltip for existing link\r\n */\r\nexport default class HyperLink implements EditorPlugin {\r\n    private editor: Editor;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Create a new instance of HyperLink class\r\n     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.\r\n     * Default value is to return the href itself. If null, there will be no tooltip text.\r\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\r\n     * @param onLinkClick (Optional) Open link callback\r\n     */\r\n    constructor(\r\n        private getTooltipCallback: (href: string, a: HTMLAnchorElement) => string = href => href,\r\n        private target?: string,\r\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => void\r\n    ) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Hyperlink';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    public initialize(editor: Editor): void {\r\n        this.editor = editor;\r\n        this.disposer =\r\n            this.getTooltipCallback &&\r\n            editor.addDomEventHandler({ mouseover: this.onMouse, mouseout: this.onMouse });\r\n    }\r\n\r\n    protected onMouse = (e: MouseEvent) => {\r\n        const a = this.editor.getElementAtCursor('a[href]', e.srcElement) as HTMLAnchorElement;\r\n        const href = this.tryGetHref(a);\r\n\r\n        if (href) {\r\n            this.editor.setEditorDomAttribute(\r\n                'title',\r\n                e.type == 'mouseover' ? this.getTooltipCallback(href, a) : null\r\n            );\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose(): void {\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    public onPluginEvent(event: PluginEvent): void {\r\n        if (event.eventType == PluginEventType.MouseUp) {\r\n            const anchor = this.editor.getElementAtCursor(\r\n                'A',\r\n                event.rawEvent.srcElement\r\n            ) as HTMLAnchorElement;\r\n\r\n            if (anchor) {\r\n                if (this.onLinkClick) {\r\n                    this.onLinkClick(anchor, event.rawEvent);\r\n                    return;\r\n                }\r\n\r\n                let href: string;\r\n                if (\r\n                    !Browser.isFirefox &&\r\n                    (href = this.tryGetHref(anchor)) &&\r\n                    (Browser.isMac ? event.rawEvent.metaKey : event.rawEvent.ctrlKey)\r\n                ) {\r\n                    try {\r\n                        const target = this.target || '_blank';\r\n                        const window = this.editor.getDocument().defaultView;\r\n                        window.open(href, target);\r\n                    } catch {}\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Try get href from an anchor element\r\n     * The reason this is put in a try-catch is that\r\n     * it has been seen that accessing href may throw an exception, in particular on IE/Edge\r\n     */\r\n    private tryGetHref(anchor: HTMLAnchorElement): string {\r\n        try {\r\n            return anchor ? anchor.href : null;\r\n        } catch {}\r\n    }\r\n}\r\n","import contains from '../utils/contains';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\nimport { getFirstBlockElement } from '../blockElements/getFirstLastBlockElement';\r\nimport { getFirstInlineElement } from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * provides scoper for traversing the entire editor body starting from the beginning\r\n */\r\nclass BodyScoper implements TraversingScoper {\r\n    /**\r\n     * Construct a new instance of BodyScoper class\r\n     * @param rootNode Root node of the body\r\n     */\r\n    constructor(public rootNode: Node) {}\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return getFirstBlockElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        return getFirstInlineElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Since the scope is global, all blocks under the root node are in scope\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return contains(this.rootNode, blockElement.getStartNode());\r\n    }\r\n\r\n    /**\r\n     * Since we're at body scope, inline elements never need to be trimmed\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return inlineElement;\r\n    }\r\n}\r\n\r\nexport default BodyScoper;\r\n","import EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport NodeBlockElement from '../blockElements/NodeBlockElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport {\r\n    getFirstInlineElement,\r\n    getLastInlineElement,\r\n} from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * This provides traversing content in a selection start block\r\n * This is commonly used for those cursor context sensitive plugin,\r\n * they want to know text being typed at cursor\r\n * This provides a scope for parsing from cursor position up to begin of the selection block\r\n */\r\nclass SelectionBlockScoper implements TraversingScoper {\r\n    private block: BlockElement;\r\n    private position: NodePosition;\r\n\r\n    /**\r\n     * Create a new instance of SelectionBlockScoper class\r\n     * @param rootNode The root node of the whole scope\r\n     * @param position Position of the selection start\r\n     * @param startFrom Where to start, can be Begin, End, SelectionStart\r\n     */\r\n    constructor(\r\n        public rootNode: Node,\r\n        position: NodePosition | Range,\r\n        private startFrom: ContentPosition\r\n    ) {\r\n        position = position instanceof Range ? Position.getStart(position) : position;\r\n        this.position = position.normalize();\r\n        this.block = getBlockElementAtNode(this.rootNode, this.position.node);\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.block;\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     * The start inline refers to inline before the selection start\r\n     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragragh,\r\n     * the one after likely will point to inline in next paragragh which may be null if the cursor is at bottom of editor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (this.block) {\r\n            switch (this.startFrom) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End:\r\n                    return getFirstLastInlineElementFromBlockElement(\r\n                        this.block,\r\n                        this.startFrom == ContentPosition.Begin\r\n                    );\r\n                case ContentPosition.SelectionStart:\r\n                    // Get the inline before selection start point, and ensure it falls in the selection block\r\n                    let startInline = getInlineElementAfter(this.rootNode, this.position);\r\n                    return startInline && this.block.contains(startInline.getContainerNode())\r\n                        ? startInline\r\n                        : new EmptyInlineElement(this.position, this.block);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if the given block element is in current scope\r\n     * @param blockElement The block element to check\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return this.block && blockElement ? this.block.equals(blockElement) : false;\r\n    }\r\n\r\n    /**\r\n     * Trim the incoming inline element, and return an inline element\r\n     * This just tests and return the inline element if it is in block\r\n     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half\r\n     * A block scoper does not cut an inline in half\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())\r\n            ? inlineElement\r\n            : null;\r\n    }\r\n}\r\n\r\nexport default SelectionBlockScoper;\r\n\r\n/**\r\n * Get first/last InlineElement of the given BlockElement\r\n * @param block The BlockElement to get InlineElement from\r\n * @param isFirst True to get first InlineElement, false to get last InlineElement\r\n */\r\nfunction getFirstLastInlineElementFromBlockElement(\r\n    block: BlockElement,\r\n    isFirst: boolean\r\n): InlineElement {\r\n    if (block instanceof NodeBlockElement) {\r\n        let blockNode = block.getStartNode();\r\n        return isFirst ? getFirstInlineElement(blockNode) : getLastInlineElement(blockNode);\r\n    } else {\r\n        return getInlineElementAtNode(block, isFirst ? block.getStartNode() : block.getEndNode());\r\n    }\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\n\r\n/**\r\n * This is selection scoper that provide a start inline as the start of the selection\r\n * and checks if a block falls in the selection (isBlockInScope)\r\n * last trimInlineElement to trim any inline element to return a partial that falls in the selection\r\n */\r\nclass SelectionScoper implements TraversingScoper {\r\n    private start: NodePosition;\r\n    private end: NodePosition;\r\n    private startBlock: BlockElement;\r\n    private startInline: InlineElement;\r\n\r\n    /**\r\n     * Create a new instance of SelectionScoper class\r\n     * @param rootNode The root node of the content\r\n     * @param range The selection range to scope to\r\n     */\r\n    constructor(public rootNode: Node, range: Range) {\r\n        this.start = Position.getStart(range).normalize();\r\n        this.end = Position.getEnd(range).normalize();\r\n    }\r\n\r\n    /**\r\n     * Provide a start block as the first block after the cursor\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        if (!this.startBlock) {\r\n            this.startBlock = getBlockElementAtNode(this.rootNode, this.start.node);\r\n        }\r\n\r\n        return this.startBlock;\r\n    }\r\n\r\n    /**\r\n     * Provide a start inline as the first inline after the cursor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (!this.startInline) {\r\n            this.startInline = this.trimInlineElement(\r\n                getInlineElementAfter(this.rootNode, this.start)\r\n            );\r\n        }\r\n\r\n        return this.startInline;\r\n    }\r\n\r\n    /**\r\n     * Checks if a block completely falls in the selection\r\n     * @param block The BlockElement to check\r\n     */\r\n    public isBlockInScope(block: BlockElement): boolean {\r\n        if (!block) {\r\n            return false;\r\n        }\r\n        let inScope = false;\r\n        let selStartBlock = this.getStartBlockElement();\r\n        if (this.start.equalTo(this.end)) {\r\n            inScope = selStartBlock && selStartBlock.equals(block);\r\n        } else {\r\n            let selEndBlock = getBlockElementAtNode(this.rootNode, this.end.node);\r\n\r\n            // There are three cases that are considered as \"block in scope\"\r\n            // 1) The start of selection falls on the block\r\n            // 2) The end of selection falls on the block\r\n            // 3) the block falls in-between selection start and end\r\n            inScope =\r\n                selStartBlock &&\r\n                selEndBlock &&\r\n                (block.equals(selStartBlock) ||\r\n                    block.equals(selEndBlock) ||\r\n                    (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));\r\n        }\r\n\r\n        return inScope;\r\n    }\r\n\r\n    /**\r\n     * Trim an incoming inline. If it falls completely outside selection, return null\r\n     * otherwise return a partial that represents the portion that falls in the selection\r\n     * @param inline The InlineElement to check\r\n     */\r\n    public trimInlineElement(inline: InlineElement): InlineElement {\r\n        if (!inline || this.start.equalTo(this.end)) {\r\n            return null;\r\n        }\r\n\r\n        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon\r\n        let start = inline.getStartPosition();\r\n        let end = inline.getEndPosition();\r\n\r\n        if (start.isAfter(this.end) || this.start.isAfter(end)) {\r\n            return null;\r\n        }\r\n\r\n        let startPartial = false;\r\n        let endPartial = false;\r\n\r\n        if (this.start.isAfter(start)) {\r\n            start = this.start;\r\n            startPartial = true;\r\n        }\r\n\r\n        if (end.isAfter(this.end)) {\r\n            end = this.end;\r\n            endPartial = true;\r\n        }\r\n\r\n        return start.isAfter(end) || start.equalTo(end)\r\n            ? null\r\n            : startPartial || endPartial\r\n            ? new PartialInlineElement(inline, startPartial && start, endPartial && end)\r\n            : inline;\r\n    }\r\n}\r\n\r\nexport default SelectionScoper;\r\n","import ContentTraverser from './ContentTraverser';\r\nimport createRange from '../selection/createRange';\r\nimport { InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n// White space matching regex. It matches following chars:\r\n// \\s: white space\r\n// \\u00A0: no-breaking white space\r\n// \\u200B: zero width space\r\n// \\u3000: full width space (which can come from JPN IME)\r\nconst WHITESPACE_REGEX = /[\\s\\u00A0\\u200B\\u3000]+([^\\s\\u00A0\\u200B\\u3000]*)$/i;\r\n\r\n/**\r\n * The class that helps search content around a position\r\n */\r\nexport default class PositionContentSearcher {\r\n    // The cached text before position that has been read so far\r\n    private text = '';\r\n\r\n    // The cached word before position\r\n    private word: string;\r\n\r\n    // The inline element before position\r\n    private inlineBefore: InlineElement;\r\n\r\n    // The inline element after position\r\n    private inlineAfter: InlineElement;\r\n\r\n    // The content traverser used to traverse backwards\r\n    private traverser: ContentTraverser;\r\n\r\n    // Backward parsing has completed\r\n    private traversingComplete: boolean;\r\n\r\n    // All inline elements before position that have been read so far\r\n    private inlineElements: InlineElement[] = [];\r\n\r\n    // First non-text inline before position\r\n    private nearestNonTextInlineElement: InlineElement;\r\n\r\n    /**\r\n     * Create a new CursorData instance\r\n     * @param rootNode Root node of the whole scope\r\n     * @param position Start position\r\n     */\r\n    constructor(private rootNode: Node, private position: NodePosition) {}\r\n\r\n    /**\r\n     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion\r\n     * between position and the white space is the word before position\r\n     * @returns The word before position\r\n     */\r\n    public getWordBefore(): string {\r\n        if (!this.word) {\r\n            this.traverse(() => this.word);\r\n        }\r\n\r\n        return this.word;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element before position\r\n     * @returns The inlineElement before position\r\n     */\r\n    public getInlineElementBefore(): InlineElement {\r\n        if (!this.inlineBefore) {\r\n            this.traverse(null);\r\n        }\r\n\r\n        return this.inlineBefore;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element after position\r\n     * @returns The inline element after position\r\n     */\r\n    public getInlineElementAfter(): InlineElement {\r\n        if (!this.inlineAfter) {\r\n            this.inlineAfter = ContentTraverser.createBlockTraverser(\r\n                this.rootNode,\r\n                this.position\r\n            ).currentInlineElement;\r\n        }\r\n\r\n        return this.inlineAfter;\r\n    }\r\n\r\n    /**\r\n     * Get X number of chars before position\r\n     * The actual returned chars may be less than what is requested.\r\n     * @param length The length of string user want to get, the string always ends at the position,\r\n     * so this length determins the start position of the string\r\n     * @returns The actual string we get as a sub string, or the whole string before position when\r\n     * there is not enough chars in the string\r\n     */\r\n    public getSubStringBefore(length: number): string {\r\n        if (this.text.length < length) {\r\n            this.traverse(() => this.text.length >= length);\r\n        }\r\n\r\n        return this.text.substr(Math.max(0, this.text.length - length));\r\n    }\r\n\r\n    /**\r\n     * Try to get a range matches the given text before the position\r\n     * @param text The text to match against\r\n     * @param exactMatch Whether it is an exact match\r\n     * @returns The range for the matched text, null if unable to find a match\r\n     */\r\n    public getRangeFromText(text: string, exactMatch: boolean): Range {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        let startPosition: NodePosition;\r\n        let endPosition: NodePosition;\r\n        let textIndex = text.length - 1;\r\n\r\n        this.forEachTextInlineElement(textInline => {\r\n            let nodeContent = textInline.getTextContent() || '';\r\n            let nodeIndex = nodeContent.length - 1;\r\n            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {\r\n                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {\r\n                    textIndex--;\r\n\r\n                    // on first time when end is matched, set the end of range\r\n                    if (!endPosition) {\r\n                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                    }\r\n                } else if (exactMatch || endPosition) {\r\n                    // Mismatch found when exact match or end already match, so return since matching failed\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // when textIndex == -1, we have a successful complete match\r\n            if (textIndex == -1) {\r\n                startPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return startPosition && endPosition && createRange(startPosition, endPosition);\r\n    }\r\n\r\n    /**\r\n     * Get text section before position till stop condition is met.\r\n     * This offers consumers to retrieve text section by section\r\n     * The section essentially is just an inline element which has Container element\r\n     * so that the consumer can remember it for anchoring popup or verification purpose\r\n     * when position moves out of context etc.\r\n     * @param stopFunc The callback stop function\r\n     */\r\n    public forEachTextInlineElement(callback: (textInlineElement: InlineElement) => any) {\r\n        // We cache all text sections read so far\r\n        // Every time when you ask for textSection, we start with the cached first\r\n        // and resort to further reading once we exhausted with the cache\r\n        if (!this.inlineElements.some(callback)) {\r\n            this.traverse(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get first non textual inline element before position\r\n     * @returns First non textutal inline element before position or null if no such element exists\r\n     */\r\n    public getNearestNonTextInlineElement(): InlineElement {\r\n        if (!this.nearestNonTextInlineElement) {\r\n            this.traverse(() => this.nearestNonTextInlineElement);\r\n        }\r\n\r\n        return this.nearestNonTextInlineElement;\r\n    }\r\n\r\n    /**\r\n     * Continue traversing backward till stop condition is met or begin of block is reached\r\n     */\r\n    private traverse(callback: (inlineElement: InlineElement) => any) {\r\n        this.traverser =\r\n            this.traverser || ContentTraverser.createBlockTraverser(this.rootNode, this.position);\r\n\r\n        if (!this.traverser || this.traversingComplete) {\r\n            return;\r\n        }\r\n\r\n        let previousInline = this.traverser.getPreviousInlineElement();\r\n        while (!this.traversingComplete) {\r\n            this.inlineBefore = this.inlineBefore || previousInline;\r\n\r\n            if (previousInline && previousInline.isTextualInlineElement()) {\r\n                let textContent = previousInline.getTextContent();\r\n\r\n                // build the word before position if it is not built yet\r\n                if (!this.word) {\r\n                    // Match on the white space, the portion after space is on the index of 1 of the matched result\r\n                    // (index at 0 is whole match result, index at 1 is the word)\r\n                    let matches = WHITESPACE_REGEX.exec(textContent);\r\n                    if (matches && matches.length == 2) {\r\n                        this.word = matches[1] + this.text;\r\n                    }\r\n                }\r\n\r\n                this.text = textContent + this.text;\r\n                this.inlineElements.push(previousInline);\r\n\r\n                // Check if stop condition is met\r\n                if (callback && callback(previousInline)) {\r\n                    break;\r\n                }\r\n            } else {\r\n                this.nearestNonTextInlineElement = previousInline;\r\n                this.traversingComplete = true;\r\n                if (!this.word) {\r\n                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor\r\n                    this.word = this.text;\r\n                }\r\n\r\n                // When a non-textual inline element, or null is seen, we consider parsing complete\r\n                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.\r\n                // we have aaa @someone bbb<position>, and we want to read the text before @someone\r\n                break;\r\n            }\r\n\r\n            previousInline = this.traverser.getPreviousInlineElement();\r\n        }\r\n    }\r\n}\r\n","import { DefaultFormat } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Apply format to an HTML element\r\n * @param element The HTML element to apply format to\r\n * @param format The format to apply\r\n */\r\nexport default function applyFormat(element: HTMLElement, format: DefaultFormat) {\r\n    if (format) {\r\n        let elementStyle = element.style;\r\n        let { fontFamily, fontSize, textColor, backgroundColor, bold, italic, underline } = format;\r\n\r\n        if (fontFamily) {\r\n            elementStyle.fontFamily = fontFamily;\r\n        }\r\n        if (fontSize) {\r\n            elementStyle.fontSize = fontSize;\r\n        }\r\n        if (textColor) {\r\n            elementStyle.color = textColor;\r\n        }\r\n        if (backgroundColor) {\r\n            elementStyle.backgroundColor = backgroundColor;\r\n        }\r\n        if (bold) {\r\n            elementStyle.fontWeight = 'bold';\r\n        }\r\n        if (italic) {\r\n            elementStyle.fontStyle = 'italic';\r\n        }\r\n        if (underline) {\r\n            elementStyle.textDecoration = 'underline';\r\n        }\r\n    }\r\n}\r\n","import getComputedStyles from './getComputedStyles';\r\nimport getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag<K extends keyof HTMLElementTagNameMap>(\r\n    element: HTMLElement,\r\n    newTag: K\r\n): HTMLElementTagNameMap[K];\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement;\r\n\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement {\r\n    if (!element || !newTag) {\r\n        return null;\r\n    }\r\n\r\n    let newElement = element.ownerDocument.createElement(newTag);\r\n\r\n    for (let i = 0; i < element.attributes.length; i++) {\r\n        let attr = element.attributes[i];\r\n        newElement.setAttribute(attr.name, attr.value);\r\n    }\r\n\r\n    while (element.firstChild) {\r\n        newElement.appendChild(element.firstChild);\r\n    }\r\n\r\n    if (getTagOfNode(element) == 'P' || getTagOfNode(newElement) == 'P') {\r\n        [newElement.style.marginTop, newElement.style.marginBottom] = getComputedStyles(element, [\r\n            'margin-top',\r\n            'margin-bottom',\r\n        ]);\r\n    }\r\n\r\n    if (element.parentNode) {\r\n        element.parentNode.replaceChild(newElement, element);\r\n    }\r\n\r\n    return newElement;\r\n}\r\n","import Browser from './Browser';\r\nimport { ClipboardItems } from 'roosterjs-editor-types';\r\n\r\n// HTML header to indicate where is the HTML content started from.\r\n// Sample header:\r\n// Version:0.9\r\n// StartHTML:71\r\n// EndHTML:170\r\n// StartFragment:140\r\n// EndFragment:160\r\n// StartSelection:140\r\n// EndSelection:160\r\nconst CLIPBOARD_HTML_HEADER_REGEX = /^Version:[0-9\\.]+\\s+StartHTML:\\s*([0-9]+)\\s+EndHTML:\\s*([0-9]+)\\s+/i;\r\n\r\ninterface WindowForIE extends Window {\r\n    clipboardData: DataTransfer;\r\n}\r\n\r\n/**\r\n * Extract a Clipboard event\r\n * @param event The paste event\r\n * @param callback Callback function when data is ready\r\n * @param fallbackHtmlRetriever If direct HTML retriving is not support (e.g. Internet Explorer), as a fallback,\r\n * using this helper function to retrieve HTML content\r\n * @returns An object with the following properties:\r\n *  types: Available types from the clipboard event\r\n *  text: Plain text from the clipboard event\r\n *  image: Image file from the clipboard event\r\n *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.\r\n *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is\r\n *   not supported by browser.\r\n */\r\nexport default function extractClipboardEvent(\r\n    event: ClipboardEvent,\r\n    callback: (items: ClipboardItems) => void\r\n) {\r\n    let dataTransfer =\r\n        event.clipboardData ||\r\n        (<WindowForIE>event.srcElement.ownerDocument.defaultView).clipboardData;\r\n    let result: ClipboardItems = {\r\n        types: dataTransfer.types ? [].slice.call(dataTransfer.types) : [],\r\n        text: dataTransfer.getData('text'),\r\n        image: getImage(dataTransfer),\r\n        html: undefined,\r\n    };\r\n\r\n    if (event.clipboardData && event.clipboardData.items) {\r\n        event.preventDefault();\r\n        let items = event.clipboardData.items;\r\n        for (let i = 0; i < items.length; i++) {\r\n            let item = items[i];\r\n            if (item.type && item.type.indexOf('text/html') == 0) {\r\n                item.getAsString(html => {\r\n                    result.html = Browser.isEdge ? workaroundForEdge(html) : html;\r\n                    callback(result);\r\n                });\r\n                return;\r\n            }\r\n        }\r\n\r\n        // No HTML content found, set html to null\r\n        result.html = null;\r\n    }\r\n\r\n    callback(result);\r\n}\r\n\r\nfunction getImage(dataTransfer: DataTransfer): File {\r\n    // Chrome, Firefox, Edge support dataTransfer.items\r\n    let fileCount = dataTransfer.items ? dataTransfer.items.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let item = dataTransfer.items[i];\r\n        if (item.type && item.type.indexOf('image/') == 0) {\r\n            return item.getAsFile();\r\n        }\r\n    }\r\n    // IE, Safari support dataTransfer.files\r\n    fileCount = dataTransfer.files ? dataTransfer.files.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let file = dataTransfer.files.item(i);\r\n        if (file.type && file.type.indexOf('image/') == 0) {\r\n            return file;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Edge sometimes doesn't remove the headers, which cause we paste more things then expected.\r\n * So we need to remove it in our code\r\n * @param html The HTML string got from clipboard\r\n */\r\nfunction workaroundForEdge(html: string) {\r\n    let headerValues = CLIPBOARD_HTML_HEADER_REGEX.exec(html);\r\n\r\n    if (headerValues && headerValues.length == 3) {\r\n        let start = parseInt(headerValues[1]);\r\n        let end = parseInt(headerValues[2]);\r\n        if (start > 0 && end > start) {\r\n            html = html.substring(start, end);\r\n        }\r\n    }\r\n\r\n    return html;\r\n}\r\n","import { LinkData } from 'roosterjs-editor-types';\r\n\r\ninterface LinkMatchRule {\r\n    match: RegExp;\r\n    except?: RegExp;\r\n    normalizeUrl?: (url: string) => string;\r\n}\r\n\r\n// http exclude matching regex\r\n// invalid URL example (in paricular on IE and Edge):\r\n// - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception\r\n// - http://www.bing.com%1, %1 is invalid\r\n// - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)\r\n// - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)\r\n// All above % cases if they're after ? (question mark) is then considered valid again\r\n// Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception\r\n// - http://www.bing.com@name, @name before ? (question mark) is considered invalid\r\n// - http://www.bing.com/@name, is valid sine it is after / (forward slash)\r\n// - http://www.bing.com?@name, is also valid sinve it is after ? (question mark)\r\n// The regex below is essentially a break down of:\r\n// ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%\r\n// ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1\r\n// ^[^?]+%00 => to exclude URL like www.bing.com%00\r\n// ^[^?]+%$ => to exclude URL like www.bing.com%\r\n// ^https?:\\/\\/[^?\\/]+@ => to exclude URL like http://www.bing.com@name\r\n// ^www\\.[^?\\/]+@ => to exclude URL like www.bing.com@name\r\n// , => to exclude url like www.bing,,com\r\nconst httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\\/\\/[^?\\/]+@|^www\\.[^?\\/]+@/i;\r\n\r\n// via https://tools.ietf.org/html/rfc1035 Page 7\r\nconst labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexes below so don't bother including A-Z\r\nconst domainNameRegEx = `(?:${labelRegEx}\\\\.)*${labelRegEx}`;\r\nconst domainPortRegEx = `${domainNameRegEx}(?:\\\\:[0-9]+)?`;\r\nconst domainPortWithUrlRegEx = `${domainPortRegEx}(?:[\\\\/\\\\?]\\\\S*)?`;\r\n\r\nconst linkMatchRules: { [schema: string]: LinkMatchRule } = {\r\n    http: {\r\n        match: new RegExp(\r\n            `^(?:microsoft-edge:)?http:\\\\/\\\\/${domainPortWithUrlRegEx}|www\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        except: httpExcludeRegEx,\r\n        normalizeUrl: url =>\r\n            new RegExp('^(?:microsoft-edge:)?http:\\\\/\\\\/', 'i').test(url) ? url : 'http://' + url,\r\n    },\r\n    https: {\r\n        match: new RegExp(`^(?:microsoft-edge:)?https:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i'),\r\n        except: httpExcludeRegEx,\r\n    },\r\n    mailto: { match: new RegExp('^mailto:\\\\S+@\\\\S+\\\\.\\\\S+', 'i') },\r\n    notes: { match: new RegExp('^notes:\\\\/\\\\/\\\\S+', 'i') },\r\n    file: { match: new RegExp('^file:\\\\/\\\\/\\\\/?\\\\S+', 'i') },\r\n    unc: { match: new RegExp('^\\\\\\\\\\\\\\\\\\\\S+', 'i') },\r\n    ftp: {\r\n        match: new RegExp(\r\n            `^ftp:\\\\/\\\\/${domainPortWithUrlRegEx}|ftp\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        normalizeUrl: url => (new RegExp('^ftp:\\\\/\\\\/', 'i').test(url) ? url : 'ftp://' + url),\r\n    },\r\n    news: { match: new RegExp(`^news:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    telnet: { match: new RegExp(`^telnet:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    gopher: { match: new RegExp(`^gopher:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i') },\r\n    wais: { match: new RegExp(`^wais:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n};\r\n\r\n/**\r\n * Try to match a given string with link match rules, return matched link\r\n * @param url Input url to match\r\n * @param option Link match option, exact or partial. If it is exact match, we need\r\n * to check the length of matched link and url\r\n * @param rules Optional link match rules, if not passed, only the default link match\r\n * rules will be applied\r\n * @returns The matched link data, or null if no match found.\r\n * The link data includes an original url and a normalized url\r\n */\r\nexport default function matchLink(url: string): LinkData {\r\n    if (url) {\r\n        for (let schema of Object.keys(linkMatchRules)) {\r\n            let rule = linkMatchRules[schema];\r\n            let matches = url.match(rule.match);\r\n            if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {\r\n                return {\r\n                    scheme: schema,\r\n                    originalUrl: url,\r\n                    normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import { DocumentPosition } from 'roosterjs-editor-types';\r\nimport { QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Query HTML elements in the container by a selector string\r\n * @param container Container element to query from\r\n * @param selector Selector string to query\r\n * @param forEachCallback An optional callback to be invoked on each node in query result\r\n * @param scope The scope of the query, default value is QueryScope.Body\r\n * @param range The selection range to query with. This is required when scope is not Body\r\n * @returns HTML Element array of the query result\r\n */\r\nexport default function queryElements(\r\n    container: HTMLElement,\r\n    selector: string,\r\n    forEachCallback?: (node: HTMLElement) => any,\r\n    scope: QueryScope = QueryScope.Body,\r\n    range?: Range\r\n): HTMLElement[] {\r\n    if (!container || !selector) {\r\n        return [];\r\n    }\r\n\r\n    let elements = [].slice.call(container.querySelectorAll(selector)) as HTMLElement[];\r\n\r\n    if (scope != QueryScope.Body && range) {\r\n        elements = elements.filter(element =>\r\n            isIntersectWithNodeRange(element, range, scope == QueryScope.InSelection)\r\n        );\r\n    }\r\n\r\n    if (forEachCallback) {\r\n        elements.forEach(forEachCallback);\r\n    }\r\n    return elements;\r\n}\r\n\r\nfunction isIntersectWithNodeRange(\r\n    node: Node,\r\n    range: Range,\r\n    nodeContainedByRangeOnly: boolean\r\n): boolean {\r\n    let startPosition = node.compareDocumentPosition(range.startContainer);\r\n    let endPosition = node.compareDocumentPosition(range.endContainer);\r\n    let targetPositions = [DocumentPosition.Same, DocumentPosition.Contains];\r\n\r\n    if (!nodeContainedByRangeOnly) {\r\n        targetPositions.push(DocumentPosition.ContainedBy);\r\n    }\r\n\r\n    return (\r\n        checkPosition(startPosition, targetPositions) || // intersectStart\r\n        checkPosition(endPosition, targetPositions) || // intersectEnd\r\n        (checkPosition(startPosition, [DocumentPosition.Preceding]) && // Contains\r\n            checkPosition(endPosition, [DocumentPosition.Following]) &&\r\n            !checkPosition(endPosition, [DocumentPosition.ContainedBy]))\r\n    );\r\n}\r\n\r\nfunction checkPosition(position: DocumentPosition, targets: DocumentPosition[]): boolean {\r\n    return targets.some(target =>\r\n        target == DocumentPosition.Same\r\n            ? position == DocumentPosition.Same\r\n            : (position & target) == target\r\n    );\r\n}\r\n","/**\r\n * Removes the node and keep all children in place, return the parentNode where the children are attached\r\n * @param node the node to remove\r\n */\r\nexport default function unwrap(node: Node): Node {\r\n    // Unwrap requires a parentNode\r\n    let parentNode = node ? node.parentNode : null;\r\n    if (!parentNode) {\r\n        return null;\r\n    }\r\n\r\n    while (node.firstChild) {\r\n        parentNode.insertBefore(node.firstChild, node);\r\n    }\r\n\r\n    parentNode.removeChild(node);\r\n    return parentNode;\r\n}\r\n","import { TableFormat, TableOperation } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a virtual cell of a virtual table\r\n */\r\nexport interface VCell {\r\n    /**\r\n     * The table cell object. The value will be null if this is an expanded virtual cell\r\n     */\r\n    td?: HTMLTableCellElement;\r\n\r\n    /**\r\n     * Whether this cell is spanned from left\r\n     */\r\n    spanLeft?: boolean;\r\n\r\n    /**\r\n     * Whether this cell is spanned from above\r\n     */\r\n    spanAbove?: boolean;\r\n}\r\n\r\n/**\r\n * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells\r\n */\r\nexport default class VTable {\r\n    /**\r\n     * The HTML table object\r\n     */\r\n    table: HTMLTableElement;\r\n\r\n    /**\r\n     * Virtual cells\r\n     */\r\n    cells: VCell[][];\r\n\r\n    /**\r\n     * Current row index\r\n     */\r\n    row: number;\r\n\r\n    /**\r\n     * Current column index\r\n     */\r\n    col: number;\r\n\r\n    private trs: HTMLTableRowElement[] = [];\r\n\r\n    /**\r\n     * Create a new instance of VTable object using HTML TABLE or TD node\r\n     * @param node The HTML Table or TD node\r\n     */\r\n    constructor(node: HTMLTableElement | HTMLTableCellElement) {\r\n        this.table = node instanceof HTMLTableElement ? node : getTableFromTd(node);\r\n        if (this.table) {\r\n            let currentTd = node instanceof HTMLTableElement ? null : node;\r\n            let trs = <HTMLTableRowElement[]>[].slice.call(this.table.rows);\r\n            this.cells = trs.map(row => []);\r\n            trs.forEach((tr, rowIndex) => {\r\n                this.trs[rowIndex % 2] = tr;\r\n                for (let sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {\r\n                    // Skip the cells which already initialized\r\n                    for (; this.cells[rowIndex][targetCol]; targetCol++) {}\r\n\r\n                    let td = tr.cells[sourceCol];\r\n                    if (td == currentTd) {\r\n                        this.col = targetCol;\r\n                        this.row = rowIndex;\r\n                    }\r\n\r\n                    for (let colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {\r\n                        for (let rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {\r\n                            this.cells[rowIndex + rowSpan][targetCol] = {\r\n                                td: colSpan + rowSpan == 0 ? td : null,\r\n                                spanLeft: colSpan > 0,\r\n                                spanAbove: rowSpan > 0,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write the virtual table back to DOM tree to represent the change of VTable\r\n     */\r\n    writeBack() {\r\n        if (this.cells) {\r\n            moveChildren(this.table);\r\n            this.cells.forEach((row, r) => {\r\n                let tr = cloneNode(this.trs[r % 2] || this.trs[0]);\r\n                this.table.appendChild(tr);\r\n                row.forEach((cell, c) => {\r\n                    if (cell.td) {\r\n                        this.recalcSpans(r, c);\r\n                        tr.appendChild(cell.td);\r\n                    }\r\n                });\r\n            });\r\n        } else if (this.table) {\r\n            this.table.parentNode.removeChild(this.table);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the given table format to this virtual table\r\n     * @param format Table format to apply\r\n     */\r\n    applyFormat(format: Partial<TableFormat>) {\r\n        if (!format || !this.table) {\r\n            return;\r\n        }\r\n        this.table.style.borderCollapse = 'collapse';\r\n        this.trs[0].style.backgroundColor = format.bgColorOdd || 'transparent';\r\n        if (this.trs[1]) {\r\n            this.trs[1].style.backgroundColor = format.bgColorEven || 'transparent';\r\n        }\r\n        this.cells.forEach(row =>\r\n            row\r\n                .filter(cell => cell.td)\r\n                .forEach(cell => {\r\n                    cell.td.style.borderTop = getBorderStyle(format.topBorderColor);\r\n                    cell.td.style.borderBottom = getBorderStyle(format.bottomBorderColor);\r\n                    cell.td.style.borderLeft = getBorderStyle(format.verticalBorderColor);\r\n                    cell.td.style.borderRight = getBorderStyle(format.verticalBorderColor);\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Edit table with given operation.\r\n     * @param operation Table operation\r\n     */\r\n    edit(operation: TableOperation) {\r\n        if (!this.table) {\r\n            return;\r\n        }\r\n\r\n        let currentRow = this.cells[this.row];\r\n        let currentCell = currentRow[this.col];\r\n        switch (operation) {\r\n            case TableOperation.InsertAbove:\r\n                this.cells.splice(this.row, 0, currentRow.map(cloneCell));\r\n                break;\r\n            case TableOperation.InsertBelow:\r\n                let newRow = this.row + this.countSpanAbove(this.row, this.col);\r\n                this.cells.splice(\r\n                    newRow,\r\n                    0,\r\n                    this.cells[newRow - 1].map((cell, colIndex) => {\r\n                        let nextCell = this.getCell(newRow, colIndex);\r\n                        if (nextCell.spanAbove) {\r\n                            return cloneCell(nextCell);\r\n                        } else if (cell.spanLeft) {\r\n                            let newCell = cloneCell(cell);\r\n                            newCell.spanAbove = false;\r\n                            return newCell;\r\n                        } else {\r\n                            return {\r\n                                td: cloneNode(this.getTd(this.row, colIndex)),\r\n                            };\r\n                        }\r\n                    })\r\n                );\r\n                break;\r\n\r\n            case TableOperation.InsertLeft:\r\n                this.forEachCellOfCurrentColumn((cell, row) => {\r\n                    row.splice(this.col, 0, cloneCell(cell));\r\n                });\r\n                break;\r\n            case TableOperation.InsertRight:\r\n                let newCol = this.col + this.countSpanLeft(this.row, this.col);\r\n                this.forEachCellOfColumn(newCol - 1, (cell, row, i) => {\r\n                    let nextCell = this.getCell(i, newCol);\r\n                    let newCell: VCell;\r\n                    if (nextCell.spanLeft) {\r\n                        newCell = cloneCell(nextCell);\r\n                    } else if (cell.spanAbove) {\r\n                        newCell = cloneCell(cell);\r\n                        newCell.spanLeft = false;\r\n                    } else {\r\n                        newCell = {\r\n                            td: cloneNode(this.getTd(i, this.col)),\r\n                        };\r\n                    }\r\n\r\n                    row.splice(newCol, 0, newCell);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.DeleteRow:\r\n                this.forEachCellOfCurrentRow((cell, i) => {\r\n                    let nextCell = this.getCell(this.row + 1, i);\r\n                    if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                });\r\n                this.cells.splice(this.row, 1);\r\n                break;\r\n\r\n            case TableOperation.DeleteColumn:\r\n                this.forEachCellOfCurrentColumn((cell, row, i) => {\r\n                    let nextCell = this.getCell(i, this.col + 1);\r\n                    if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                    row.splice(this.col, 1);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.MergeAbove:\r\n            case TableOperation.MergeBelow:\r\n                let rowStep = operation == TableOperation.MergeAbove ? -1 : 1;\r\n                for (\r\n                    let rowIndex = this.row + rowStep;\r\n                    rowIndex >= 0 && rowIndex < this.cells.length;\r\n                    rowIndex += rowStep\r\n                ) {\r\n                    let cell = this.getCell(rowIndex, this.col);\r\n                    if (cell.td && !cell.spanAbove) {\r\n                        let aboveCell = rowIndex < this.row ? cell : currentCell;\r\n                        let belowCell = rowIndex < this.row ? currentCell : cell;\r\n                        if (aboveCell.td.colSpan == belowCell.td.colSpan) {\r\n                            moveChildren(belowCell.td, aboveCell.td);\r\n                            belowCell.td = null;\r\n                            belowCell.spanAbove = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.MergeLeft:\r\n            case TableOperation.MergeRight:\r\n                let colStep = operation == TableOperation.MergeLeft ? -1 : 1;\r\n                for (\r\n                    let colIndex = this.col + colStep;\r\n                    colIndex >= 0 && colIndex < this.cells[this.row].length;\r\n                    colIndex += colStep\r\n                ) {\r\n                    let cell = this.getCell(this.row, colIndex);\r\n                    if (cell.td && !cell.spanLeft) {\r\n                        let leftCell = colIndex < this.col ? cell : currentCell;\r\n                        let rightCell = colIndex < this.col ? currentCell : cell;\r\n                        if (leftCell.td.rowSpan == rightCell.td.rowSpan) {\r\n                            moveChildren(rightCell.td, leftCell.td);\r\n                            rightCell.td = null;\r\n                            rightCell.spanLeft = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.DeleteTable:\r\n                this.cells = null;\r\n                break;\r\n\r\n            case TableOperation.SplitVertically:\r\n                if (currentCell.td.rowSpan > 1) {\r\n                    this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    let splitRow = currentRow.map(cell => {\r\n                        return {\r\n                            td: cell == currentCell ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell != currentCell,\r\n                            spanLeft: cell.spanLeft,\r\n                        };\r\n                    });\r\n                    this.cells.splice(this.row + 1, 0, splitRow);\r\n                }\r\n                break;\r\n\r\n            case TableOperation.SplitHorizontally:\r\n                if (currentCell.td.colSpan > 1) {\r\n                    this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    this.forEachCellOfCurrentColumn((cell, row) => {\r\n                        row.splice(this.col + 1, 0, {\r\n                            td: row == currentRow ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell.spanAbove,\r\n                            spanLeft: row != currentRow,\r\n                        });\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current column and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => any) {\r\n        this.forEachCellOfColumn(this.col, callback);\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current row and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => any) {\r\n        this.forEachCellOfRow(this.row, callback);\r\n    }\r\n\r\n    /**\r\n     * Get a table cell using its row and column index. This function will always return an object\r\n     * even if the given indexes don't exist in table.\r\n     * @param row The row index\r\n     * @param col The column index\r\n     */\r\n    getCell(row: number, col: number): VCell {\r\n        return (this.cells && this.cells[row] && this.cells[row][col]) || {};\r\n    }\r\n\r\n    /**\r\n     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell\r\n     */\r\n    getCurrentTd(): HTMLTableCellElement {\r\n        return this.getTd(this.row, this.col);\r\n    }\r\n\r\n    private getTd(row: number, col: number) {\r\n        if (this.cells) {\r\n            row = Math.min(this.cells.length - 1, row);\r\n            col = Math.min(this.cells[row].length - 1, col);\r\n            while (row >= 0 && col >= 0) {\r\n                let cell = this.getCell(row, col);\r\n                if (cell.td) {\r\n                    return cell.td;\r\n                } else if (cell.spanLeft) {\r\n                    col--;\r\n                } else if (cell.spanAbove) {\r\n                    row--;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private forEachCellOfColumn(\r\n        col: number,\r\n        callback: (cell: VCell, row: VCell[], i: number) => any\r\n    ) {\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            callback(this.getCell(i, col), this.cells[i], i);\r\n        }\r\n    }\r\n\r\n    private forEachCellOfRow(row: number, callback: (cell: VCell, i: number) => any) {\r\n        for (let i = 0; i < this.cells[row].length; i++) {\r\n            callback(this.getCell(row, i), i);\r\n        }\r\n    }\r\n\r\n    private recalcSpans(row: number, col: number) {\r\n        let td = this.getCell(row, col).td;\r\n        if (td) {\r\n            td.colSpan = this.countSpanLeft(row, col);\r\n            td.rowSpan = this.countSpanAbove(row, col);\r\n            if (td.colSpan == 1) {\r\n                td.removeAttribute('colSpan');\r\n            }\r\n            if (td.rowSpan == 1) {\r\n                td.removeAttribute('rowSpan');\r\n            }\r\n        }\r\n    }\r\n\r\n    private countSpanLeft(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = col + 1; i < this.cells[row].length; i++) {\r\n            let cell = this.getCell(row, i);\r\n            if (cell.td || !cell.spanLeft) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private countSpanAbove(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = row + 1; i < this.cells.length; i++) {\r\n            let cell = this.getCell(i, col);\r\n            if (cell.td || !cell.spanAbove) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nfunction getTableFromTd(td: HTMLTableCellElement) {\r\n    let result = <HTMLElement>td;\r\n    for (; result && result.tagName != 'TABLE'; result = result.parentElement) {}\r\n    return <HTMLTableElement>result;\r\n}\r\n\r\nfunction getBorderStyle(style: string): string {\r\n    return 'solid 1px ' + (style || 'transparent');\r\n}\r\n\r\n/**\r\n * Clone a table cell\r\n * @param cell The cell to clone\r\n */\r\nfunction cloneCell(cell: VCell): VCell {\r\n    return {\r\n        td: cloneNode(cell.td),\r\n        spanAbove: cell.spanAbove,\r\n        spanLeft: cell.spanLeft,\r\n    };\r\n}\r\n\r\n/**\r\n * Clone a node without its children.\r\n * @param node The node to clone\r\n */\r\nfunction cloneNode<T extends Node>(node: T): T {\r\n    let newNode = node ? <T>node.cloneNode(false /*deep*/) : null;\r\n    if (newNode && newNode instanceof HTMLTableCellElement) {\r\n        newNode.removeAttribute('id');\r\n        if (!newNode.firstChild) {\r\n            newNode.appendChild(node.ownerDocument.createElement('br'));\r\n        }\r\n    }\r\n    return newNode;\r\n}\r\n\r\n/**\r\n * Move all children from one node to another\r\n * @param fromNode The source node to move children from\r\n * @param toNode Target node. If not passed, children nodes of source node will be removed\r\n */\r\nfunction moveChildren(fromNode: Node, toNode?: Node) {\r\n    while (fromNode.firstChild) {\r\n        if (toNode) {\r\n            toNode.appendChild(fromNode.firstChild);\r\n        } else {\r\n            fromNode.removeChild(fromNode.firstChild);\r\n        }\r\n    }\r\n}\r\n","import createRange from './createRange';\r\nimport { NodePosition, NodeType, Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get bounding rect of this position\r\n * @param position The positioin to get rect from\r\n */\r\nexport default function getPositionRect(position: NodePosition): Rect {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n\r\n    let range = createRange(position);\r\n\r\n    // 1) try to get rect using range.getBoundingClientRect()\r\n    let rect = range.getBoundingClientRect && normalizeRect(range.getBoundingClientRect());\r\n\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 2) try to get rect using range.getClientRects\r\n    position = position.normalize();\r\n    const rects = range.getClientRects && range.getClientRects();\r\n    rect = rects && rects.length == 1 && normalizeRect(rects[0]);\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 3) if node is text node, try inserting a SPAN and get the rect of SPAN for others\r\n    if (position.node.nodeType == NodeType.Text) {\r\n        let span = document.createElement('SPAN');\r\n        span.innerHTML = '\\u200b';\r\n        range = createRange(position);\r\n        range.insertNode(span);\r\n        rect = span.getBoundingClientRect && normalizeRect(span.getBoundingClientRect());\r\n        span.parentNode.removeChild(span);\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    // 4) try getBoundingClientRect on element\r\n    let element = position.element;\r\n    if (element && element.getBoundingClientRect) {\r\n        rect = normalizeRect(element.getBoundingClientRect());\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction normalizeRect(clientRect: ClientRect): Rect {\r\n    // A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p\r\n    // We validate that and only return a rect when the passed in ClientRect is valid\r\n    let { left, right, top, bottom } = clientRect || <ClientRect>{};\r\n    return left + right + top + bottom > 0\r\n        ? {\r\n              left: Math.round(left),\r\n              right: Math.round(right),\r\n              top: Math.round(top),\r\n              bottom: Math.round(bottom),\r\n          }\r\n        : null;\r\n}\r\n","import contains from '../utils/contains';\r\nimport isNodeEmpty from '../utils/isNodeEmpty';\r\nimport { NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check if this position is at beginning of the given node.\r\n * This will return true if all nodes between the beginning of target node and the position are empty.\r\n * @param position The position to check\r\n * @param targetNode The node to check\r\n * @returns True if position is at beginning of the node, otherwise false\r\n */\r\nexport default function isPositionAtBeginningOf(position: NodePosition, targetNode: Node) {\r\n    if (position) {\r\n        let { node, offset } = position.normalize();\r\n        if (offset == 0) {\r\n            while (contains(targetNode, node) && areAllPrevousNodesEmpty(node)) {\r\n                node = node.parentNode;\r\n            }\r\n\r\n            return node == targetNode;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction areAllPrevousNodesEmpty(node: Node): boolean {\r\n    while (node.previousSibling) {\r\n        node = node.previousSibling;\r\n        if (!isNodeEmpty(node)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n","import contains from '../utils/contains';\r\nimport createRange from './createRange';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get path of the given selection range related to the given rootNode\r\n * @param rootNode The root node where the path start from\r\n * @param range The range of selection\r\n */\r\nexport default function getSelectionPath(rootNode: HTMLElement, range: Range): SelectionPath {\r\n    if (!range) {\r\n        return null;\r\n    }\r\n\r\n    let selectionPath: SelectionPath = {\r\n        start: getPositionPath(Position.getStart(range), rootNode),\r\n        end: getPositionPath(Position.getEnd(range), rootNode),\r\n    };\r\n\r\n    return selectionPath;\r\n}\r\n\r\n/**\r\n * Get range from the given selection path\r\n * @param rootNode Root node of the selection path\r\n * @param path The selection path which contains start and end position path\r\n */\r\nexport function getRangeFromSelectionPath(rootNode: HTMLElement, path: SelectionPath) {\r\n    let start = getPositionFromPath(rootNode, path.start);\r\n    let end = getPositionFromPath(rootNode, path.end);\r\n    return createRange(start, end);\r\n}\r\n\r\nfunction getPositionFromPath(node: Node, path: number[]): NodePosition {\r\n    if (!node || !path) {\r\n        return null;\r\n    }\r\n\r\n    // Iterate with a for loop to avoid mutating the passed in element path stack\r\n    // or needing to copy it.\r\n    let offset: number;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        offset = path[i];\r\n        if (\r\n            i < path.length - 1 &&\r\n            node &&\r\n            node.nodeType == NodeType.Element &&\r\n            node.childNodes.length > offset\r\n        ) {\r\n            node = node.childNodes[offset];\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return new Position(node, offset);\r\n}\r\n\r\n/**\r\n * Get the path of the node relative to rootNode.\r\n * The path of the node is an array of integer indecies into the childNodes of the given node.\r\n *\r\n * The node path will be what the node path will be on a _normalized_ dom\r\n * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)\r\n *\r\n * @param rootNode the node the path will be relative to\r\n * @param position the position to get indexes from. Follows the same semantics\r\n * as selectionRange (if node is of type Text, it is an offset into the text of that node.\r\n * If node is of type Element, it is the index of a child in that Element node.)\r\n */\r\nfunction getPositionPath(position: NodePosition, rootNode: HTMLElement): number[] {\r\n    if (!position || !rootNode) {\r\n        return [];\r\n    }\r\n\r\n    let { node, offset } = position;\r\n    let result: number[] = [];\r\n    let parent: Node;\r\n\r\n    if (!contains(rootNode, node, true)) {\r\n        return [];\r\n    }\r\n\r\n    if (node.nodeType == NodeType.Text) {\r\n        parent = node.parentNode;\r\n        while (node.previousSibling && node.previousSibling.nodeType == NodeType.Text) {\r\n            offset += node.previousSibling.nodeValue.length;\r\n            node = node.previousSibling;\r\n        }\r\n        result.unshift(offset);\r\n    } else {\r\n        parent = node;\r\n        node = node.childNodes[offset];\r\n    }\r\n\r\n    do {\r\n        offset = 0;\r\n        let isPreviousText = false;\r\n\r\n        for (let c: Node = parent.firstChild; c && c != node; c = c.nextSibling) {\r\n            if (c.nodeType == NodeType.Text) {\r\n                if (c.nodeValue.length == 0 || isPreviousText) {\r\n                    continue;\r\n                }\r\n\r\n                isPreviousText = true;\r\n            } else {\r\n                isPreviousText = false;\r\n            }\r\n\r\n            offset++;\r\n        }\r\n\r\n        result.unshift(offset);\r\n        node = parent;\r\n        parent = parent.parentNode;\r\n    } while (node && node != rootNode);\r\n\r\n    return result;\r\n}\r\n","import ContentEditFeatures, { getDefaultContentEditFeatures } from './ContentEditFeatures';\r\nimport { AutoLink, UnlinkWhenBackspaceAfterLink } from './features/autoLinkFeatures';\r\nimport { DefaultShortcut } from './features/shortcutFeatures';\r\nimport { Editor, EditorPlugin, GenericContentEditFeature } from 'roosterjs-editor-core';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\nimport { TabInTable, UpDownInTable } from './features/tableFeatures';\r\n\r\nimport {\r\n    AutoBullet,\r\n    IndentWhenTab,\r\n    OutdentWhenShiftTab,\r\n    MergeInNewLine,\r\n    OutdentWhenBackOn1stEmptyLine,\r\n    OutdentWhenEnterOnEmptyLine,\r\n    getSmartOrderedList,\r\n} from './features/listFeatures';\r\nimport {\r\n    UnquoteWhenBackOnEmpty1stLine,\r\n    UnquoteWhenEnterOnEmptyLine,\r\n} from './features/quoteFeatures';\r\n\r\n/**\r\n * An editor plugin to handle content edit event.\r\n * The following cases are included:\r\n * 1. Auto increase/decrease indentation on Tab, Shift+tab\r\n * 2. Enter, Backspace on empty list item\r\n * 3. Enter, Backspace on empty blockquote line\r\n * 4. Auto bullet/numbering\r\n * 5. Auto link\r\n * 6. Tab in table\r\n * 7. Up/Down in table\r\n * 8. Manage list style\r\n */\r\nexport default class ContentEdit implements EditorPlugin {\r\n    private editor: Editor;\r\n\r\n    /**\r\n     * Create instance of ContentEdit plugin\r\n     * @param features An optional feature set to determine which features the plugin should provide\r\n     */\r\n    constructor(private featureSet?: ContentEditFeatures) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'ContentEdit';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    public initialize(editor: Editor): void {\r\n        this.editor = editor;\r\n        this.getFilteredFeatures().forEach(feature => this.editor.addContentEditFeature(feature));\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose(): void {\r\n        this.editor = null;\r\n    }\r\n\r\n    private getFilteredFeatures(): GenericContentEditFeature<PluginEvent>[] {\r\n        let featureSet = this.featureSet || getDefaultContentEditFeatures();\r\n        let allFeatures: {\r\n            [key in keyof Partial<ContentEditFeatures>]: GenericContentEditFeature<PluginEvent>\r\n        } = {\r\n            indentWhenTab: IndentWhenTab,\r\n            outdentWhenShiftTab: OutdentWhenShiftTab,\r\n            outdentWhenBackspaceOnEmptyFirstLine: OutdentWhenBackOn1stEmptyLine,\r\n            outdentWhenEnterOnEmptyLine: OutdentWhenEnterOnEmptyLine,\r\n            mergeInNewLineWhenBackspaceOnFirstChar: MergeInNewLine,\r\n            unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,\r\n            unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,\r\n            tabInTable: TabInTable,\r\n            upDownInTable: UpDownInTable,\r\n            autoBullet: AutoBullet,\r\n            autoLink: AutoLink,\r\n            unlinkWhenBackspaceAfterLink: UnlinkWhenBackspaceAfterLink,\r\n            defaultShortcut: DefaultShortcut,\r\n            smartOrderedList: getSmartOrderedList(featureSet.smartOrderedListStyles),\r\n        };\r\n        let keys = Object.keys(allFeatures) as (keyof ContentEditFeatures)[];\r\n        return keys.filter(key => featureSet[key]).map(key => allFeatures[key]);\r\n    }\r\n}\r\n","import { Browser, LinkInlineElement, matchLink } from 'roosterjs-editor-dom';\r\nimport { removeLink, replaceWithNode } from 'roosterjs-editor-api';\r\nimport {\r\n    ChangeSource,\r\n    LinkData,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginKeyboardEvent,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    Editor,\r\n    cacheGetEventData,\r\n    cacheGetContentSearcher,\r\n    clearContentSearcherCache,\r\n    GenericContentEditFeature,\r\n    Keys,\r\n} from 'roosterjs-editor-core';\r\n\r\n// When user type, they may end a link with a puncatuation, i.e. www.bing.com;\r\n// we need to trim off the trailing puncatuation before turning it to link match\r\nconst TRAILING_PUNCTUATION_REGEX = /[.+=\\s:;\"',>]+$/i;\r\nconst MINIMUM_LENGTH = 5;\r\n\r\nexport const AutoLink: GenericContentEditFeature<PluginEvent> = {\r\n    keys: [Keys.ENTER, Keys.SPACE, Keys.CONTENTCHANGED],\r\n    initialize: editor =>\r\n        Browser.isIE &&\r\n        editor.getDocument().execCommand('AutoUrlDetect', false, <string>(<any>false)),\r\n    shouldHandleEvent: cacheGetLinkData,\r\n    handleEvent: autoLink,\r\n};\r\n\r\nexport const UnlinkWhenBackspaceAfterLink: GenericContentEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: hasLinkBeforeCursor,\r\n    handleEvent: (event, editor) => {\r\n        event.rawEvent.preventDefault();\r\n        removeLink(editor);\r\n    },\r\n};\r\n\r\nfunction cacheGetLinkData(event: PluginEvent, editor: Editor): LinkData {\r\n    return event.eventType == PluginEventType.KeyDown ||\r\n        (event.eventType == PluginEventType.ContentChanged && event.source == ChangeSource.Paste)\r\n        ? cacheGetEventData(event, 'LINK_DATA', () => {\r\n              let searcher = cacheGetContentSearcher(event, editor);\r\n              let word = searcher && searcher.getWordBefore();\r\n              if (word && word.length > MINIMUM_LENGTH) {\r\n                  // Check for trailing punctuation\r\n                  let trailingPunctuations = word.match(TRAILING_PUNCTUATION_REGEX);\r\n                  let trailingPunctuation = (trailingPunctuations || [])[0] || '';\r\n                  let candidate = word.substring(0, word.length - trailingPunctuation.length);\r\n\r\n                  // Do special handling for ')', '}', ']'\r\n                  ['()', '{}', '[]'].forEach(str => {\r\n                      if (\r\n                          candidate[candidate.length - 1] == str[1] &&\r\n                          candidate.indexOf(str[0]) < 0\r\n                      ) {\r\n                          candidate = candidate.substr(0, candidate.length - 1);\r\n                      }\r\n                  });\r\n\r\n                  // Match and replace in editor\r\n                  return matchLink(candidate);\r\n              }\r\n              return null;\r\n          })\r\n        : null;\r\n}\r\n\r\nfunction hasLinkBeforeCursor(event: PluginKeyboardEvent, editor: Editor): boolean {\r\n    let contentSearcher = cacheGetContentSearcher(event, editor);\r\n    let inline = contentSearcher.getInlineElementBefore();\r\n    return inline instanceof LinkInlineElement;\r\n}\r\n\r\nfunction autoLink(event: PluginEvent, editor: Editor) {\r\n    let searcher = cacheGetContentSearcher(event, editor);\r\n    let anchor = editor.getDocument().createElement('a');\r\n    let linkData = cacheGetLinkData(event, editor);\r\n    anchor.textContent = linkData.originalUrl;\r\n    anchor.href = linkData.normalizedUrl;\r\n\r\n    editor.runAsync(() => {\r\n        editor.performAutoComplete(() => {\r\n            replaceWithNode(editor, linkData.originalUrl, anchor, false /* exactMatch */, searcher);\r\n\r\n            // The content at cursor has changed. Should also clear the cursor data cache\r\n            clearContentSearcherCache(event);\r\n            return anchor;\r\n        }, ChangeSource.AutoLink);\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FontSizeChange } from 'roosterjs-editor-types';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,\r\n * So that when increase/decrease font size, the font size can match the sequence of your font size picker\r\n */\r\nexport const FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];\r\nconst MIN_FONT_SIZE = 1;\r\nconst MAX_FONT_SIZE = 1000;\r\n\r\n/**\r\n * Increase or decrease font size in selection\r\n * @param editor The editor instance\r\n * @param change Whether increase or decrease font size\r\n * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES\r\n */\r\nexport default function changeFontSize(\r\n    editor: Editor,\r\n    change: FontSizeChange,\r\n    fontSizes: number[] = FONT_SIZES\r\n) {\r\n    let changeBase: 1 | -1 = change == FontSizeChange.Increase ? 1 : -1;\r\n    applyInlineStyle(editor, element => {\r\n        let pt = parseFloat(getComputedStyle(element, 'font-size'));\r\n        element.style.fontSize = getNewFontSize(pt, changeBase, fontSizes) + 'pt';\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n\r\nexport function getNewFontSize(pt: number, changeBase: 1 | -1, fontSizes: number[]): number {\r\n    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n    let last = fontSizes[fontSizes.length - 1];\r\n    if (pt <= fontSizes[0]) {\r\n        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);\r\n    } else if (pt > last || (pt == last && changeBase == 1)) {\r\n        pt = pt / 10;\r\n        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);\r\n    } else if (changeBase == 1) {\r\n        for (let i = 0; i < fontSizes.length; i++) {\r\n            if (pt < fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = fontSizes.length - 1; i >= 0; i--) {\r\n            if (pt > fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return pt;\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, NodeType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    getTagOfNode,\r\n    isBlockElement,\r\n    unwrap,\r\n    wrap,\r\n    splitBalancedNodeRange,\r\n} from 'roosterjs-editor-dom';\r\n\r\nexport const TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(\r\n    ','\r\n);\r\nexport const TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];\r\nexport const ATTRIBUTES_TO_PRESERVE = ['href'];\r\n\r\n/**\r\n * Clear all formats of selected blocks.\r\n * When selection is collapsed, only clear format of current block.\r\n * @param editor The editor instance\r\n * @param tagsToUnwrap Optional. A string array contains HTML tags in upper case which we will unwrap when clear format\r\n * @param tagsToStopUnwrap Optional. A string array contains HTML tags in upper case which we will stop unwrap if these tags are hit\r\n */\r\nexport default function clearBlockFormat(\r\n    editor: Editor,\r\n    tagsToUnwrap: string[] = TAGS_TO_UNWRAP,\r\n    tagsToStopUnwrap: string[] = TAGS_TO_STOP_UNWRAP,\r\n    attributesToPreserve: string[] = ATTRIBUTES_TO_PRESERVE\r\n) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        let groups: {\r\n            first?: HTMLElement;\r\n            last?: HTMLElement;\r\n            td?: HTMLElement;\r\n        }[] = [{}];\r\n        let stopUnwrapSelector = tagsToStopUnwrap.join(',');\r\n\r\n        // 1. Collapse the selected blocks and get first and last element\r\n        collapseSelectedBlocks(editor, element => {\r\n            let group = groups[groups.length - 1];\r\n            let td = editor.getElementAtCursor(stopUnwrapSelector, element);\r\n            if (td != group.td && group.first) {\r\n                groups.push((group = {}));\r\n            }\r\n\r\n            group.td = td;\r\n            group.first = group.first || element;\r\n            group.last = element;\r\n        });\r\n\r\n        groups\r\n            .filter(group => group.first)\r\n            .forEach(group => {\r\n                // 2. Collapse with first and last element to make them under same parent\r\n                let nodes = editor.collapseNodes(group.first, group.last, true /*canSplitParent*/);\r\n\r\n                // 3. Continue collapse until we can't collapse any more (hit root node, or a table)\r\n                if (canCollapse(tagsToStopUnwrap, nodes[0])) {\r\n                    while (\r\n                        editor.contains(nodes[0].parentNode) &&\r\n                        canCollapse(tagsToStopUnwrap, nodes[0].parentNode as HTMLElement)\r\n                    ) {\r\n                        nodes = [splitBalancedNodeRange(nodes)];\r\n                    }\r\n                }\r\n\r\n                // 4. Clear formats of the nodes\r\n                nodes.forEach(node =>\r\n                    clearNodeFormat(\r\n                        node as HTMLElement,\r\n                        tagsToUnwrap,\r\n                        tagsToStopUnwrap,\r\n                        attributesToPreserve\r\n                    )\r\n                );\r\n\r\n                // 5. Clear CSS of container TD if exist\r\n                if (group.td) {\r\n                    let styles = group.td.getAttribute('style') || '';\r\n                    let styleArray = styles.split(';');\r\n                    styleArray = styleArray.filter(\r\n                        style =>\r\n                            style\r\n                                .trim()\r\n                                .toLowerCase()\r\n                                .indexOf('border') == 0\r\n                    );\r\n                    styles = styleArray.join(';');\r\n                    if (styles) {\r\n                        group.td.setAttribute('style', styles);\r\n                    } else {\r\n                        group.td.removeAttribute('style');\r\n                    }\r\n                }\r\n            });\r\n\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction clearNodeFormat(\r\n    node: Node,\r\n    tagsToUnwrap: string[],\r\n    tagsToStopUnwrap: string[],\r\n    attributesToPreserve: string[]\r\n): boolean {\r\n    if (node.nodeType != NodeType.Element || getTagOfNode(node) == 'BR') {\r\n        return false;\r\n    }\r\n\r\n    // 1. Recursively clear format of all its child nodes\r\n    let allChildrenAreBlock = ([].slice.call(node.childNodes) as Node[])\r\n        .map(n => clearNodeFormat(n, tagsToUnwrap, tagsToStopUnwrap, attributesToPreserve))\r\n        .reduce((previousValue, value) => previousValue && value, true);\r\n\r\n    if (!canCollapse(tagsToStopUnwrap, node)) {\r\n        return false;\r\n    }\r\n\r\n    let returnBlockElement = isBlockElement(node);\r\n\r\n    // 2. If we should unwrap this tag, put it into an array and unwrap it later\r\n    if (tagsToUnwrap.indexOf(getTagOfNode(node)) >= 0 || allChildrenAreBlock) {\r\n        if (returnBlockElement && !allChildrenAreBlock) {\r\n            wrap(node);\r\n        }\r\n        unwrap(node);\r\n    } else {\r\n        // 3. Otherwise, remove all attributes\r\n        clearAttribute(node as HTMLElement, attributesToPreserve);\r\n    }\r\n\r\n    return returnBlockElement;\r\n}\r\n\r\nfunction clearAttribute(element: HTMLElement, attributesToPreserve: string[]) {\r\n    for (let attr of [].slice.call(element.attributes) as Attr[]) {\r\n        if (attributesToPreserve.indexOf(attr.name.toLowerCase()) < 0) {\r\n            element.removeAttribute(attr.name);\r\n        }\r\n    }\r\n}\r\n\r\nfunction canCollapse(tagsToStopUnwrap: string[], node: Node) {\r\n    return tagsToStopUnwrap.indexOf(getTagOfNode(node)) < 0;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport setBackgroundColor from './setBackgroundColor';\r\nimport setFontName from './setFontName';\r\nimport setFontSize from './setFontSize';\r\nimport setTextColor from './setTextColor';\r\nimport toggleBold from './toggleBold';\r\nimport toggleItalic from './toggleItalic';\r\nimport toggleUnderline from './toggleUnderline';\r\nimport { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\nconst STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];\r\n\r\n/**\r\n * Clear the format in current selection, after cleaning, the format will be\r\n * changed to default format. The format that get cleaned include B/I/U/font name/\r\n * font size/text color/background color/align left/align right/align center/superscript/subscript\r\n * @param editor The editor instance\r\n */\r\nexport default function clearFormat(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, DocumentCommand.RemoveFormat);\r\n\r\n        editor.queryElements('[class]', QueryScope.OnSelection, node =>\r\n            node.removeAttribute('class')\r\n        );\r\n\r\n        const defaultFormat = editor.getDefaultFormat();\r\n        const isDefaultFormatEmpty = Object.keys(defaultFormat).length === 0;\r\n        editor.queryElements('[style]', QueryScope.InSelection, node => {\r\n            STYLES_TO_REMOVE.forEach(style => node.style.removeProperty(style));\r\n\r\n            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style\r\n            // (note: because default format is empty, we're not adding style back in)\r\n            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {\r\n                node.removeAttribute('style');\r\n            }\r\n        });\r\n\r\n        if (!isDefaultFormatEmpty) {\r\n            if (defaultFormat.fontFamily) {\r\n                setFontName(editor, defaultFormat.fontFamily);\r\n            }\r\n            if (defaultFormat.fontSize) {\r\n                setFontSize(editor, defaultFormat.fontSize);\r\n            }\r\n            if (defaultFormat.textColor) {\r\n                setTextColor(editor, defaultFormat.textColor);\r\n            }\r\n            if (defaultFormat.backgroundColor) {\r\n                setBackgroundColor(editor, defaultFormat.backgroundColor);\r\n            }\r\n            if (defaultFormat.bold) {\r\n                toggleBold(editor);\r\n            }\r\n            if (defaultFormat.italic) {\r\n                toggleItalic(editor);\r\n            }\r\n            if (defaultFormat.underline) {\r\n                toggleUnderline(editor);\r\n            }\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { matchLink } from 'roosterjs-editor-dom';\r\n\r\n// Regex matching Uri scheme\r\nconst URI_REGEX = /^[a-zA-Z]+:/i;\r\n// Regex matching begin of email address\r\nconst MAILTO_REGEX = /^[\\w.%+-]+@/i;\r\n// Regex matching begin of ftp, i.e. ftp.microsoft.com\r\nconst FTP_REGEX = /^ftp\\./i;\r\nconst TEMP_TITLE = 'istemptitle';\r\n\r\nfunction applyLinkPrefix(url: string): string {\r\n    if (!url) {\r\n        return url;\r\n    }\r\n\r\n    // Add link prefix per rule:\r\n    // (a) if the url always starts with a URI scheme, leave it as it is\r\n    // (b) if the url is an email address, xxx@... add mailto: prefix\r\n    // (c) if the url starts with ftp., add ftp:// prefix\r\n    // (d) rest, add http:// prefix\r\n    let prefix = '';\r\n    if (url.search(URI_REGEX) < 0) {\r\n        if (url.search(MAILTO_REGEX) == 0) {\r\n            prefix = 'mailto:';\r\n        } else if (url.search(FTP_REGEX) == 0) {\r\n            prefix = 'ftp://';\r\n        } else {\r\n            // fallback to http://\r\n            prefix = 'http://';\r\n        }\r\n    }\r\n\r\n    return prefix + url;\r\n}\r\n\r\n/**\r\n * Insert a hyperlink at cursor.\r\n * When there is a selection, hyperlink will be applied to the selection,\r\n * otherwise a hyperlink will be inserted to the cursor position.\r\n * @param editor Editor object\r\n * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.\r\n * When protocol is not specified, a best matched protocol will be predicted.\r\n * @param altText Optional alt text of the link, will be shown when hover on the link\r\n * @param displayText Optional display text for the link.\r\n * If specified, the display text of link will be replaced with this text.\r\n * If not specified and there wasn't a link, the link url will be used as display text.\r\n */\r\nexport default function createLink(\r\n    editor: Editor,\r\n    link: string,\r\n    altText?: string,\r\n    displayText?: string\r\n) {\r\n    editor.focus();\r\n    let url = link ? link.trim() : '';\r\n    if (url) {\r\n        let linkData = matchLink(url);\r\n        // matchLink can match most links, but not all, i.e. if you pass link a link as \"abc\", it won't match\r\n        // we know in that case, users will want to insert a link like http://abc\r\n        // so we have separate logic in applyLinkPrefix to add link prefix depending on the format of the link\r\n        // i.e. if the link starts with something like abc@xxx, we will add mailto: prefix\r\n        // if the link starts with ftp.xxx, we will add ftp:// link. For more, see applyLinkPrefix\r\n        let normalizedUrl = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);\r\n        let originalUrl = linkData ? linkData.originalUrl : url;\r\n\r\n        editor.addUndoSnapshot(() => {\r\n            let range = editor.getSelectionRange();\r\n            let anchor: HTMLAnchorElement = null;\r\n            if (range && range.collapsed) {\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n\r\n                // If there is already a link, just change its href\r\n                if (anchor) {\r\n                    anchor.href = normalizedUrl;\r\n                    // Change text content if it is specified\r\n                    updateAnchorDisplayText(anchor, displayText);\r\n                } else {\r\n                    anchor = editor.getDocument().createElement('A') as HTMLAnchorElement;\r\n                    anchor.textContent = displayText || originalUrl;\r\n                    anchor.href = normalizedUrl;\r\n                    editor.insertNode(anchor);\r\n                }\r\n            } else {\r\n                // the selection is not collapsed, use browser execCommand\r\n                editor.getDocument().execCommand(DocumentCommand.CreateLink, false, normalizedUrl);\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n                updateAnchorDisplayText(anchor, displayText);\r\n            }\r\n            if (altText && anchor) {\r\n                // Hack: Ideally this should be done by HyperLink plugin.\r\n                // We make a hack here since we don't have an event to notify HyperLink plugin\r\n                // before we apply the link.\r\n                anchor.removeAttribute(TEMP_TITLE);\r\n                anchor.title = altText;\r\n            }\r\n            return anchor;\r\n        }, ChangeSource.CreateLink);\r\n    }\r\n}\r\n\r\nfunction getAnchorNodeAtCursor(editor: Editor): HTMLAnchorElement {\r\n    return editor.queryElements('a[href]', QueryScope.OnSelection)[0] as HTMLAnchorElement;\r\n}\r\n\r\nfunction updateAnchorDisplayText(anchor: HTMLAnchorElement, displayText: string) {\r\n    if (displayText && anchor.textContent != displayText) {\r\n        anchor.textContent = displayText;\r\n    }\r\n}\r\n","import { cacheGetElementAtCursor, Editor } from 'roosterjs-editor-core';\r\nimport { DocumentCommand, FormatState, PluginEvent, QueryScope } from 'roosterjs-editor-types';\r\nimport { getComputedStyles, getTagOfNode, Position } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Get format state at cursor\r\n * A format state is a collection of all format related states, e.g.,\r\n * bold, italic, underline, font name, font size, etc.\r\n * @param editor The editor\r\n * @param (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns The format state at cursor\r\n */\r\nexport default function getFormatState(editor: Editor, event?: PluginEvent): FormatState {\r\n    let range = editor.getSelectionRange();\r\n    let node = range && Position.getStart(range).normalize().node;\r\n    let styles = node ? getComputedStyles(node) : [];\r\n    let listTag = getTagOfNode(cacheGetElementAtCursor(editor, event, 'OL,UL'));\r\n    let headerTag = getTagOfNode(cacheGetElementAtCursor(editor, event, 'H1,H2,H3,H4,H5,H6'));\r\n    let document = editor.getDocument();\r\n    return {\r\n        fontName: styles[0],\r\n        fontSize: styles[1],\r\n        textColor: styles[2],\r\n        backgroundColor: styles[3],\r\n\r\n        isBold: document.queryCommandState(DocumentCommand.Bold),\r\n        isItalic: document.queryCommandState(DocumentCommand.Italic),\r\n        isUnderline: document.queryCommandState(DocumentCommand.Underline),\r\n        isStrikeThrough: document.queryCommandState(DocumentCommand.StrikeThrough),\r\n        isSubscript: document.queryCommandState(DocumentCommand.Subscript),\r\n        isSuperscript: document.queryCommandState(DocumentCommand.Superscript),\r\n\r\n        isBullet: listTag == 'UL',\r\n        isNumbering: listTag == 'OL',\r\n        headerLevel: (headerTag && parseInt(headerTag[1])) || 0,\r\n\r\n        canUnlink: !!editor.queryElements('a[href]', QueryScope.OnSelection)[0],\r\n        canAddImageAltText: !!editor.queryElements('img', QueryScope.OnSelection)[0],\r\n        isBlockQuote: !!editor.queryElements('blockquote', QueryScope.OnSelection)[0],\r\n\r\n        canUndo: editor.canUndo(),\r\n        canRedo: editor.canRedo(),\r\n    };\r\n}\r\n","import createEditorCore from './createEditorCore';\r\nimport EditorCore from '../interfaces/EditorCore';\r\nimport EditorOptions from '../interfaces/EditorOptions';\r\nimport { GenericContentEditFeature } from '../interfaces/ContentEditFeature';\r\nimport { getRangeFromSelectionPath, getSelectionPath } from 'roosterjs-editor-dom';\r\nimport {\r\n    BlockElement,\r\n    ChangeSource,\r\n    ContentPosition,\r\n    DefaultFormat,\r\n    DocumentCommand,\r\n    ExtractContentEvent,\r\n    InlineElement,\r\n    InsertOption,\r\n    NodePosition,\r\n    NodeType,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PositionType,\r\n    QueryScope,\r\n    SelectionPath,\r\n    Rect,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    PositionContentSearcher,\r\n    ContentTraverser,\r\n    Position,\r\n    contains,\r\n    fromHtml,\r\n    getBlockElementAtNode,\r\n    findClosestElementAncestor,\r\n    getPositionRect,\r\n    getInlineElementAtNode,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    queryElements,\r\n    collapseNodes,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * RoosterJs core editor class\r\n */\r\nexport default class Editor {\r\n    private core: EditorCore;\r\n    private eventDisposers: (() => void)[];\r\n    private contenteditableChanged: boolean;\r\n\r\n    //#region Lifecycle\r\n\r\n    /**\r\n     * Creates an instance of Editor\r\n     * @param contentDiv The DIV HTML element which will be the container element of editor\r\n     * @param options An optional options object to customize the editor\r\n     */\r\n    constructor(contentDiv: HTMLDivElement, options: EditorOptions = {}) {\r\n        // 1. Make sure all parameters are valid\r\n        if (getTagOfNode(contentDiv) != 'DIV') {\r\n            throw new Error('contentDiv must be an HTML DIV element');\r\n        }\r\n\r\n        // 2. Store options values to local variables\r\n        this.core = createEditorCore(contentDiv, options);\r\n\r\n        // 3. Initialize plugins\r\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\r\n\r\n        // 4. Ensure initial content and its format\r\n        this.setContent(options.initialContent || contentDiv.innerHTML || '');\r\n\r\n        // 5. Create event handler to bind DOM events\r\n        this.eventDisposers = [\r\n            this.core.api.attachDomEvent(this.core, 'keypress', PluginEventType.KeyPress),\r\n            this.core.api.attachDomEvent(this.core, 'keydown', PluginEventType.KeyDown),\r\n            this.core.api.attachDomEvent(this.core, 'keyup', PluginEventType.KeyUp),\r\n            this.core.api.attachDomEvent(this.core, 'mousedown', PluginEventType.MouseDown),\r\n        ];\r\n\r\n        // 6. Add additional content edit features to the editor if specified\r\n        if (options.additionalEditFeatures) {\r\n            options.additionalEditFeatures.forEach(feature => this.addContentEditFeature(feature));\r\n        }\r\n\r\n        // 7. Make the container editable and set its selection styles\r\n        if (!options.omitContentEditableAttributeChanges && !contentDiv.isContentEditable) {\r\n            contentDiv.setAttribute('contenteditable', 'true');\r\n            let styles = contentDiv.style;\r\n            styles.userSelect = styles.msUserSelect = styles.webkitUserSelect = 'text';\r\n            this.contenteditableChanged = true;\r\n        }\r\n\r\n        // 8. Disable these operations for firefox since its behavior is usually wrong\r\n        // Catch any possible exception since this should not block the initialization of editor\r\n        try {\r\n            this.core.document.execCommand(DocumentCommand.EnableObjectResizing, false, <string>(\r\n                (<any>false)\r\n            ));\r\n            this.core.document.execCommand(DocumentCommand.EnableInlineTableEditing, false, <\r\n                string\r\n            >(<any>false));\r\n        } catch (e) {}\r\n\r\n        // 9. Let plugins know that we are ready\r\n        this.triggerEvent(\r\n            {\r\n                eventType: PluginEventType.EditorReady,\r\n            },\r\n            true /*broadcast*/\r\n        );\r\n\r\n        // 10. Before give editor to user, make sure there is at least one DIV element to accept typing\r\n        this.core.corePlugins.typeInContainer.ensureTypeInElement(\r\n            new Position(contentDiv, PositionType.Begin)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Dispose this editor, dispose all plugins and custom data\r\n     */\r\n    public dispose(): void {\r\n        this.triggerEvent(\r\n            {\r\n                eventType: PluginEventType.BeforeDispose,\r\n            },\r\n            true /*broadcast*/\r\n        );\r\n\r\n        this.core.plugins.forEach(plugin => plugin.dispose());\r\n        this.eventDisposers.forEach(disposer => disposer());\r\n        this.eventDisposers = null;\r\n\r\n        for (let key of Object.keys(this.core.customData)) {\r\n            let data = this.core.customData[key];\r\n            if (data && data.disposer) {\r\n                data.disposer(data.value);\r\n            }\r\n            delete this.core.customData[key];\r\n        }\r\n\r\n        if (this.contenteditableChanged) {\r\n            let styles = this.core.contentDiv.style;\r\n            styles.userSelect = styles.msUserSelect = styles.webkitUserSelect = '';\r\n            this.core.contentDiv.removeAttribute('contenteditable');\r\n        }\r\n\r\n        this.core = null;\r\n    }\r\n\r\n    /**\r\n     * Get whether this editor is disposed\r\n     * @returns True if editor is disposed, otherwise false\r\n     */\r\n    public isDisposed(): boolean {\r\n        return !this.core;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Node API\r\n\r\n    /**\r\n     * Insert node into editor\r\n     * @param node The node to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     * @returns true if node is inserted. Otherwise false\r\n     */\r\n    public insertNode(node: Node, option?: InsertOption): boolean {\r\n        return node ? this.core.api.insertNode(this.core, node, option) : false;\r\n    }\r\n\r\n    /**\r\n     * Delete a node from editor content\r\n     * @param node The node to delete\r\n     * @returns true if node is deleted. Otherwise false\r\n     */\r\n    public deleteNode(node: Node): boolean {\r\n        // Only remove the node when it falls within editor\r\n        if (node && this.contains(node)) {\r\n            node.parentNode.removeChild(node);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Replace a node in editor content with another node\r\n     * @param existingNode The existing node to be replaced\r\n     * @param new node to replace to\r\n     * @returns true if node is replaced. Otherwise false\r\n     */\r\n    public replaceNode(existingNode: Node, toNode: Node): boolean {\r\n        // Only replace the node when it falls within editor\r\n        if (existingNode && toNode && this.contains(existingNode)) {\r\n            existingNode.parentNode.replaceChild(toNode, existingNode);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get InlineElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The InlineElement result\r\n     */\r\n    public getInlineElementAtNode(node: Node): InlineElement {\r\n        return getInlineElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    /**\r\n     * Get BlockElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The BlockElement result\r\n     */\r\n    public getBlockElementAtNode(node: Node): BlockElement {\r\n        return getBlockElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    /**\r\n     * Check if the node falls in the editor content\r\n     * @param node The node to check\r\n     * @returns True if the given node is in editor content, otherwise false\r\n     */\r\n    public contains(node: Node): boolean;\r\n\r\n    /**\r\n     * Check if the range falls in the editor content\r\n     * @param range The range to check\r\n     * @returns True if the given range is in editor content, otherwise false\r\n     */\r\n    public contains(range: Range): boolean;\r\n\r\n    public contains(arg: Node | Range): boolean {\r\n        return contains(this.core.contentDiv, <Node>arg);\r\n    }\r\n\r\n    /**\r\n     * Query HTML elements in editor by tag name\r\n     * @param tag Tag name of the element to query\r\n     * @param forEachCallback An optional callback to be invoked on each element in query result\r\n     * @returns HTML Element array of the query result\r\n     */\r\n    public queryElements<T extends keyof HTMLElementTagNameMap>(\r\n        tag: T,\r\n        forEachCallback?: (node: HTMLElementTagNameMap[T]) => any\r\n    ): HTMLElementTagNameMap[T][];\r\n\r\n    /**\r\n     * Query HTML elements in editor by a selector string\r\n     * @param selector Selector string to query\r\n     * @param forEachCallback An optional callback to be invoked on each node in query result\r\n     * @returns HTML Element array of the query result\r\n     */\r\n    public queryElements<T extends HTMLElement = HTMLElement>(\r\n        selector: string,\r\n        forEachCallback?: (node: T) => any\r\n    ): T[];\r\n\r\n    /**\r\n     * Query HTML elements with the given scope by tag name\r\n     * @param tag Tag name of the element to query\r\n     * @param scope The scope of the query, default value is QueryScope.Body\r\n     * @param forEachCallback An optional callback to be invoked on each element in query result\r\n     * @returns HTML Element list of the query result\r\n     */\r\n    public queryElements<T extends keyof HTMLElementTagNameMap>(\r\n        tag: T,\r\n        scope: QueryScope,\r\n        forEachCallback?: (node: HTMLElementTagNameMap[T]) => any\r\n    ): HTMLElementTagNameMap[T][];\r\n\r\n    /**\r\n     * Query HTML elements with the given scope by a selector string\r\n     * @param selector Selector string to query\r\n     * @param scope The scope of the query, default value is QueryScope.Body\r\n     * @param forEachCallback An optional callback to be invoked on each element in query result\r\n     * @returns HTML Element array of the query result\r\n     */\r\n    public queryElements<T extends HTMLElement = HTMLElement>(\r\n        selector: string,\r\n        scope: QueryScope,\r\n        forEachCallback?: (node: T) => any\r\n    ): T[];\r\n\r\n    public queryElements(\r\n        selector: string,\r\n        scopeOrCallback: QueryScope | ((node: Node) => any) = QueryScope.Body,\r\n        callback?: (node: Node) => any\r\n    ) {\r\n        let scope = scopeOrCallback instanceof Function ? QueryScope.Body : scopeOrCallback;\r\n        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;\r\n\r\n        let range = scope == QueryScope.Body ? null : this.getSelectionRange();\r\n        return queryElements(this.core.contentDiv, selector, callback, scope, range);\r\n    }\r\n\r\n    /**\r\n     * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n     * split parent nodes if necessary\r\n     * @param start The start node\r\n     * @param end The end node\r\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n     * and the returned nodes will be all nodes from start trhough end after splitting\r\n     * False to disallow split parent\r\n     * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n     * otherwise just return start and end\r\n     */\r\n    public collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[] {\r\n        return collapseNodes(this.core.contentDiv, start, end, canSplitParent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Content API\r\n\r\n    /**\r\n     * Check whether the editor contains any visible content\r\n     * @param trim Whether trime the content string before check. Default is false\r\n     * @returns True if there's no visible content, otherwise false\r\n     */\r\n    public isEmpty(trim?: boolean): boolean {\r\n        return isNodeEmpty(this.core.contentDiv, trim);\r\n    }\r\n\r\n    /**\r\n     * Get current editor content as HTML string\r\n     * @param triggerExtractContentEvent Whether trigger ExtractContent event to all plugins\r\n     * before return. Use this parameter to remove any temporary content added by plugins.\r\n     * @param includeSelectionMarker Set to true if need include selection marker inside the content.\r\n     * When restore this content, editor will set the selection to the position marked by these markers\r\n     * @returns HTML string representing current editor content\r\n     */\r\n    public getContent(\r\n        triggerExtractContentEvent: boolean = true,\r\n        includeSelectionMarker: boolean = false\r\n    ): string {\r\n        let contentDiv = this.core.contentDiv;\r\n        let content = contentDiv.innerHTML;\r\n        let selectionPath: SelectionPath;\r\n\r\n        if (\r\n            includeSelectionMarker &&\r\n            (selectionPath = getSelectionPath(contentDiv, this.getSelectionRange()))\r\n        ) {\r\n            content += `<!--${JSON.stringify(selectionPath)}-->`;\r\n        }\r\n\r\n        if (triggerExtractContentEvent) {\r\n            let extractContentEvent: ExtractContentEvent = {\r\n                eventType: PluginEventType.ExtractContent,\r\n                content: content,\r\n            };\r\n            this.triggerEvent(extractContentEvent, true /*broadcast*/);\r\n            content = extractContentEvent.content;\r\n        }\r\n\r\n        return content;\r\n    }\r\n\r\n    /**\r\n     * Get plain text content inside editor\r\n     * @returns The text content inside editor\r\n     */\r\n    public getTextContent(): string {\r\n        return this.core.contentDiv.innerText;\r\n    }\r\n\r\n    /**\r\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\r\n     * @param content HTML content to set in\r\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\r\n     */\r\n    public setContent(content: string, triggerContentChangedEvent: boolean = true) {\r\n        let contentDiv = this.core.contentDiv;\r\n        if (contentDiv.innerHTML != content) {\r\n            contentDiv.innerHTML = content || '';\r\n\r\n            let pathComment = contentDiv.lastChild;\r\n\r\n            if (pathComment && pathComment.nodeType == NodeType.Comment) {\r\n                try {\r\n                    let path = JSON.parse(pathComment.nodeValue) as SelectionPath;\r\n                    this.deleteNode(pathComment);\r\n                    let range = getRangeFromSelectionPath(contentDiv, path);\r\n                    this.select(range);\r\n                } catch {}\r\n            }\r\n\r\n            if (triggerContentChangedEvent) {\r\n                this.triggerContentChangedEvent();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert HTML content into editor\r\n     * @param HTML content to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     */\r\n    public insertContent(content: string, option?: InsertOption) {\r\n        if (content) {\r\n            let allNodes = fromHtml(content, this.core.document);\r\n            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with\r\n            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped\r\n            // separately to show up on its own line\r\n            if (option && option.insertOnNewLine && allNodes.length > 0) {\r\n                allNodes = [wrap(allNodes)];\r\n            }\r\n            for (let i = 0; i < allNodes.length; i++) {\r\n                this.insertNode(allNodes[i], option);\r\n            }\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Focus and Selection\r\n\r\n    /**\r\n     * Get current selection range from Editor.\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @returns current selection range, or null if editor never got focus before\r\n     */\r\n    public getSelectionRange(): Range {\r\n        return this.core.api.getSelectionRange(this.core, true /*tryGetFromCache*/);\r\n    }\r\n\r\n    /**\r\n     * Check if focus is in editor now\r\n     * @returns true if focus is in editor, otherwise false\r\n     */\r\n    public hasFocus(): boolean {\r\n        return this.core.api.hasFocus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\r\n     */\r\n    public focus() {\r\n        this.core.api.focus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Select content by range\r\n     * @param range The range to select\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(range: Range): boolean;\r\n\r\n    /**\r\n     * Select content by Position and collapse to this position\r\n     * @param position The position to select\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(position: NodePosition): boolean;\r\n\r\n    /**\r\n     * Select content by a start and end position\r\n     * @param start The start position to select\r\n     * @param end The end position to select, if this is the same with start, the selection will be collapsed\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(start: NodePosition, end: NodePosition): boolean;\r\n\r\n    /**\r\n     * Select content by node\r\n     * @param node The node to select\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(node: Node): boolean;\r\n\r\n    /**\r\n     * Select content by node and offset, and collapse to this position\r\n     * @param node The node to select\r\n     * @param offset The offset of node to select, can be a number or value of PositionType\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(node: Node, offset: number | PositionType): boolean;\r\n\r\n    /**\r\n     * Select content by start and end nodes and offsets\r\n     * @param startNode The node to select start from\r\n     * @param startOffset The offset to select start from\r\n     * @param endNode The node to select end to\r\n     * @param endOffset The offset to select end to\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(\r\n        startNode: Node,\r\n        startOffset: number | PositionType,\r\n        endNode: Node,\r\n        endOffset: number | PositionType\r\n    ): boolean;\r\n\r\n    public select(arg1: any, arg2?: any, arg3?: any, arg4?: any): boolean {\r\n        return this.core.api.select(this.core, arg1, arg2, arg3, arg4);\r\n    }\r\n\r\n    /**\r\n     * Get current selection\r\n     * @return current selection object\r\n     */\r\n    public getSelection(): Selection {\r\n        return this.core.document.defaultView.getSelection();\r\n    }\r\n\r\n    /**\r\n     * Save the current selection in editor so that when focus again, the selection can be restored\r\n     */\r\n    public saveSelectionRange() {\r\n        this.core.cachedSelectionRange = this.core.api.getSelectionRange(\r\n            this.core,\r\n            false /*tryGetFromCache*/\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Restore the saved selection range and clear it\r\n     */\r\n    public restoreSavedRange() {\r\n        this.select(this.core.cachedSelectionRange);\r\n        this.core.cachedSelectionRange = null;\r\n    }\r\n\r\n    /**\r\n     * Get current focused position. Return null if editor doesn't have focus at this time.\r\n     */\r\n    public getFocusedPosition(): NodePosition {\r\n        let sel = this.getSelection();\r\n        if (this.contains(sel && sel.focusNode)) {\r\n            return new Position(sel.focusNode, sel.focusOffset);\r\n        }\r\n\r\n        let range = this.getSelectionRange();\r\n        if (range) {\r\n            return Position.getStart(range);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get a rect representing the location of the cursor.\r\n     * @returns a Rect object representing cursor location\r\n     */\r\n    public getCursorRect(): Rect {\r\n        let position = this.getFocusedPosition();\r\n        return position && getPositionRect(position);\r\n    }\r\n\r\n    /**\r\n     * Get an HTML element from current cursor position.\r\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\r\n     * or its parent node (if current node is a Text node).\r\n     * When expectedTags is specified, return value is the first anscestor of current node which has\r\n     * one of the expected tags.\r\n     * If no element found within editor by the given tag, return null.\r\n     * @param selector Optional, an HTML selector to find HTML element with.\r\n     * @param startFrom Start search from this node. If not specified, start from current focused position\r\n     */\r\n    public getElementAtCursor(selector?: string, startFrom?: Node): HTMLElement {\r\n        if (!startFrom) {\r\n            let position = this.getFocusedPosition();\r\n            startFrom = position && position.node;\r\n        }\r\n        return startFrom && findClosestElementAncestor(startFrom, this.core.contentDiv, selector);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region EVENT API\r\n\r\n    /**\r\n     * Add a custom DOM event handler to handle events not handled by roosterjs.\r\n     * Caller need to take the responsibility to dispose the handler properly\r\n     * @param eventName DOM event name to handle\r\n     * @param handler Handler callback\r\n     * @returns A dispose function. Call the function to dispose this event handler\r\n     */\r\n    public addDomEventHandler(eventName: string, handler: (event: UIEvent) => void): () => void;\r\n\r\n    /**\r\n     * Add a bunch of custom DOM event handler to handle events not handled by roosterjs.\r\n     * Caller need to take the responsibility to dispose the handler properly\r\n     * @param handlerMap A event name => event handler map\r\n     * @returns A dispose function. Call the function to dispose all event handlers added by this function\r\n     */\r\n    public addDomEventHandler(handlerMap: {\r\n        [eventName: string]: (event: UIEvent) => void;\r\n    }): () => void;\r\n\r\n    public addDomEventHandler(\r\n        nameOrMap:\r\n            | string\r\n            | {\r\n                  [eventName: string]: (event: UIEvent) => void;\r\n              },\r\n        handler?: (event: UIEvent) => void\r\n    ): () => void {\r\n        if (nameOrMap instanceof Object) {\r\n            let handlers = Object.keys(nameOrMap)\r\n                .map(\r\n                    eventName =>\r\n                        nameOrMap[eventName] &&\r\n                        this.core.api.attachDomEvent(\r\n                            this.core,\r\n                            eventName,\r\n                            null /*pluginEventType*/,\r\n                            nameOrMap[eventName]\r\n                        )\r\n                )\r\n                .filter(x => x);\r\n            return () => handlers.forEach(handler => handler());\r\n        } else {\r\n            return this.core.api.attachDomEvent(\r\n                this.core,\r\n                nameOrMap,\r\n                null /*pluginEventType*/,\r\n                handler\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger an event to be dispatched to all plugins\r\n     * @param pluginEvent The event object to trigger\r\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\r\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\r\n     */\r\n    public triggerEvent(pluginEvent: PluginEvent, broadcast: boolean = true) {\r\n        this.core.api.triggerEvent(this.core, pluginEvent, broadcast);\r\n    }\r\n\r\n    /**\r\n     * Trigger a ContentChangedEvent\r\n     * @param source Source of this event, by default is 'SetContent'\r\n     * @param data additional data for this event\r\n     */\r\n    public triggerContentChangedEvent(\r\n        source: ChangeSource | string = ChangeSource.SetContent,\r\n        data?: any\r\n    ) {\r\n        this.triggerEvent({\r\n            eventType: PluginEventType.ContentChanged,\r\n            source: source,\r\n            data: data,\r\n        } as PluginEvent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Undo API\r\n\r\n    /**\r\n     * Undo last edit operation\r\n     */\r\n    public undo() {\r\n        this.focus();\r\n        this.core.corePlugins.undo.undo();\r\n    }\r\n\r\n    /**\r\n     * Redo next edit operation\r\n     */\r\n    public redo() {\r\n        this.focus();\r\n        this.core.corePlugins.undo.redo();\r\n    }\r\n\r\n    /**\r\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\r\n     * ContentChangedEvent with given change source.\r\n     * If this function is called nested, undo snapshot will only be added in the outside one\r\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\r\n     * the data field in ContentChangedEvent if changeSource is not null.\r\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\r\n     * a ContentChangedEvent will be fired with change source equal to this value\r\n     */\r\n    public addUndoSnapshot(\r\n        callback?: (start: NodePosition, end: NodePosition, snapshotBeforeCallback: string) => any,\r\n        changeSource?: ChangeSource | string\r\n    ) {\r\n        this.core.api.editWithUndo(this.core, callback, changeSource);\r\n    }\r\n\r\n    /**\r\n     * Perform an auto complete action in the callback, save a snapsnot of content before the action,\r\n     * and trigger ContentChangedEvent with the change source if specified\r\n     * @param callback The auto complete callback, return value will be used as data field of ContentChangedEvent\r\n     * @param changeSource Chagne source of ContentChangedEvent. If not passed, no ContentChangedEvent will be  triggered\r\n     */\r\n    public performAutoComplete(callback: () => any, changeSource?: ChangeSource | string) {\r\n        this.core.corePlugins.edit.performAutoComplete(callback, changeSource);\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available undo snapshot\r\n     */\r\n    public canUndo(): boolean {\r\n        return this.core.corePlugins.undo.canUndo();\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available redo snapshot\r\n     */\r\n    public canRedo(): boolean {\r\n        return this.core.corePlugins.undo.canRedo();\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Misc\r\n\r\n    /**\r\n     * Get document which contains this editor\r\n     * @returns The HTML document which contains this editor\r\n     */\r\n    public getDocument(): Document {\r\n        return this.core.document;\r\n    }\r\n\r\n    /**\r\n     * Get custom data related to this editor\r\n     * @param key Key of the custom data\r\n     * @param getter Getter function. If custom data for the given key doesn't exist,\r\n     * call this function to get one and store it.\r\n     * @param disposer An optional disposer function to dispose this custom data when\r\n     * dispose editor.\r\n     */\r\n    public getCustomData<T>(key: string, getter: () => T, disposer?: (value: T) => void): T {\r\n        return this.core.api.getCustomData(this.core, key, getter, disposer);\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME(): boolean {\r\n        return this.core.corePlugins.domEvent.isInIME();\r\n    }\r\n\r\n    /**\r\n     * Get default format of this editor\r\n     * @returns Default format object of this editor\r\n     */\r\n    public getDefaultFormat(): DefaultFormat {\r\n        return this.core.defaultFormat;\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for the whole editor\r\n     */\r\n    public getBodyTraverser(): ContentTraverser {\r\n        return ContentTraverser.createBodyTraverser(this.core.contentDiv);\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current selection\r\n     */\r\n    public getSelectionTraverser(): ContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range &&\r\n            ContentTraverser.createSelectionTraverser(\r\n                this.core.contentDiv,\r\n                this.getSelectionRange()\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current block element start from specified position\r\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\r\n     */\r\n    public getBlockTraverser(\r\n        startFrom: ContentPosition = ContentPosition.SelectionStart\r\n    ): ContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range && ContentTraverser.createBlockTraverser(this.core.contentDiv, range, startFrom)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a text traverser of current selection\r\n     */\r\n    public getContentSearcherOfCursor(): PositionContentSearcher {\r\n        let range = this.getSelectionRange();\r\n        return range && new PositionContentSearcher(this.core.contentDiv, Position.getStart(range));\r\n    }\r\n\r\n    /**\r\n     * Run a callback function asynchronously\r\n     * @param callback The callback function to run\r\n     */\r\n    public runAsync(callback: () => void) {\r\n        let win = this.core.contentDiv.ownerDocument.defaultView || window;\r\n        win.requestAnimationFrame(() => {\r\n            if (!this.isDisposed() && callback) {\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     * @param value Value of the attribute\r\n     */\r\n    public setEditorDomAttribute(name: string, value: string) {\r\n        if (value === null) {\r\n            this.core.contentDiv.removeAttribute(name);\r\n        } else {\r\n            this.core.contentDiv.setAttribute(name, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature. This is mostly called from ContentEdit plugin\r\n     * @param feature The feature to add\r\n     */\r\n    public addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        this.core.corePlugins.edit.addFeature(feature);\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","import attachDomEvent from '../coreAPI/attachDomEvent';\r\nimport DOMEventPlugin from '../corePlugins/DOMEventPlugin';\r\nimport EditorCore, { CoreApiMap, CorePlugins } from '../interfaces/EditorCore';\r\nimport EditorOptions from '../interfaces/EditorOptions';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport EditPlugin from '../corePlugins/EditPlugin';\r\nimport editWithUndo from '../coreAPI/editWithUndo';\r\nimport focus from '../coreAPI/focus';\r\nimport getCustomData from '../coreAPI/getCustomData';\r\nimport getSelectionRange from '../coreAPI/getSelectionRange';\r\nimport hasFocus from '../coreAPI/hasFocus';\r\nimport insertNode from '../coreAPI/insertNode';\r\nimport MouseUpPlugin from '../corePlugins/MouseUpPlugin';\r\nimport select from '../coreAPI/select';\r\nimport triggerEvent from '../coreAPI/triggerEvent';\r\nimport TypeInContainerPlugin from '../corePlugins/TypeInContainerPlugin';\r\nimport Undo from '../undo/Undo';\r\nimport { DefaultFormat } from 'roosterjs-editor-types';\r\nimport { getComputedStyles } from 'roosterjs-editor-dom';\r\n\r\nexport default function createEditorCore(\r\n    contentDiv: HTMLDivElement,\r\n    options: EditorOptions\r\n): EditorCore {\r\n    let corePlugins: CorePlugins = {\r\n        undo: options.undo || new Undo(),\r\n        edit: new EditPlugin(),\r\n        typeInContainer: new TypeInContainerPlugin(),\r\n        mouseUp: new MouseUpPlugin(),\r\n        domEvent: new DOMEventPlugin(options.disableRestoreSelectionOnFocus),\r\n    };\r\n    let allPlugins: EditorPlugin[] = [\r\n        corePlugins.typeInContainer,\r\n        corePlugins.edit,\r\n        corePlugins.mouseUp,\r\n        ...(options.plugins || []),\r\n        corePlugins.undo,\r\n        corePlugins.domEvent,\r\n    ].filter(plugin => !!plugin);\r\n    let eventHandlerPlugins = allPlugins.filter(\r\n        plugin => plugin.onPluginEvent || plugin.willHandleEventExclusively\r\n    );\r\n    return {\r\n        contentDiv,\r\n        document: contentDiv.ownerDocument,\r\n        defaultFormat: calcDefaultFormat(contentDiv, options.defaultFormat),\r\n        corePlugins,\r\n        currentUndoSnapshot: null,\r\n        customData: {},\r\n        cachedSelectionRange: null,\r\n        plugins: allPlugins,\r\n        eventHandlerPlugins: eventHandlerPlugins,\r\n        api: createCoreApiMap(options.coreApiOverride),\r\n        defaultApi: createCoreApiMap(),\r\n    };\r\n}\r\n\r\nfunction calcDefaultFormat(node: Node, baseFormat: DefaultFormat): DefaultFormat {\r\n    if (baseFormat && Object.keys(baseFormat).length === 0) {\r\n        return {};\r\n    }\r\n\r\n    baseFormat = baseFormat || <DefaultFormat>{};\r\n    let styles = getComputedStyles(node);\r\n    return {\r\n        fontFamily: baseFormat.fontFamily || styles[0],\r\n        fontSize: baseFormat.fontSize || styles[1],\r\n        textColor: baseFormat.textColor || styles[2],\r\n        backgroundColor: baseFormat.backgroundColor || '',\r\n        bold: baseFormat.bold,\r\n        italic: baseFormat.italic,\r\n        underline: baseFormat.underline,\r\n    };\r\n}\r\n\r\nfunction createCoreApiMap(map?: Partial<CoreApiMap>): CoreApiMap {\r\n    map = map || {};\r\n    return {\r\n        attachDomEvent: map.attachDomEvent || attachDomEvent,\r\n        editWithUndo: map.editWithUndo || editWithUndo,\r\n        focus: map.focus || focus,\r\n        getCustomData: map.getCustomData || getCustomData,\r\n        getSelectionRange: map.getSelectionRange || getSelectionRange,\r\n        hasFocus: map.hasFocus || hasFocus,\r\n        insertNode: map.insertNode || insertNode,\r\n        select: map.select || select,\r\n        triggerEvent: map.triggerEvent || triggerEvent,\r\n    };\r\n}\r\n","import EditorCore, { AttachDomEvent } from '../interfaces/EditorCore';\r\nimport { PluginDomEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\nconst attachDomEvent: AttachDomEvent = (\r\n    core: EditorCore,\r\n    eventName: string,\r\n    pluginEventType?: PluginEventType,\r\n    beforeDispatch?: (event: UIEvent) => void\r\n) => {\r\n    let onEvent = (event: UIEvent) => {\r\n        if (beforeDispatch) {\r\n            beforeDispatch(event);\r\n        }\r\n        if (pluginEventType != null) {\r\n            core.api.triggerEvent(\r\n                core,\r\n                <PluginDomEvent>{\r\n                    eventType: pluginEventType,\r\n                    rawEvent: event,\r\n                },\r\n                false /*broadcast*/\r\n            );\r\n        }\r\n    };\r\n    core.contentDiv.addEventListener(eventName, onEvent);\r\n    return () => {\r\n        core.contentDiv.removeEventListener(eventName, onEvent);\r\n    };\r\n};\r\n\r\nexport default attachDomEvent;\r\n","import EditorCore, { EditWithUndo } from '../interfaces/EditorCore';\r\nimport { Position } from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    ContentChangedEvent,\r\n    NodePosition,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst editWithUndo: EditWithUndo = (\r\n    core: EditorCore,\r\n    callback: (start: NodePosition, end: NodePosition, snapshotBeforeCallback: string) => any,\r\n    changeSource: ChangeSource | string\r\n) => {\r\n    let isNested = core.currentUndoSnapshot !== null;\r\n    let data: any;\r\n\r\n    if (!isNested) {\r\n        core.currentUndoSnapshot = core.corePlugins.undo.addUndoSnapshot();\r\n    }\r\n\r\n    try {\r\n        if (callback) {\r\n            let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\r\n            data = callback(\r\n                range && Position.getStart(range).normalize(),\r\n                range && Position.getEnd(range).normalize(),\r\n                core.currentUndoSnapshot\r\n            );\r\n\r\n            if (!isNested) {\r\n                core.corePlugins.undo.addUndoSnapshot();\r\n            }\r\n        }\r\n    } finally {\r\n        if (!isNested) {\r\n            core.currentUndoSnapshot = null;\r\n        }\r\n    }\r\n\r\n    if (callback && changeSource) {\r\n        let event: ContentChangedEvent = {\r\n            eventType: PluginEventType.ContentChanged,\r\n            source: changeSource,\r\n            data: data,\r\n        };\r\n        core.api.triggerEvent(core, event, true /*broadcast*/);\r\n    }\r\n};\r\n\r\nexport default editWithUndo;\r\n","import EditorCore, { Focus } from '../interfaces/EditorCore';\r\nimport { getFirstLeafNode } from 'roosterjs-editor-dom';\r\nimport { PositionType } from 'roosterjs-editor-types';\r\n\r\nconst focus: Focus = (core: EditorCore) => {\r\n    if (!core.api.hasFocus(core) || !core.api.getSelectionRange(core, false /*tryGetFromCache*/)) {\r\n        // Focus (document.activeElement indicates) and selection are mostly in sync, but could be out of sync in some extreme cases.\r\n        // i.e. if you programmatically change window selection to point to a non-focusable DOM element (i.e. tabindex=-1 etc.).\r\n        // On Chrome/Firefox, it does not change document.activeElement. On Edge/IE, it change document.activeElement to be body\r\n        // Although on Chrome/Firefox, document.activeElement points to editor, you cannot really type which we don't want (no cursor).\r\n        // So here we always do a live selection pull on DOM and make it point in Editor. The pitfall is, the cursor could be reset\r\n        // to very begin to of editor since we don't really have last saved selection (created on blur which does not fire in this case).\r\n        // It should be better than the case you cannot type\r\n        if (!core.cachedSelectionRange || !core.api.select(core, core.cachedSelectionRange)) {\r\n            let node = getFirstLeafNode(core.contentDiv) || core.contentDiv;\r\n            core.api.select(core, node, PositionType.Begin);\r\n        }\r\n    }\r\n\r\n    // remember to clear cachedSelectionRange\r\n    core.cachedSelectionRange = null;\r\n\r\n    // This is more a fallback to ensure editor gets focus if it didn't manage to move focus to editor\r\n    if (!core.api.hasFocus(core)) {\r\n        core.contentDiv.focus();\r\n    }\r\n};\r\n\r\nexport default focus;\r\n","import EditorCore, { GetCustomData } from '../interfaces/EditorCore';\r\n\r\nconst getCustomData: GetCustomData = <T>(\r\n    core: EditorCore,\r\n    key: string,\r\n    getter: () => T,\r\n    disposer?: (value: T) => void\r\n): T => {\r\n    return (core.customData[key] = core.customData[key] || {\r\n        value: getter(),\r\n        disposer,\r\n    }).value as T;\r\n};\r\n\r\nexport default getCustomData;\r\n","import EditorCore, { GetSelectionRange } from '../interfaces/EditorCore';\r\nimport { contains } from 'roosterjs-editor-dom';\r\n\r\nconst getSelectionRange: GetSelectionRange = (core: EditorCore, tryGetFromCache: boolean) => {\r\n    let result: Range = null;\r\n\r\n    if (!tryGetFromCache || core.api.hasFocus(core)) {\r\n        let selection = core.document.defaultView.getSelection();\r\n        if (selection && selection.rangeCount > 0) {\r\n            let range = selection.getRangeAt(0);\r\n            if (contains(core.contentDiv, range)) {\r\n                result = range;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!result && tryGetFromCache) {\r\n        result = core.cachedSelectionRange;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nexport default getSelectionRange;\r\n","import EditorCore, { InsertNode } from '../interfaces/EditorCore';\r\nimport { ContentPosition, InsertOption, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport {\r\n    Position,\r\n    changeElementTag,\r\n    contains,\r\n    createRange,\r\n    getBlockElementAtNode,\r\n    getFirstLastBlockElement,\r\n    getTagOfNode,\r\n    isBlockElement,\r\n    isNodeEmpty,\r\n    isPositionAtBeginningOf,\r\n    isVoidHtmlElement,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst insertNode: InsertNode = (core: EditorCore, node: Node, option: InsertOption) => {\r\n    let position = option ? option.position : ContentPosition.SelectionStart;\r\n    let updateCursor = option ? option.updateCursor : true;\r\n    let replaceSelection = option ? option.replaceSelection : true;\r\n    let insertOnNewLine = option ? option.insertOnNewLine : false;\r\n    let contentDiv = core.contentDiv;\r\n\r\n    if (updateCursor) {\r\n        core.api.focus(core);\r\n    }\r\n\r\n    switch (position) {\r\n        case ContentPosition.Begin:\r\n        case ContentPosition.End:\r\n            let isBegin = position == ContentPosition.Begin;\r\n            let block = getFirstLastBlockElement(contentDiv, isBegin);\r\n            let insertedNode: Node;\r\n            if (block) {\r\n                let refNode = isBegin ? block.getStartNode() : block.getEndNode();\r\n                if (\r\n                    insertOnNewLine ||\r\n                    refNode.nodeType == NodeType.Text ||\r\n                    isVoidHtmlElement(refNode)\r\n                ) {\r\n                    // For insert on new line, or refNode is text or void html element (HR, BR etc.)\r\n                    // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\r\n                    // first and last node. Insert before 'hello' or after 'world', but still inside DIV\r\n                    insertedNode = refNode.parentNode.insertBefore(\r\n                        node,\r\n                        isBegin ? refNode : refNode.nextSibling\r\n                    );\r\n                } else {\r\n                    // if the refNode can have child, use appendChild (which is like to insert as first/last child)\r\n                    // i.e. <div>hello</div>, the content will be inserted before/after hello\r\n                    insertedNode = refNode.insertBefore(node, isBegin ? refNode.firstChild : null);\r\n                }\r\n            } else {\r\n                // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\r\n                insertedNode = contentDiv.appendChild(node);\r\n            }\r\n\r\n            // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\r\n            // add a DIV wrapping\r\n            if (insertedNode && insertOnNewLine && !isBlockElement(insertedNode)) {\r\n                wrap(insertedNode);\r\n            }\r\n\r\n            break;\r\n        case ContentPosition.SelectionStart:\r\n            let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\r\n            if (range) {\r\n                // if to replace the selection and the selection is not collapsed, remove the the content at selection first\r\n                if (replaceSelection && !range.collapsed) {\r\n                    range.deleteContents();\r\n                }\r\n\r\n                // Create a clone (backup) for the selection first as we may need to restore to it later\r\n                let clonedRange = range.cloneRange();\r\n                let position = Position.getStart(range).normalize();\r\n                let blockElement = getBlockElementAtNode(contentDiv, position.node);\r\n\r\n                if (blockElement) {\r\n                    let endNode = blockElement.getEndNode();\r\n                    if (insertOnNewLine) {\r\n                        // Adjust the insertion point\r\n                        // option.insertOnNewLine means to insert on a block after the selection, not really right at the selection\r\n                        // This is commonly used when users want to insert signature. They could place cursor somewhere mid of a line\r\n                        // and insert signature, they actually want signature to be inserted the line after the selection\r\n                        range.setEndAfter(endNode);\r\n                        range.collapse(false /*toStart*/);\r\n                    } else {\r\n                        range = preprocessNode(core, range, node, endNode);\r\n                    }\r\n                }\r\n\r\n                let nodeForCursor =\r\n                    node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\r\n                range.insertNode(node);\r\n                if (updateCursor && nodeForCursor) {\r\n                    core.api.select(\r\n                        core,\r\n                        new Position(nodeForCursor, PositionType.After).normalize()\r\n                    );\r\n                } else {\r\n                    core.api.select(core, clonedRange);\r\n                }\r\n            }\r\n            break;\r\n        case ContentPosition.Outside:\r\n            core.contentDiv.parentNode.insertBefore(node, contentDiv.nextSibling);\r\n            break;\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nexport default insertNode;\r\n\r\nfunction preprocessNode(\r\n    core: EditorCore,\r\n    range: Range,\r\n    nodeToInsert: Node,\r\n    currentNode: Node\r\n): Range {\r\n    let rootNodeToInsert = nodeToInsert;\r\n\r\n    if (rootNodeToInsert.nodeType == NodeType.DocumentFragment) {\r\n        let rootNodes = (<Node[]>[].slice.call(rootNodeToInsert.childNodes)).filter(\r\n            n => getTagOfNode(n) != 'BR'\r\n        );\r\n        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;\r\n    }\r\n\r\n    let tag = getTagOfNode(rootNodeToInsert);\r\n\r\n    if ((tag == 'OL' || tag == 'UL') && getTagOfNode(rootNodeToInsert.firstChild) == 'LI') {\r\n        let shouldInsertListAsText =\r\n            !rootNodeToInsert.firstChild.nextSibling &&\r\n            getTagOfNode(rootNodeToInsert.nextSibling) != 'BR';\r\n\r\n        if (getTagOfNode(rootNodeToInsert.nextSibling) == 'BR' && rootNodeToInsert.parentNode) {\r\n            rootNodeToInsert.parentNode.removeChild(rootNodeToInsert.nextSibling);\r\n        }\r\n\r\n        if (shouldInsertListAsText) {\r\n            unwrap(rootNodeToInsert.firstChild);\r\n            unwrap(rootNodeToInsert);\r\n        } else {\r\n            let listNode = currentNode;\r\n            while (\r\n                getTagOfNode(listNode.parentNode) != tag &&\r\n                contains(core.contentDiv, listNode)\r\n            ) {\r\n                listNode = listNode.parentNode;\r\n            }\r\n\r\n            if (getTagOfNode(listNode.parentNode) == tag) {\r\n                if (\r\n                    isNodeEmpty(listNode) ||\r\n                    isPositionAtBeginningOf(Position.getStart(range), listNode)\r\n                ) {\r\n                    range.setEndBefore(listNode);\r\n                } else {\r\n                    range.setEndAfter(listNode);\r\n                }\r\n                range.collapse(false /*toStart*/);\r\n                unwrap(rootNodeToInsert);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (getTagOfNode(currentNode) == 'P') {\r\n        // Insert into a P tag may cause issues when the inserted content contains any block element.\r\n        // Change P tag to DIV to make sure it works well\r\n        let start = Position.getStart(range).normalize();\r\n        let end = Position.getEnd(range).normalize();\r\n        let div = changeElementTag(<HTMLElement>currentNode, 'div');\r\n        let newRange = createRange(start, end);\r\n        if (start.node != div && end.node != div && contains(core.contentDiv, newRange)) {\r\n            range = newRange;\r\n        }\r\n    }\r\n\r\n    if (isVoidHtmlElement(range.endContainer)) {\r\n        range.setEndBefore(range.endContainer);\r\n    }\r\n\r\n    return range;\r\n}\r\n","import EditorCore, { Select } from '../interfaces/EditorCore';\r\nimport hasFocus from './hasFocus';\r\nimport { Browser, contains, createRange, Position } from 'roosterjs-editor-dom';\r\nimport { NodePosition, PositionType } from 'roosterjs-editor-types';\r\n\r\nconst select: Select = (core: EditorCore, arg1: any, arg2?: any, arg3?: any, arg4?: any) => {\r\n    let range: Range;\r\n\r\n    if (!arg1) {\r\n        return false;\r\n    } else if (arg1 instanceof Range) {\r\n        range = arg1;\r\n    } else {\r\n        if (arg1.node) {\r\n            range = createRange(new Position(arg1), arg2 && arg2.node ? new Position(arg2) : null);\r\n        } else if (arg1 instanceof Node) {\r\n            let start: NodePosition;\r\n            let end: NodePosition;\r\n            if (arg2 == undefined) {\r\n                start = new Position(<Node>arg1, PositionType.Before);\r\n                end = new Position(<Node>arg1, PositionType.After);\r\n            } else {\r\n                start = new Position(<Node>arg1, <number | PositionType>arg2);\r\n                end =\r\n                    arg3 instanceof Node\r\n                        ? new Position(<Node>arg3, <number | PositionType>arg4)\r\n                        : null;\r\n            }\r\n            range = createRange(start, end);\r\n        }\r\n    }\r\n\r\n    if (contains(core.contentDiv, range)) {\r\n        let selection = core.document.defaultView.getSelection();\r\n        if (selection) {\r\n            let needAddRange = true;\r\n\r\n            if (selection.rangeCount > 0) {\r\n                // Workaround IE exception 800a025e\r\n                try {\r\n                    // Do not remove/add range if current selection is the same with target range\r\n                    // Without this check, execCommand() may fail in Edge since we changed the selection\r\n                    let currentRange =\r\n                        Browser.isEdge && selection.rangeCount == 1\r\n                            ? selection.getRangeAt(0)\r\n                            : null;\r\n                    if (\r\n                        currentRange &&\r\n                        currentRange.startContainer == range.startContainer &&\r\n                        currentRange.startOffset == range.startOffset &&\r\n                        currentRange.endContainer == range.endContainer &&\r\n                        currentRange.endOffset == range.endOffset\r\n                    ) {\r\n                        needAddRange = false;\r\n                    } else {\r\n                        selection.removeAllRanges();\r\n                    }\r\n                } catch (e) {}\r\n            }\r\n\r\n            if (needAddRange) {\r\n                selection.addRange(range);\r\n            }\r\n\r\n            if (!hasFocus(core)) {\r\n                core.cachedSelectionRange = range;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nexport default select;\r\n","import EditorCore, { TriggerEvent } from '../interfaces/EditorCore';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\n\r\nconst triggerEvent: TriggerEvent = (\r\n    core: EditorCore,\r\n    pluginEvent: PluginEvent,\r\n    broadcast: boolean\r\n) => {\r\n    if (\r\n        broadcast ||\r\n        !core.eventHandlerPlugins.some(plugin => handledExclusively(pluginEvent, plugin))\r\n    ) {\r\n        core.eventHandlerPlugins.forEach(plugin => {\r\n            if (plugin.onPluginEvent) {\r\n                plugin.onPluginEvent(pluginEvent);\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\nfunction handledExclusively(event: PluginEvent, plugin: EditorPlugin): boolean {\r\n    if (\r\n        plugin.onPluginEvent &&\r\n        plugin.willHandleEventExclusively &&\r\n        plugin.willHandleEventExclusively(event)\r\n    ) {\r\n        plugin.onPluginEvent(event);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport default triggerEvent;\r\n","import UndoSnapshotsService from '../interfaces/UndoSnapshotsService';\r\n\r\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\r\n// to keep size under limit. This is kept at 10MB\r\nconst MAXSIZELIMIT = 1e7;\r\n\r\nexport default class UndoSnapshots implements UndoSnapshotsService {\r\n    private snapshots: string[];\r\n    private totalSize: number;\r\n    private currentIndex: number;\r\n\r\n    constructor(private maxSize: number = MAXSIZELIMIT) {\r\n        this.snapshots = [];\r\n        this.totalSize = 0;\r\n        this.currentIndex = -1;\r\n    }\r\n\r\n    /**\r\n     * Check whether can move current undo snapshot with the given step\r\n     * @param step The step to check, can be positive, negative or 0\r\n     * @returns True if can move current snapshot with the given step, otherwise false\r\n     */\r\n    public canMove(delta: number): boolean {\r\n        let newIndex = this.currentIndex + delta;\r\n        return newIndex >= 0 && newIndex < this.snapshots.length;\r\n    }\r\n\r\n    /**\r\n     * Move current snapshot with the given step if can move this step. Otherwise no action and return null\r\n     * @param step The step to move\r\n     * @returns If can move with the given step, returns the snapshot after move, otherwise null\r\n     */\r\n    public move(delta: number): string {\r\n        if (this.canMove(delta)) {\r\n            this.currentIndex += delta;\r\n            return this.snapshots[this.currentIndex];\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new undo snapshot\r\n     * @param snapshot The snapshot to add\r\n     */\r\n    public addSnapshot(snapshot: string) {\r\n        if (this.currentIndex < 0 || snapshot != this.snapshots[this.currentIndex]) {\r\n            this.clearRedo();\r\n            this.snapshots.push(snapshot);\r\n            this.currentIndex++;\r\n            this.totalSize += snapshot.length;\r\n\r\n            let removeCount = 0;\r\n            while (removeCount < this.snapshots.length && this.totalSize > this.maxSize) {\r\n                this.totalSize -= this.snapshots[removeCount].length;\r\n                removeCount++;\r\n            }\r\n\r\n            if (removeCount > 0) {\r\n                this.snapshots.splice(0, removeCount);\r\n                this.currentIndex -= removeCount;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all undo snapshots after the current one\r\n     */\r\n    public clearRedo() {\r\n        if (this.canMove(1)) {\r\n            let removedSize = 0;\r\n            for (let i = this.currentIndex + 1; i < this.snapshots.length; i++) {\r\n                removedSize += this.snapshots[i].length;\r\n            }\r\n            this.snapshots.splice(this.currentIndex + 1);\r\n            this.totalSize -= removedSize;\r\n        }\r\n    }\r\n}\r\n","import cacheGetEventData from './cacheGetEventData';\r\nimport clearEventDataCache from './clearEventDataCache';\r\nimport Editor from '../editor/Editor';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\nimport { PositionContentSearcher } from 'roosterjs-editor-dom';\r\n\r\nconst CONTENTSEARCHER_KEY = 'CONTENTSEARCHER';\r\n\r\n/**\r\n * Try get existing PositionContentSearcher from an event. If there isn't one, create a new one from editor.\r\n * @param event The plugin event, it stores the event cached data for looking up.\r\n * If passed as null, we will create a new PositionContentSearcher\r\n * @param editor The editor instance\r\n * @returns The PositionContentSearcher object\r\n */\r\nexport function cacheGetContentSearcher(\r\n    event: PluginEvent,\r\n    editor: Editor\r\n): PositionContentSearcher {\r\n    return cacheGetEventData(event, CONTENTSEARCHER_KEY, () => editor.getContentSearcherOfCursor());\r\n}\r\n\r\n/**\r\n * Clear the PositionContentSearcher in a plugin event.\r\n * This is called when the content is changed\r\n * @param event The plugin event\r\n */\r\nexport function clearContentSearcherCache(event: PluginEvent) {\r\n    clearEventDataCache(event, CONTENTSEARCHER_KEY);\r\n}\r\n","import cacheGetEventData from './cacheGetEventData';\r\nimport Editor from '../editor/Editor';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\n\r\nconst CACHE_KEY_PREFIX = 'GET_ELEMENT_AT_CURSOR_';\r\n\r\n/**\r\n * Get an HTML element at cursor from event cache if it exists.\r\n * If an selector is specified, return the nearest ancestor of current node\r\n * which matches the selector, or null if no match found in editor.\r\n * @param editor The editor instance\r\n * @param event Event object to get cached object from\r\n * @param selector The expected selector. If null, return the element at cursor\r\n * @returns The element at cursor or the nearest ancestor with the tag name is specified\r\n */\r\nexport default function cacheGetElementAtCursor(\r\n    editor: Editor,\r\n    event: PluginEvent,\r\n    selector: string\r\n): HTMLElement {\r\n    return cacheGetEventData(event, CACHE_KEY_PREFIX + selector, () =>\r\n        editor.getElementAtCursor(selector)\r\n    );\r\n}\r\n","import { ChangeSource } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image file. There are at least 3 ways to obtain the file object:\r\n * From local file, from clipboard data, from drag-and-drop\r\n */\r\nexport default function insertImage(editor: Editor, imageFile: File) {\r\n    let reader = new FileReader();\r\n    reader.onload = (event: ProgressEvent) => {\r\n        if (!editor.isDisposed()) {\r\n            editor.addUndoSnapshot(() => {\r\n                let image = editor.getDocument().createElement('img');\r\n                image.src = (event.target as FileReader).result as string;\r\n                image.style.maxWidth = '100%';\r\n                editor.insertNode(image);\r\n            }, ChangeSource.Format);\r\n        }\r\n    };\r\n    reader.readAsDataURL(imageFile);\r\n}\r\n","import formatTable from './formatTable';\r\nimport { ChangeSource, PositionType, TableFormat } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { Position } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert table into editor at current selection\r\n * @param editor The editor instance\r\n * @param columns Number of columns in table, it also controls the default table cell width:\r\n * if columns <= 4, width = 120px; if columns <= 6, width = 100px; else width = 70px\r\n * @param rows Number of rows in table\r\n * @param format (Optional) The table format. If not passed, the default format will be applied:\r\n * background color: #FFF; border color: #ABABAB\r\n */\r\nexport default function insertTable(\r\n    editor: Editor,\r\n    columns: number,\r\n    rows: number,\r\n    format?: TableFormat\r\n) {\r\n    let document = editor.getDocument();\r\n    let fragment = document.createDocumentFragment();\r\n    let table = document.createElement('table') as HTMLTableElement;\r\n    fragment.appendChild(table);\r\n    table.cellSpacing = '0';\r\n    table.cellPadding = '1';\r\n    for (let i = 0; i < rows; i++) {\r\n        let tr = document.createElement('tr') as HTMLTableRowElement;\r\n        table.appendChild(tr);\r\n        for (let j = 0; j < columns; j++) {\r\n            let td = document.createElement('td') as HTMLTableCellElement;\r\n            tr.appendChild(td);\r\n            td.appendChild(document.createElement('br'));\r\n            td.style.width = getTableCellWidth(columns);\r\n        }\r\n    }\r\n\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        editor.insertNode(fragment);\r\n        formatTable(\r\n            editor,\r\n            format || {\r\n                bgColorEven: '#FFF',\r\n                bgColorOdd: '#FFF',\r\n                topBorderColor: '#ABABAB',\r\n                bottomBorderColor: '#ABABAB',\r\n                verticalBorderColor: '#ABABAB',\r\n            },\r\n            table\r\n        );\r\n        editor.runAsync(() => editor.select(new Position(table, PositionType.Begin).normalize()));\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction getTableCellWidth(columns: number): string {\r\n    if (columns <= 4) {\r\n        return '120px';\r\n    } else if (columns <= 6) {\r\n        return '100px';\r\n    } else {\r\n        return '70px';\r\n    }\r\n}\r\n","import { ChangeSource, TableOperation } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Edit table with given operation. If there is no table at cursor then no op.\r\n * @param editor The editor instance\r\n * @param operation Table operation\r\n */\r\nexport default function editTable(editor: Editor, operation: TableOperation) {\r\n    let td = editor.getElementAtCursor('TD,TH') as HTMLTableCellElement;\r\n    if (td) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(td);\r\n            vtable.edit(operation);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n\r\n            if (!editor.select(start, end)) {\r\n                editor.select(editor.contains(td) ? td : vtable.getCurrentTd());\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { unwrap } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Remove link at selection. If no links at selection, do nothing.\r\n * If selection contains multiple links, all of the link styles will be removed.\r\n * If only part of a link is selected, the whole link style will be removed.\r\n * @param editor The editor instance\r\n */\r\nexport default function removeLink(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        editor.queryElements('a[href]', QueryScope.OnSelection, unwrap);\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { Editor } from 'roosterjs-editor-core';\r\nimport { PositionContentSearcher } from 'roosterjs-editor-dom';\r\nimport { PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Replace text before current selection with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param text The text for matching. We will try to match the text with the text before cursor\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n * @param searcher Optional PositionContentSearcher of current selection to help search text\r\n */\r\nexport default function replaceWithNode(\r\n    editor: Editor,\r\n    text: string,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: PositionContentSearcher\r\n): boolean;\r\n\r\n/**\r\n * Replace a given range with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param range The range to replace from\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n */\r\nexport default function replaceWithNode(\r\n    editor: Editor,\r\n    range: Range,\r\n    node: Node,\r\n    exactMatch: boolean\r\n): boolean;\r\n\r\nexport default function replaceWithNode(\r\n    editor: Editor,\r\n    textOrRange: string | Range,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: PositionContentSearcher\r\n): boolean {\r\n    // Make sure the text and node is valid\r\n    if (!textOrRange || !node) {\r\n        return false;\r\n    }\r\n\r\n    let range: Range;\r\n\r\n    if (typeof textOrRange == 'string') {\r\n        searcher = searcher || editor.getContentSearcherOfCursor();\r\n        range = searcher && searcher.getRangeFromText(textOrRange, exactMatch);\r\n    } else {\r\n        range = textOrRange;\r\n    }\r\n\r\n    if (range) {\r\n        let backupRange = editor.getSelectionRange();\r\n\r\n        range.deleteContents();\r\n        range.insertNode(node);\r\n\r\n        if (exactMatch) {\r\n            editor.select(node, PositionType.After);\r\n        } else {\r\n            editor.select(backupRange);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { Alignment, ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set content alignment\r\n * @param editor The editor instance\r\n * @param alignment The alignment option:\r\n * Alignment.Center, Alignment.Left, Alignment.Right\r\n */\r\nexport default function setAlignment(editor: Editor, alignment: Alignment) {\r\n    let command = DocumentCommand.JustifyLeft;\r\n    let align = 'left';\r\n\r\n    if (alignment == Alignment.Center) {\r\n        command = DocumentCommand.JustifyCenter;\r\n        align = 'center';\r\n    } else if (alignment == Alignment.Right) {\r\n        command = DocumentCommand.JustifyRight;\r\n        align = 'right';\r\n    }\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, command);\r\n        editor.queryElements(\r\n            '[align]',\r\n            QueryScope.OnSelection,\r\n            node => (node.style.textAlign = align)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, Direction } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Change direction for the blocks/paragraph at selection\r\n * @param editor The editor instance\r\n * @param direction The direction option:\r\n * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'\r\n */\r\nexport default function setDirection(editor: Editor, direction: Direction) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        collapseSelectedBlocks(editor, element => {\r\n            element.setAttribute('dir', direction == Direction.LeftToRight ? 'ltr' : 'rtl');\r\n            element.style.textAlign = direction == Direction.LeftToRight ? 'left' : 'right';\r\n        });\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set image alt text for all selected images at selection. If no images is contained\r\n * in selection, do nothing.\r\n * The alt attribute provides alternative information for an image if a user for some reason\r\n * cannot view it (because of slow connection, an error in the src attribute, or if the user\r\n * uses a screen reader). See https://www.w3schools.com/tags/att_img_alt.asp\r\n * @param editor The editor instance\r\n * @param altText The image alt text\r\n */\r\nexport default function setImageAltText(editor: Editor, altText: string) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        editor.queryElements('img', QueryScope.OnSelection, node =>\r\n            node.setAttribute('alt', altText)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import processList from '../utils/processList';\r\nimport { ChangeSource, DocumentCommand, Indentation, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set indentation at selection\r\n * If selection contains bullet/numbering list, increase/decrease indentation will\r\n * increase/decrease the list level by one.\r\n * @param editor The editor instance\r\n * @param indentation The indentation option:\r\n * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation\r\n */\r\nexport default function setIndentation(editor: Editor, indentation: Indentation) {\r\n    let command =\r\n        indentation == Indentation.Increase ? DocumentCommand.Indent : DocumentCommand.Outdent;\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n        let listNode = editor.getElementAtCursor('OL,UL');\r\n        let newNode: Node;\r\n\r\n        if (listNode) {\r\n            // There is already list node, setIndentation() will increase/decrease the list level,\r\n            // so we need to process the list when change indentation\r\n            newNode = processList(editor, command);\r\n        } else {\r\n            // No existing list node, browser will create <Blockquote> node for indentation.\r\n            // We need to set top and bottom margin to 0 to avoid unnecessary spaces\r\n            editor.getDocument().execCommand(command, false, null);\r\n            editor.queryElements('BLOCKQUOTE', QueryScope.OnSelection, node => {\r\n                newNode = newNode || node;\r\n                node.style.marginTop = '0px';\r\n                node.style.marginBottom = '0px';\r\n            });\r\n        }\r\n\r\n        return newNode;\r\n    }, ChangeSource.Format);\r\n}\r\n","import processList from '../utils/processList';\r\nimport { ChangeSource, DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle bullet at selection\r\n * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one\r\n * If selection contains number list, toggle bullet will convert the number list into bullet list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBullet(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(\r\n        () => processList(editor, DocumentCommand.InsertUnorderedList),\r\n        ChangeSource.Format\r\n    );\r\n}\r\n","import processList from '../utils/processList';\r\nimport { ChangeSource, DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle numbering at selection\r\n * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one\r\n * If selection contains bullet list, toggle numbering will convert the bullet list into number list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * realization of browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleNumbering(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(\r\n        () => processList(editor, DocumentCommand.InsertOrderedList),\r\n        ChangeSource.Format\r\n    );\r\n}\r\n","import toggleTagCore from '../utils/toggleTagCore';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\nconst BLOCKQUOTE_TAG = 'blockquote';\r\nconst DEFAULT_STYLER = (element: HTMLElement): void => {\r\n    element.style.borderLeft = '3px solid';\r\n    element.style.borderColor = '#C8C8C8';\r\n    element.style.paddingLeft = '10px';\r\n    element.style.color = '#666666';\r\n};\r\n\r\n/**\r\n * Toggle blockquote at selection, if selection already contains any blockquoted elements,\r\n * the blockquoted elements will be unblockquoted and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the blockquote element\r\n */\r\nexport default function toggleBlockQuote(editor: Editor, styler?: (element: HTMLElement) => void) {\r\n    toggleTagCore(editor, BLOCKQUOTE_TAG, styler || DEFAULT_STYLER);\r\n}\r\n","import toggleTagCore from '../utils/toggleTagCore';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getTagOfNode, unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst PRE_TAG = 'pre';\r\nconst CODE_TAG = 'code';\r\nconst CODE_NODE_TAG = 'CODE';\r\n\r\n/**\r\n * Toggle code block at selection, if selection already contains any code blocked elements,\r\n * the code block elements will be no longer be code blocked and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the code block element\r\n */\r\nexport default function toggleCodeBlock(\r\n    editor: Editor,\r\n    styler?: (element: HTMLElement) => void\r\n): void {\r\n    toggleTagCore(editor, PRE_TAG, styler, wrapFunction, unwrapFunction);\r\n}\r\n\r\nfunction wrapFunction(nodes: Node[]): HTMLElement {\r\n    let codeBlock = wrap(nodes, CODE_TAG);\r\n    return wrap(codeBlock, PRE_TAG);\r\n}\r\n\r\nfunction unwrapFunction(node: HTMLElement): Node {\r\n    if (!node) {\r\n        return null;\r\n    }\r\n\r\n    let firstChild = node.childNodes[0];\r\n    if (node.childNodes.length == 1 && getTagOfNode(firstChild) == CODE_NODE_TAG) {\r\n        unwrap(firstChild);\r\n    }\r\n\r\n    return unwrap(node);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle strikethrough at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only strikethrough text, the strikethrough style will be removed\r\n * If selection contains only normal text, strikethrough style will be added to the whole selected text\r\n * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleStrikethrough(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.StrikeThrough);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle subscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only subscript text, the subscript style will be removed\r\n * If selection contains only normal text, subscript style will be added to the whole selected text\r\n * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text\r\n * If selection contains any superscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSubscript(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Subscript);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle superscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only superscript text, the superscript style will be removed\r\n * If selection contains only normal text, superscript style will be added to the whole selected text\r\n * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text\r\n * If selection contains any subscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSuperscript(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Superscript);\r\n}\r\n","import { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { findClosestElementAncestor } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Toggle header at selection\r\n * @param editor The editor instance\r\n * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to\r\n * the HTML header element <H1> to <H6>, 0 means no header\r\n * if passed in param is outside the range, will be rounded to nearest number in the range\r\n */\r\nexport default function toggleHeader(editor: Editor, level: number) {\r\n    level = Math.min(Math.max(Math.round(level), 0), 6);\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n\r\n        let wrapped = false;\r\n        editor.queryElements('H1,H2,H3,H4,H5,H6', QueryScope.OnSelection, header => {\r\n            if (!wrapped) {\r\n                editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, '<DIV>');\r\n                wrapped = true;\r\n            }\r\n\r\n            let div = editor.getDocument().createElement('div');\r\n            while (header.firstChild) {\r\n                div.appendChild(header.firstChild);\r\n            }\r\n            editor.replaceNode(header, div);\r\n        });\r\n\r\n        if (level > 0) {\r\n            let traverser = editor.getSelectionTraverser();\r\n            let inlineElement = traverser ? traverser.currentInlineElement : null;\r\n            while (inlineElement) {\r\n                let element = findClosestElementAncestor(inlineElement.getContainerNode());\r\n                if (element) {\r\n                    element.style.fontSize = '';\r\n                }\r\n                inlineElement = traverser.getNextInlineElement();\r\n            }\r\n            editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, `<H${level}>`);\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\nimport { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\r\nimport { FontSizeChange, PluginEventType, PluginKeyboardEvent } from 'roosterjs-editor-types';\r\nimport {\r\n    changeFontSize,\r\n    toggleBold,\r\n    toggleItalic,\r\n    toggleUnderline,\r\n    toggleBullet,\r\n    toggleNumbering,\r\n} from 'roosterjs-editor-api';\r\n\r\ninterface ShortcutCommand {\r\n    winKey: number;\r\n    macKey: number;\r\n    action: (editor: Editor) => any;\r\n}\r\n\r\nfunction createCommand(winKey: number, macKey: number, action: (editor: Editor) => any) {\r\n    return {\r\n        winKey,\r\n        macKey,\r\n        action,\r\n    };\r\n}\r\n\r\nconst commands: ShortcutCommand[] = [\r\n    createCommand(Keys.Ctrl | Keys.B, Keys.Meta | Keys.B, toggleBold),\r\n    createCommand(Keys.Ctrl | Keys.I, Keys.Meta | Keys.I, toggleItalic),\r\n    createCommand(Keys.Ctrl | Keys.U, Keys.Meta | Keys.U, toggleUnderline),\r\n    createCommand(Keys.Ctrl | Keys.Z, Keys.Meta | Keys.Z, editor => editor.undo()),\r\n    createCommand(Keys.Ctrl | Keys.Y, Keys.Meta | Keys.Shift | Keys.Z, editor => editor.redo()),\r\n    createCommand(Keys.Ctrl | Keys.PERIOD, Keys.Meta | Keys.PERIOD, toggleBullet),\r\n    createCommand(Keys.Ctrl | Keys.FORWARDSLASH, Keys.Meta | Keys.FORWARDSLASH, toggleNumbering),\r\n    createCommand(\r\n        Keys.Ctrl | Keys.Shift | Keys.PERIOD,\r\n        Keys.Meta | Keys.Shift | Keys.PERIOD,\r\n        editor => changeFontSize(editor, FontSizeChange.Increase)\r\n    ),\r\n    createCommand(\r\n        Keys.Ctrl | Keys.Shift | Keys.COMMA,\r\n        Keys.Meta | Keys.Shift | Keys.COMMA,\r\n        editor => changeFontSize(editor, FontSizeChange.Decrease)\r\n    ),\r\n];\r\n\r\nexport const DefaultShortcut: ContentEditFeature = {\r\n    allowFunctionKeys: true,\r\n    keys: [Keys.B, Keys.I, Keys.U, Keys.Y, Keys.Z, Keys.COMMA, Keys.PERIOD, Keys.FORWARDSLASH],\r\n    shouldHandleEvent: cacheGetCommand,\r\n    handleEvent: (event, editor) => {\r\n        let command = cacheGetCommand(event);\r\n        if (command) {\r\n            command.action(editor);\r\n            event.rawEvent.preventDefault();\r\n            event.rawEvent.stopPropagation();\r\n        }\r\n    },\r\n};\r\n\r\nfunction cacheGetCommand(event: PluginKeyboardEvent) {\r\n    return cacheGetEventData(event, 'DEFAULT_SHORT_COMMAND', () => {\r\n        let e = event.rawEvent;\r\n        let key =\r\n            // Need to check ALT key to be false since in some language (e.g. Polski) uses AltGr to input some special charactors\r\n            // In that case, ctrlKey and altKey are both true in Edge, but we should not trigger any shortcut function here\r\n            event.eventType == PluginEventType.KeyDown && !e.altKey\r\n                ? e.which |\r\n                  (e.metaKey && Keys.Meta) |\r\n                  (e.shiftKey && Keys.Shift) |\r\n                  (e.ctrlKey && Keys.Ctrl)\r\n                : 0;\r\n        return key && commands.filter(cmd => (Browser.isMac ? cmd.macKey : cmd.winKey) == key)[0];\r\n    });\r\n}\r\n","import { cacheGetElementAtCursor, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\r\nimport { contains, getTagOfNode, VTable } from 'roosterjs-editor-dom';\r\nimport { PluginEvent, PositionType } from 'roosterjs-editor-types';\r\n\r\nexport const TabInTable: ContentEditFeature = {\r\n    keys: [Keys.TAB],\r\n    shouldHandleEvent: cacheGetTableCell,\r\n    handleEvent: (event, editor) => {\r\n        let shift = event.rawEvent.shiftKey;\r\n        let td = cacheGetTableCell(event, editor);\r\n        for (\r\n            let vtable = new VTable(td),\r\n                step = shift ? -1 : 1,\r\n                row = vtable.row,\r\n                col = vtable.col + step;\r\n            ;\r\n            col += step\r\n        ) {\r\n            if (col < 0 || col >= vtable.cells[row].length) {\r\n                row += step;\r\n                if (row < 0 || row >= vtable.cells.length) {\r\n                    editor.select(vtable.table, shift ? PositionType.Before : PositionType.After);\r\n                    break;\r\n                }\r\n                col = shift ? vtable.cells[row].length - 1 : 0;\r\n            }\r\n            let cell = vtable.getCell(row, col);\r\n            if (cell.td) {\r\n                editor.select(cell.td, PositionType.Begin);\r\n                break;\r\n            }\r\n        }\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\nexport const UpDownInTable: ContentEditFeature = {\r\n    keys: [Keys.UP, Keys.DOWN],\r\n    shouldHandleEvent: cacheGetTableCell,\r\n    handleEvent: (event, editor) => {\r\n        let td = cacheGetTableCell(event, editor);\r\n        let vtable = new VTable(td);\r\n        let isUp = event.rawEvent.which == Keys.UP;\r\n        let step = isUp ? -1 : 1;\r\n        let targetTd: HTMLTableCellElement = null;\r\n\r\n        for (let row = vtable.row; row >= 0 && row < vtable.cells.length; row += step) {\r\n            let cell = vtable.getCell(row, vtable.col);\r\n            if (cell.td && cell.td != td) {\r\n                targetTd = cell.td;\r\n                break;\r\n            }\r\n        }\r\n\r\n        editor.runAsync(() => {\r\n            let newContainer = editor.getElementAtCursor();\r\n            if (\r\n                contains(vtable.table, newContainer) &&\r\n                !contains(td, newContainer, true /*treatSameNodeAsContain*/)\r\n            ) {\r\n                if (targetTd) {\r\n                    editor.select(targetTd, PositionType.Begin);\r\n                } else {\r\n                    editor.select(vtable.table, isUp ? PositionType.Before : PositionType.After);\r\n                }\r\n            }\r\n        });\r\n    },\r\n};\r\n\r\nfunction cacheGetTableCell(event: PluginEvent, editor: Editor): HTMLTableCellElement {\r\n    let firstTd = cacheGetElementAtCursor(editor, event, 'TD,TH,LI');\r\n    return getTagOfNode(firstTd) == 'LI' ? null : (firstTd as HTMLTableCellElement);\r\n}\r\n","import { setIndentation, toggleBullet, toggleNumbering } from 'roosterjs-editor-api';\r\nimport {\r\n    cacheGetContentSearcher,\r\n    cacheGetElementAtCursor,\r\n    Editor,\r\n    ContentEditFeature,\r\n    GenericContentEditFeature,\r\n    Keys,\r\n} from 'roosterjs-editor-core';\r\nimport {\r\n    ContentChangedEvent,\r\n    Indentation,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    Browser,\r\n    Position,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    isPositionAtBeginningOf,\r\n} from 'roosterjs-editor-dom';\r\n\r\nexport const IndentWhenTab: ContentEditFeature = {\r\n    keys: [Keys.TAB],\r\n    shouldHandleEvent: (event, editor) =>\r\n        !event.rawEvent.shiftKey && cacheGetListElement(event, editor),\r\n    handleEvent: (event, editor) => {\r\n        setIndentation(editor, Indentation.Increase);\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\nexport const OutdentWhenShiftTab: ContentEditFeature = {\r\n    keys: [Keys.TAB],\r\n    shouldHandleEvent: (event, editor) =>\r\n        event.rawEvent.shiftKey && cacheGetListElement(event, editor),\r\n    handleEvent: (event, editor) => {\r\n        setIndentation(editor, Indentation.Decrease);\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\nexport const MergeInNewLine: ContentEditFeature = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\r\n        let range = editor.getSelectionRange();\r\n        return li && range && isPositionAtBeginningOf(Position.getStart(range), li);\r\n    },\r\n    handleEvent: (event, editor) => {\r\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\r\n        if (li.previousSibling) {\r\n            editor.runAsync(() => {\r\n                let br = editor.getDocument().createElement('BR');\r\n                editor.insertNode(br);\r\n                editor.select(br, PositionType.After);\r\n            });\r\n        } else {\r\n            toggleListAndPreventDefault(event, editor);\r\n        }\r\n    },\r\n};\r\n\r\nexport const OutdentWhenBackOn1stEmptyLine: ContentEditFeature = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\r\n        return li && isNodeEmpty(li) && !li.previousSibling;\r\n    },\r\n    handleEvent: toggleListAndPreventDefault,\r\n};\r\n\r\nexport const OutdentWhenEnterOnEmptyLine: ContentEditFeature = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\r\n        return !event.rawEvent.shiftKey && li && isNodeEmpty(li);\r\n    },\r\n    handleEvent: (event, editor) => {\r\n        editor.performAutoComplete(() => toggleListAndPreventDefault(event, editor));\r\n    },\r\n};\r\n\r\nexport const AutoBullet: ContentEditFeature = {\r\n    keys: [Keys.SPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        if (!cacheGetListElement(event, editor)) {\r\n            let searcher = cacheGetContentSearcher(event, editor);\r\n            let textBeforeCursor = searcher.getSubStringBefore(3);\r\n\r\n            // Auto list is triggered if:\r\n            // 1. Text before cursor exactly mathces '*', '-' or '1.'\r\n            // 2. There's no non-text inline entities before cursor\r\n            return (\r\n                ['*', '-', '1.'].indexOf(textBeforeCursor) >= 0 &&\r\n                !searcher.getNearestNonTextInlineElement()\r\n            );\r\n        }\r\n        return false;\r\n    },\r\n    handleEvent: (event, editor) => {\r\n        editor.runAsync(() => {\r\n            editor.performAutoComplete(() => {\r\n                let searcher = editor.getContentSearcherOfCursor();\r\n                let textBeforeCursor = searcher.getSubStringBefore(3);\r\n                let rangeToDelete = searcher.getRangeFromText(\r\n                    textBeforeCursor,\r\n                    true /*exactMatch*/\r\n                );\r\n\r\n                if (rangeToDelete) {\r\n                    rangeToDelete.deleteContents();\r\n                }\r\n\r\n                // If not explicitly insert br, Chrome/Safari/IE will operate on the previous line\r\n                let tempBr = editor.getDocument().createElement('BR');\r\n                if (Browser.isChrome || Browser.isSafari || Browser.isIE11OrGreater) {\r\n                    editor.insertNode(tempBr);\r\n                }\r\n\r\n                if (textBeforeCursor.indexOf('1.') == 0) {\r\n                    toggleNumbering(editor);\r\n                } else {\r\n                    toggleBullet(editor);\r\n                }\r\n\r\n                editor.deleteNode(tempBr);\r\n            });\r\n        });\r\n    },\r\n};\r\n\r\nexport function getSmartOrderedList(\r\n    styleList: string[]\r\n): GenericContentEditFeature<ContentChangedEvent> {\r\n    return {\r\n        keys: [Keys.CONTENTCHANGED], // Triggered by ContentChangedEvent\r\n        shouldHandleEvent: (event, editor) => event.data instanceof HTMLOListElement,\r\n        handleEvent: (event, editor) => {\r\n            let ol = event.data as HTMLOListElement;\r\n            let parentOl = editor.getElementAtCursor('OL', ol.parentNode) as HTMLOListElement;\r\n            if (parentOl) {\r\n                // The style list must has at least one value. If no value is passed in, fallback to decimal\r\n                let styles = styleList && styleList.length > 0 ? styleList : ['decimal'];\r\n                ol.style.listStyle =\r\n                    styles[(styles.indexOf(parentOl.style.listStyle) + 1) % styles.length];\r\n            }\r\n        },\r\n    };\r\n}\r\n\r\nfunction toggleListAndPreventDefault(event: PluginKeyboardEvent, editor: Editor) {\r\n    let listInfo = cacheGetListElement(event, editor);\r\n    if (listInfo) {\r\n        let listElement = listInfo[0];\r\n        let tag = getTagOfNode(listElement);\r\n        if (tag == 'UL') {\r\n            toggleBullet(editor);\r\n        } else if (tag == 'OL') {\r\n            toggleNumbering(editor);\r\n        }\r\n        editor.focus();\r\n        event.rawEvent.preventDefault();\r\n    }\r\n}\r\n\r\nfunction cacheGetListElement(event: PluginKeyboardEvent, editor: Editor) {\r\n    let li = cacheGetElementAtCursor(editor, event, 'LI,TABLE');\r\n    let listElement = li && getTagOfNode(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);\r\n    return listElement ? [listElement, li] : null;\r\n}\r\n","import { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\r\nimport { PluginKeyboardEvent, PositionType } from 'roosterjs-editor-types';\r\nimport {\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    splitBalancedNodeRange,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst QUOTE_TAG = 'BLOCKQUOTE';\r\nconst STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');\r\n\r\nexport const UnquoteWhenBackOnEmpty1stLine: ContentEditFeature = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let childOfQuote = cacheGetQuoteChild(event, editor);\r\n        return childOfQuote && isNodeEmpty(childOfQuote) && !childOfQuote.previousSibling;\r\n    },\r\n    handleEvent: splitQuote,\r\n};\r\n\r\nexport const UnquoteWhenEnterOnEmptyLine: ContentEditFeature = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let childOfQuote = cacheGetQuoteChild(event, editor);\r\n        let shift = event.rawEvent.shiftKey;\r\n        return !shift && childOfQuote && isNodeEmpty(childOfQuote);\r\n    },\r\n    handleEvent: (event, editor) => editor.performAutoComplete(() => splitQuote(event, editor)),\r\n};\r\n\r\nfunction cacheGetQuoteChild(event: PluginKeyboardEvent, editor: Editor): Node {\r\n    return cacheGetEventData(event, 'QUOTE_CHILD', () => {\r\n        let quote = editor.getElementAtCursor(STRUCTURED_TAGS);\r\n        if (quote && getTagOfNode(quote) == QUOTE_TAG) {\r\n            let pos = editor.getFocusedPosition();\r\n            let block = pos && editor.getBlockElementAtNode(pos.normalize().node);\r\n            if (block) {\r\n                let node =\r\n                    block.getStartNode() == quote\r\n                        ? block.getStartNode()\r\n                        : block.collapseToSingleElement();\r\n                return isNodeEmpty(node) ? node : null;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    });\r\n}\r\n\r\nfunction splitQuote(event: PluginKeyboardEvent, editor: Editor) {\r\n    editor.addUndoSnapshot(() => {\r\n        let childOfQuote = cacheGetQuoteChild(event, editor);\r\n        let parent: Node;\r\n        if (getTagOfNode(childOfQuote) == QUOTE_TAG) {\r\n            childOfQuote = wrap([].slice.call(childOfQuote.childNodes));\r\n        }\r\n        parent = splitBalancedNodeRange(childOfQuote);\r\n        unwrap(parent);\r\n        editor.select(childOfQuote, PositionType.Begin);\r\n    });\r\n    event.rawEvent.preventDefault();\r\n}\r\n","import buildClipboardData from './buildClipboardData';\r\nimport fragmentHandler from './fragmentHandler';\r\nimport textToHtml from './textToHtml';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport { getFormatState } from 'roosterjs-editor-api';\r\nimport { insertImage } from 'roosterjs-editor-api';\r\nimport {\r\n    AttributeCallbackMap,\r\n    getInheritableStyles,\r\n    HtmlSanitizer,\r\n    htmlToDom,\r\n} from 'roosterjs-html-sanitizer';\r\nimport {\r\n    BeforePasteEvent,\r\n    ChangeSource,\r\n    ClipboardData,\r\n    DefaultFormat,\r\n    NodeType,\r\n    PasteOption,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    applyFormat,\r\n    fromHtml,\r\n    getFirstLeafNode,\r\n    getNextLeafSibling,\r\n    Position,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Paste plugin, handles onPaste event and paste content into editor\r\n */\r\nexport default class Paste implements EditorPlugin {\r\n    private editor: Editor;\r\n    private pasteDisposer: () => void;\r\n    private sanitizer: HtmlSanitizer;\r\n\r\n    /**\r\n     * Create an instance of Paste\r\n     * @param preserved Not used. Preserved parameter only used for compatibility with old code\r\n     * @param attributeCallbacks A set of callbacks to help handle html attribute during sanitization\r\n     */\r\n    constructor(preserved?: any, attributeCallbacks?: AttributeCallbackMap) {\r\n        this.sanitizer = new HtmlSanitizer({\r\n            attributeCallbacks,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Paste';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.pasteDisposer = editor.addDomEventHandler('paste', this.onPaste);\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.pasteDisposer();\r\n        this.pasteDisposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    private onPaste = (event: Event) => {\r\n        buildClipboardData(<ClipboardEvent>event, this.editor, items => {\r\n            this.pasteOriginal({\r\n                snapshotBeforePaste: null,\r\n                originalFormat: this.getCurrentFormat(),\r\n                types: items.types,\r\n                image: items.image,\r\n                text: items.text,\r\n                rawHtml: items.html,\r\n                html: items.html\r\n                    ? this.sanitizeHtml(items.html)\r\n                    : textToHtml(items.text, true /*parseLink*/),\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Paste into editor using passed in clipboardData with original format\r\n     * @param clipboardData The clipboardData to paste\r\n     */\r\n    public pasteOriginal(clipboardData: ClipboardData) {\r\n        this.paste(clipboardData, this.detectPasteOption(clipboardData));\r\n    }\r\n\r\n    /**\r\n     * Paste plain text into editor using passed in clipboardData\r\n     * @param clipboardData The clipboardData to paste\r\n     */\r\n    public pasteText(clipboardData: ClipboardData) {\r\n        this.paste(clipboardData, PasteOption.PasteText);\r\n    }\r\n\r\n    /**\r\n     * Paste into editor using passed in clipboardData with curent format\r\n     * @param clipboardData The clipboardData to paste\r\n     */\r\n    public pasteAndMergeFormat(clipboardData: ClipboardData) {\r\n        this.paste(clipboardData, this.detectPasteOption(clipboardData), true /*mergeFormat*/);\r\n    }\r\n\r\n    private detectPasteOption(clipboardData: ClipboardData): PasteOption {\r\n        return clipboardData.text || !clipboardData.image\r\n            ? PasteOption.PasteHtml\r\n            : PasteOption.PasteImage;\r\n    }\r\n\r\n    private paste(\r\n        clipboardData: ClipboardData,\r\n        pasteOption: PasteOption,\r\n        mergeCurrentFormat?: boolean\r\n    ) {\r\n        let document = this.editor.getDocument();\r\n        let fragment = document.createDocumentFragment();\r\n\r\n        if (pasteOption == PasteOption.PasteHtml) {\r\n            let html = clipboardData.html;\r\n            let nodes = fromHtml(html, document);\r\n\r\n            for (let node of nodes) {\r\n                if (mergeCurrentFormat) {\r\n                    this.applyTextFormat(node, clipboardData.originalFormat);\r\n                }\r\n                fragment.appendChild(node);\r\n            }\r\n        }\r\n\r\n        let event: BeforePasteEvent = {\r\n            eventType: PluginEventType.BeforePaste,\r\n            clipboardData: clipboardData,\r\n            fragment: fragment,\r\n            pasteOption: pasteOption,\r\n        };\r\n\r\n        this.editor.triggerEvent(event, true /*broadcast*/);\r\n        this.internalPaste(event);\r\n    }\r\n\r\n    private internalPaste(event: BeforePasteEvent) {\r\n        let { clipboardData, fragment, pasteOption } = event;\r\n        this.editor.focus();\r\n        this.editor.addUndoSnapshot(() => {\r\n            if (clipboardData.snapshotBeforePaste == null) {\r\n                clipboardData.snapshotBeforePaste = this.editor.getContent(\r\n                    false /*triggerExtractContentEvent*/,\r\n                    true /*markSelection*/\r\n                );\r\n            } else {\r\n                this.editor.setContent(clipboardData.snapshotBeforePaste);\r\n            }\r\n\r\n            switch (pasteOption) {\r\n                case PasteOption.PasteHtml:\r\n                    this.editor.insertNode(fragment);\r\n                    break;\r\n\r\n                case PasteOption.PasteText:\r\n                    let html = textToHtml(clipboardData.text);\r\n                    this.editor.insertContent(html);\r\n                    break;\r\n\r\n                case PasteOption.PasteImage:\r\n                    insertImage(this.editor, clipboardData.image);\r\n                    break;\r\n            }\r\n\r\n            return clipboardData;\r\n        }, ChangeSource.Paste);\r\n    }\r\n\r\n    private applyTextFormat(node: Node, format: DefaultFormat) {\r\n        let leaf = getFirstLeafNode(node);\r\n        let parents: HTMLElement[] = [];\r\n        while (leaf) {\r\n            if (\r\n                leaf.nodeType == NodeType.Text &&\r\n                leaf.parentNode &&\r\n                parents.indexOf(<HTMLElement>leaf.parentNode) < 0\r\n            ) {\r\n                parents.push(<HTMLElement>leaf.parentNode);\r\n            }\r\n            leaf = getNextLeafSibling(node, leaf);\r\n        }\r\n        for (let parent of parents) {\r\n            applyFormat(parent, format);\r\n        }\r\n    }\r\n\r\n    private getCurrentFormat(): DefaultFormat {\r\n        let format = getFormatState(this.editor);\r\n        return format\r\n            ? {\r\n                  fontFamily: format.fontName,\r\n                  fontSize: format.fontSize,\r\n                  textColor: format.textColor,\r\n                  backgroundColor: format.backgroundColor,\r\n                  bold: format.isBold,\r\n                  italic: format.isItalic,\r\n                  underline: format.isUnderline,\r\n              }\r\n            : {};\r\n    }\r\n\r\n    private sanitizeHtml(html: string): string {\r\n        let doc = htmlToDom(html, true /*preserveFragmentOnly*/, fragmentHandler);\r\n        if (doc && doc.body) {\r\n            this.sanitizer.convertGlobalCssToInlineCss(doc);\r\n\r\n            let range = this.editor.getSelectionRange();\r\n            let element = range && Position.getStart(range).normalize().element;\r\n            let currentStyles = getInheritableStyles(element);\r\n            this.sanitizer.sanitize(doc.body, currentStyles);\r\n            return doc.body.innerHTML;\r\n        }\r\n        return '';\r\n    }\r\n}\r\n","import { ClipboardItems, ContentPosition } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { extractClipboardEvent, fromHtml } from 'roosterjs-editor-dom';\r\n\r\nconst CONTAINER_HTML =\r\n    '<div contenteditable style=\"width: 1px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text\"></div>';\r\n\r\n/**\r\n * Build ClipboardData from a paste event\r\n * @param event The paste event\r\n * @param editor The editor\r\n * @param callback Callback function when data is ready\r\n */\r\nexport default function buildClipboardData(\r\n    event: ClipboardEvent,\r\n    editor: Editor,\r\n    callback: (items: ClipboardItems) => void\r\n) {\r\n    extractClipboardEvent(event, items => {\r\n        if (items.html === undefined) {\r\n            retrieveHtmlViaTempDiv(editor, html => {\r\n                items.html = html;\r\n                callback(items);\r\n            });\r\n        } else {\r\n            callback(items);\r\n        }\r\n    });\r\n}\r\n\r\nfunction retrieveHtmlViaTempDiv(editor: Editor, callback: (html: string) => void) {\r\n    // cache original selection range in editor\r\n    let originalSelectionRange = editor.getSelectionRange();\r\n    let tempDiv = getTempDivForPaste(editor);\r\n    tempDiv.focus();\r\n\r\n    editor.runAsync(() => {\r\n        // restore original selection range in editor\r\n        editor.select(originalSelectionRange);\r\n        callback(tempDiv.innerHTML);\r\n        tempDiv.style.display = 'none';\r\n        tempDiv.innerHTML = '';\r\n    });\r\n}\r\n\r\nfunction getTempDivForPaste(editor: Editor): HTMLElement {\r\n    let tempDiv = editor.getCustomData(\r\n        'PasteDiv',\r\n        () => {\r\n            let pasteDiv = fromHtml(CONTAINER_HTML, editor.getDocument())[0] as HTMLElement;\r\n            editor.insertNode(pasteDiv, {\r\n                position: ContentPosition.Outside,\r\n                updateCursor: false,\r\n                replaceSelection: false,\r\n                insertOnNewLine: false,\r\n            });\r\n            return pasteDiv;\r\n        },\r\n        pasteDiv => {\r\n            pasteDiv.parentNode.removeChild(pasteDiv);\r\n        }\r\n    );\r\n    tempDiv.style.display = '';\r\n    return tempDiv;\r\n}\r\n","import convertPastedContentFromExcel from './excelConverter/convertPastedContentFromExcel';\r\nimport convertPastedContentFromWord from './wordConverter/convertPastedContentFromWord';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { splitWithFragment } from 'roosterjs-html-sanitizer';\r\n\r\nconst WORD_ATTRIBUTE_NAME = 'xmlns:w';\r\nconst WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';\r\nconst EXCEL_ATTRIBUTE_NAME = 'xmlns:x';\r\nconst EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';\r\n\r\nconst LAST_TD_END_REGEX = /<\\/\\s*td\\s*>((?!<\\/\\s*tr\\s*>)[\\s\\S])*$/i;\r\nconst LAST_TR_END_REGEX = /<\\/\\s*tr\\s*>((?!<\\/\\s*table\\s*>)[\\s\\S])*$/i;\r\nconst LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;\r\nconst LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;\r\n\r\nexport default function fragmentHandler(doc: HTMLDocument, source: string) {\r\n    let [html, before] = splitWithFragment(source);\r\n    let firstNode = doc && doc.body && (doc.querySelector('html') as HTMLElement);\r\n    if (getTagOfNode(firstNode) == 'HTML') {\r\n        if (firstNode.getAttribute(WORD_ATTRIBUTE_NAME) == WORD_ATTRIBUTE_VALUE) {\r\n            // Handle HTML copied from MS Word\r\n            doc.body.innerHTML = html;\r\n            convertPastedContentFromWord(doc);\r\n        } else if (firstNode.getAttribute(EXCEL_ATTRIBUTE_NAME) == EXCEL_ATTRIBUTE_VALUE) {\r\n            // Handle HTML copied from MS Excel\r\n            if (html.match(LAST_TD_END_REGEX)) {\r\n                let trMatch = before.match(LAST_TR_REGEX);\r\n                let tr = trMatch ? trMatch[0] : '<TR>';\r\n                html = tr + html + '</TR>';\r\n            }\r\n            if (html.match(LAST_TR_END_REGEX)) {\r\n                let tableMatch = before.match(LAST_TABLE_REGEX);\r\n                let table = tableMatch ? tableMatch[0] : '<TABLE>';\r\n                html = table + html + '</TABLE>';\r\n            }\r\n            doc.body.innerHTML = html;\r\n            convertPastedContentFromExcel(doc);\r\n        } else {\r\n            // Handle HTML copied from other places\r\n            doc.body.innerHTML = html;\r\n        }\r\n    }\r\n}\r\n","import { HtmlSanitizer } from 'roosterjs-html-sanitizer';\r\n\r\nexport default function convertPastedContentFromExcel(doc: HTMLDocument) {\r\n    let sanitizer = new HtmlSanitizer({\r\n        styleCallbacks: {\r\n            border: (value, element) => value != 'none' || element.style.border != 'none',\r\n        },\r\n        additionalAllowAttributes: ['class'],\r\n    });\r\n    sanitizer.sanitize(doc.body);\r\n\r\n    let styleNode = doc.createElement('style');\r\n    doc.body.appendChild(styleNode);\r\n    styleNode.innerHTML = 'td {border: solid 1px #d4d4d4}';\r\n    sanitizer.convertGlobalCssToInlineCss(doc);\r\n}\r\n","import cloneObject from '../utils/cloneObject';\r\nimport getInheritableStyles from '../utils/getInheritableStyles';\r\nimport HtmlSanitizerOptions from '../types/HtmlSanitizerOptions';\r\nimport htmlToDom from '../utils/htmlToDom';\r\nimport SanitizeHtmlOptions from '../types/SanitizeHtmlOptions';\r\nimport {\r\n    StringMap,\r\n    StyleCallbackMap,\r\n    ElementCallbackMap,\r\n    AttributeCallbackMap,\r\n} from '../types/maps';\r\nimport {\r\n    getAllowedAttributes,\r\n    getAllowedTags,\r\n    getDefaultStyleValues,\r\n    getStyleCallbacks,\r\n} from '../utils/getAllowedValues';\r\n\r\nexport default class HtmlSanitizer {\r\n    /**\r\n     * Convert global CSS to inline CSS if any\r\n     * @param html HTML source\r\n     * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS\r\n     */\r\n    static convertInlineCss(html: string, additionalStyleNodes?: HTMLStyleElement[]) {\r\n        let sanitizer = new HtmlSanitizer({\r\n            additionalGlobalStyleNodes: additionalStyleNodes,\r\n        });\r\n        return sanitizer.exec(html, true /*convertCssOnly*/);\r\n    }\r\n\r\n    /**\r\n     * Sanitize HTML string, remove any unuseful HTML node/attribute/CSS.\r\n     * @param html HTML source string\r\n     * @param options Options used for this sanitizing process\r\n     */\r\n    static sanitizeHtml(html: string, options?: SanitizeHtmlOptions) {\r\n        options = options || {};\r\n        let sanitizer = new HtmlSanitizer(options);\r\n        let currentStyles =\r\n            options.currentElementOrStyle instanceof HTMLElement\r\n                ? getInheritableStyles(options.currentElementOrStyle)\r\n                : options.currentElementOrStyle;\r\n        return sanitizer.exec(\r\n            html,\r\n            options.convertCssOnly,\r\n            options.preserveFragmentOnly,\r\n            currentStyles\r\n        );\r\n    }\r\n\r\n    private elementCallbacks: ElementCallbackMap;\r\n    private styleCallbacks: StyleCallbackMap;\r\n    private attributeCallbacks: AttributeCallbackMap;\r\n    private allowedTags: string[];\r\n    private allowedAttributes: string[];\r\n    private defaultStyleValues: StringMap;\r\n    private additionalGlobalStyleNodes: HTMLStyleElement[];\r\n    private allowPreserveWhiteSpace: boolean;\r\n\r\n    constructor(options?: HtmlSanitizerOptions) {\r\n        options = options || {};\r\n        this.elementCallbacks = cloneObject(options.elementCallbacks);\r\n        this.styleCallbacks = getStyleCallbacks(options.styleCallbacks);\r\n        this.attributeCallbacks = cloneObject(options.attributeCallbacks);\r\n        this.allowedTags = getAllowedTags(options.additionalAllowedTags);\r\n        this.allowedAttributes = getAllowedAttributes(options.additionalAllowAttributes);\r\n        this.defaultStyleValues = getDefaultStyleValues(options.additionalDefaultStyleValues);\r\n        this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];\r\n        this.allowPreserveWhiteSpace = options.allowPreserveWhiteSpace;\r\n    }\r\n\r\n    /**\r\n     * Sanitize HTML string\r\n     * This function will do the following work:\r\n     * 1. Convert global CSS into inline CSS\r\n     * 2. Remove dangerous HTML tags and attributes\r\n     * 3. Remove useless CSS properties\r\n     * @param html The input HTML\r\n     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing\r\n     * @param preserveFragmentOnly If set to true, only preserve the html content between <!--StartFragment--> and <!--Endfragment-->\r\n     * @param currentStyles Current inheritable CSS styles\r\n     */\r\n    exec(\r\n        html: string,\r\n        convertCssOnly?: boolean,\r\n        preserveFragmentOnly?: boolean,\r\n        currentStyles?: StringMap\r\n    ): string {\r\n        let doc = htmlToDom(html, preserveFragmentOnly);\r\n        if (doc) {\r\n            this.convertGlobalCssToInlineCss(doc);\r\n            if (!convertCssOnly) {\r\n                this.sanitize(doc.body, currentStyles);\r\n            }\r\n        }\r\n        return (doc && doc.body && doc.body.innerHTML) || '';\r\n    }\r\n\r\n    sanitize(rootNode: HTMLElement, currentStyles?: StringMap) {\r\n        if (!rootNode) {\r\n            return '';\r\n        }\r\n        currentStyles = cloneObject(currentStyles, getInheritableStyles(null));\r\n        this.processNode(rootNode, currentStyles, {});\r\n    }\r\n\r\n    convertGlobalCssToInlineCss(rootNode: HTMLDocument) {\r\n        let styleNodes = toArray(rootNode.querySelectorAll('style'));\r\n        let styleSheets = this.additionalGlobalStyleNodes\r\n            .reverse()\r\n            .map(node => node.sheet as CSSStyleSheet)\r\n            .concat(styleNodes.map(node => node.sheet as CSSStyleSheet).reverse())\r\n            .filter(sheet => sheet);\r\n        for (let styleSheet of styleSheets) {\r\n            for (let j = styleSheet.cssRules.length - 1; j >= 0; j--) {\r\n                // Skip any none-style rule, i.e. @page\r\n                let styleRule = styleSheet.cssRules[j] as CSSStyleRule;\r\n                let text = styleRule && styleRule.style ? styleRule.style.cssText : null;\r\n                if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {\r\n                    continue;\r\n                }\r\n                // Make sure the selector is not empty\r\n                for (let selector of styleRule.selectorText.split(',')) {\r\n                    if (!selector || !selector.trim() || selector.indexOf(':') >= 0) {\r\n                        continue;\r\n                    }\r\n                    let nodes = toArray(rootNode.querySelectorAll(selector));\r\n                    // Always put existing styles after so that they have higher priority\r\n                    // Which means if both global style and inline style apply to the same element,\r\n                    // inline style will have higher priority\r\n                    nodes.forEach(node =>\r\n                        node.setAttribute('style', text + (node.getAttribute('style') || ''))\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        styleNodes.forEach(node => {\r\n            if (node.parentNode) {\r\n                node.parentNode.removeChild(node);\r\n            }\r\n        });\r\n    }\r\n\r\n    private processNode(node: Node, currentStyle: StringMap, context: Object) {\r\n        let nodeType = node.nodeType;\r\n        let isElement = nodeType == Node.ELEMENT_NODE;\r\n        let isText = nodeType == Node.TEXT_NODE;\r\n        let element = <HTMLElement>node;\r\n        let tag = isElement ? element.tagName.toUpperCase() : '';\r\n\r\n        if (\r\n            (isElement && !this.allowElement(element, tag, context)) ||\r\n            (isText && /^[\\r\\n]*$/g.test(node.nodeValue) && !currentStyle.insidePRE) ||\r\n            (!isElement && !isText)\r\n        ) {\r\n            node.parentNode.removeChild(node);\r\n        } else if (\r\n            isText &&\r\n            !this.allowPreserveWhiteSpace &&\r\n            currentStyle['white-space'] == 'pre'\r\n        ) {\r\n            node.nodeValue = node.nodeValue.replace(/^ /gm, '\\u00A0').replace(/ {2}/g, ' \\u00A0');\r\n        } else if (isElement) {\r\n            let thisStyle = cloneObject(currentStyle);\r\n            this.processAttributes(element, context);\r\n            this.processCss(element, tag, thisStyle, context);\r\n\r\n            // Special handling for PRE tag, need to preserve \\r\\n inside PRE\r\n            if (tag == 'PRE') {\r\n                thisStyle.insidePRE = 'true';\r\n            }\r\n\r\n            let child: Node = element.firstChild;\r\n            let next: Node;\r\n            for (; child; child = next) {\r\n                next = child.nextSibling;\r\n                this.processNode(child, thisStyle, context);\r\n            }\r\n        }\r\n    }\r\n\r\n    private processCss(element: HTMLElement, tag: string, thisStyle: StringMap, context: Object) {\r\n        let styleNode = element.getAttributeNode('style');\r\n        if (!styleNode) {\r\n            return;\r\n        }\r\n\r\n        let source = styleNode.value.split(';');\r\n        let result = source.filter(style => {\r\n            let pair: string[];\r\n\r\n            if (!style || style.trim() == '' || (pair = style.split(':')).length != 2) {\r\n                return false;\r\n            }\r\n\r\n            let name = pair[0].trim().toLowerCase();\r\n            let value = pair[1].trim().toLowerCase();\r\n            let callback = this.styleCallbacks[name];\r\n            let isInheritable = thisStyle[name] != undefined;\r\n            let keep =\r\n                (!callback || callback(value, element, context)) &&\r\n                value != 'inherit' &&\r\n                value.indexOf('expression') < 0 &&\r\n                name.substr(0, 1) != '-' &&\r\n                this.defaultStyleValues[name] != value &&\r\n                ((isInheritable && value != thisStyle[name]) ||\r\n                    (!isInheritable && value != 'initial' && value != 'normal'));\r\n            if (keep && isInheritable) {\r\n                thisStyle[name] = value;\r\n            }\r\n            return keep && (this.allowPreserveWhiteSpace || name != 'white-space');\r\n        });\r\n\r\n        if (source.length != result.length) {\r\n            if (result.length > 0) {\r\n                element.setAttribute('style', result.map(s => s.trim()).join('; '));\r\n            } else {\r\n                element.removeAttribute('style');\r\n            }\r\n        }\r\n    }\r\n\r\n    private processAttributes(element: HTMLElement, context: Object) {\r\n        for (let i = element.attributes.length - 1; i >= 0; i--) {\r\n            let attribute = element.attributes[i];\r\n            let name = attribute.name.toLowerCase().trim();\r\n            let value = attribute.value;\r\n            let callback = this.attributeCallbacks[name];\r\n\r\n            if (callback) {\r\n                value = callback(value, element, context);\r\n            } else if (this.allowedAttributes.indexOf(name) < 0) {\r\n                value = null;\r\n            }\r\n\r\n            if (\r\n                value === null ||\r\n                value === undefined ||\r\n                value.toLowerCase().indexOf('script:') >= 0\r\n            ) {\r\n                element.removeAttribute(name);\r\n            } else {\r\n                attribute.value = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    private allowElement(element: HTMLElement, tag: string, context: Object): boolean {\r\n        let callback = this.elementCallbacks[tag];\r\n        return callback\r\n            ? callback(element, context)\r\n            : this.allowedTags.indexOf(tag) >= 0 || tag.indexOf(':') > 0;\r\n    }\r\n}\r\n\r\nfunction toArray<T extends Node>(list: NodeListOf<T>): T[] {\r\n    return [].slice.call(list) as T[];\r\n}\r\n","import cloneObject from './cloneObject';\r\nimport { StringMap, StyleCallbackMap } from '../types/maps';\r\n\r\nconst ALLOWED_HTML_TAGS = (\r\n    'BODY,H1,H2,H3,H4,H5,H6,FORM,P,BR,NOBR,HR,ACRONYM,ABBR,ADDRESS,B,' +\r\n    'BDI,BDO,BIG,BLOCKQUOTE,CENTER,CITE,CODE,DEL,DFN,EM,FONT,I,INS,KBD,MARK,METER,PRE,PROGRESS,' +\r\n    'Q,RP,RT,RUBY,S,SAMP,SMALL,STRIKE,STRONG,SUB,SUP,TEMPLATE,TIME,TT,U,VAR,WBR,XMP,INPUT,TEXTAREA,' +\r\n    'BUTTON,SELECT,OPTGROUP,OPTION,LABEL,FIELDSET,LEGEND,DATALIST,OUTPUT,IMG,MAP,AREA,CANVAS,FIGCAPTION,' +\r\n    'FIGURE,PICTURE,A,NAV,UL,OL,LI,DIR,UL,DL,DT,DD,MENU,MENUITEM,TABLE,CAPTION,TH,TR,TD,THEAD,TBODY,' +\r\n    'TFOOT,COL,COLGROUP,DIV,SPAN,HEADER,FOOTER,MAIN,SECTION,ARTICLE,ASIDE,DETAILS,DIALOG,SUMMARY,DATA'\r\n).split(',');\r\n\r\nconst ALLOWED_HTML_ATTRIBUTES = (\r\n    'accept,align,alt,checked,cite,color,cols,colspan,contextmenu,' +\r\n    'coords,datetime,default,dir,dirname,disabled,download,face,headers,height,hidden,high,href,' +\r\n    'hreflang,ismap,kind,label,lang,list,low,max,maxlength,media,min,multiple,open,optimum,pattern,' +\r\n    'placeholder,readonly,rel,required,reversed,rows,rowspan,scope,selected,shape,size,sizes,span,' +\r\n    'spellcheck,src,srclang,srcset,start,step,style,tabindex,target,title,translate,type,usemap,value,' +\r\n    'width,wrap'\r\n).split(',');\r\n\r\nconst DEFAULT_STYLE_VALUES: { [name: string]: string } = {\r\n    'background-color': 'transparent',\r\n    'border-bottom-color': 'rgb(0, 0, 0)',\r\n    'border-bottom-style': 'none',\r\n    'border-bottom-width': '0px',\r\n    'border-image-outset': '0',\r\n    'border-image-repeat': 'stretch',\r\n    'border-image-slice': '100%',\r\n    'border-image-source': 'none',\r\n    'border-image-width': '1',\r\n    'border-left-color': 'rgb(0, 0, 0)',\r\n    'border-left-style': 'none',\r\n    'border-left-width': '0px',\r\n    'border-right-color': 'rgb(0, 0, 0)',\r\n    'border-right-style': 'none',\r\n    'border-right-width': '0px',\r\n    'border-top-color': 'rgb(0, 0, 0)',\r\n    'border-top-style': 'none',\r\n    'border-top-width': '0px',\r\n    'outline-color': 'transparent',\r\n    'outline-style': 'none',\r\n    'outline-width': '0px',\r\n    overflow: 'visible',\r\n    'text-decoration': 'none',\r\n    '-webkit-text-stroke-width': '0px',\r\n    'word-wrap': 'break-word',\r\n    'margin-left': '0px',\r\n    'margin-right': '0px',\r\n    padding: '0px',\r\n    'padding-top': '0px',\r\n    'padding-left': '0px',\r\n    'padding-right': '0px',\r\n    'padding-bottom': '0px',\r\n    border: '0px',\r\n    'border-top': '0px',\r\n    'border-left': '0px',\r\n    'border-right': '0px',\r\n    'border-bottom': '0px',\r\n    'vertical-align': 'baseline',\r\n    float: 'none',\r\n};\r\n\r\nexport function getAllowedTags(additionalTags: string[]): string[] {\r\n    return unique(ALLOWED_HTML_TAGS.concat(additionalTags || [])).map(tag => tag.toUpperCase());\r\n}\r\n\r\nexport function getAllowedAttributes(additionalAttributes: string[]): string[] {\r\n    return unique(ALLOWED_HTML_ATTRIBUTES.concat(additionalAttributes || [])).map(attr =>\r\n        attr.toLocaleLowerCase()\r\n    );\r\n}\r\n\r\nexport function getDefaultStyleValues(additionalDefaultStyles: StringMap): StringMap {\r\n    let result = cloneObject(DEFAULT_STYLE_VALUES);\r\n    if (additionalDefaultStyles) {\r\n        Object.keys(additionalDefaultStyles).forEach(name => {\r\n            let value = additionalDefaultStyles[name];\r\n            if (value !== null && value !== undefined) {\r\n                result[name] = value;\r\n            } else {\r\n                delete result[name];\r\n            }\r\n        });\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport function getStyleCallbacks(callbacks: StyleCallbackMap): StyleCallbackMap {\r\n    let result = cloneObject(callbacks);\r\n    result.position = result.position || removeValue;\r\n    result.width = result.width || removeWidthForLiAndDiv;\r\n    return result;\r\n}\r\n\r\nfunction removeValue(): null {\r\n    return null;\r\n}\r\n\r\nfunction removeWidthForLiAndDiv(value: string, element: HTMLElement) {\r\n    let tag = element.tagName;\r\n    return !(tag == 'LI' || tag == 'DIV');\r\n}\r\n\r\nfunction unique<T>(array: T[]): T[] {\r\n    return array.filter((value, index, self) => self.indexOf(value) == index);\r\n}\r\n","import { createWordConverter } from './wordConverter';\r\nimport { createWordConverterArguments } from './WordConverterArguments';\r\nimport { HtmlSanitizer } from 'roosterjs-html-sanitizer';\r\nimport { processNodeConvert, processNodesDiscovery } from './converterUtils';\r\n\r\n/** Converts all the Word generated list items in the specified node into standard HTML UL and OL tags */\r\nexport default function convertPastedContentFromWord(doc: HTMLDocument) {\r\n    let sanitizer = new HtmlSanitizer({\r\n        elementCallbacks: {\r\n            ['O:P']: () => false,\r\n        },\r\n        additionalAllowAttributes: ['class'],\r\n    });\r\n    sanitizer.sanitize(doc.body);\r\n\r\n    let wordConverter = createWordConverter();\r\n\r\n    // First find all the nodes that we need to check for list item information\r\n    // This call will return all the p and header elements under the root node.. These are the elements that\r\n    // Word uses a list items, so we'll only process them and avoid walking the whole tree.\r\n    let elements = doc.querySelectorAll('p');\r\n    if (elements.length > 0) {\r\n        wordConverter.wordConverterArgs = createWordConverterArguments(elements);\r\n        if (processNodesDiscovery(wordConverter)) {\r\n            processNodeConvert(wordConverter);\r\n        }\r\n    }\r\n}\r\n","import CustomData, { createCustomData } from './CustomData';\r\nimport WordConverterArguments from './WordConverterArguments';\r\n\r\n/** Processes HTML generated by Word, converting Word Lists into standard HTML UL and OL tags */\r\nexport default interface WordConverter {\r\n    /** Next unique id to be assigned to a list */\r\n    nextUniqueId: number;\r\n\r\n    /** Number of bullets converted */\r\n    numBulletsConverted: number;\r\n\r\n    /** Number of numbering converted */\r\n    numNumberedConverted: number;\r\n\r\n    /** The structure that records the status of the conversion */\r\n    wordConverterArgs: WordConverterArguments;\r\n\r\n    /** Custom data storage for list items */\r\n    customData: CustomData;\r\n}\r\n\r\n/** create an empty WordConverter */\r\nexport function createWordConverter(): WordConverter {\r\n    return {\r\n        nextUniqueId: 1,\r\n        numBulletsConverted: 0,\r\n        numNumberedConverted: 0,\r\n        wordConverterArgs: null,\r\n        customData: createCustomData(),\r\n    };\r\n}\r\n","import LevelLists, { createLevelLists } from './LevelLists';\r\nimport ListItemMetadata from './ListItemMetadata';\r\nimport ListMetadata from './ListMetadata';\r\n\r\n/** Contains the state of the WordConverter when called back after yielding */\r\nexport default interface WordConverterArguments {\r\n    /** The list of element nodes being processed */\r\n    nodes: NodeListOf<HTMLElement>;\r\n\r\n    /** The index of the element currently being processed */\r\n    currentIndex: number;\r\n\r\n    /**\r\n     * Holds the metadata for all the lists we have found\r\n     * key: unique list id, value: list metadata\r\n     */\r\n    lists: { [key: string]: ListMetadata };\r\n\r\n    /**\r\n     * Stores the list item metatada of the items we\r\n     * have found that need to be converted\r\n     */\r\n    listItems: ListItemMetadata[];\r\n\r\n    /**\r\n     * This array holds the list id of the lists we are processing\r\n     * that are next to each other.. This list will be used to determine\r\n     * if list items are next to each other or if they are separated...\r\n     * Separated items are ignored from the conversion\r\n     */\r\n\r\n    currentListIdsByLevels: LevelLists[];\r\n\r\n    /** Remembers the item that was last processed  */\r\n    lastProcessedItem: HTMLElement;\r\n}\r\n\r\n/** create an empty WordConverterArguments */\r\nexport function createWordConverterArguments(\r\n    nodes: NodeListOf<HTMLElement>\r\n): WordConverterArguments {\r\n    return {\r\n        nodes: nodes,\r\n        currentIndex: 0,\r\n        lists: {},\r\n        listItems: [],\r\n        currentListIdsByLevels: [createLevelLists()],\r\n        lastProcessedItem: null,\r\n    };\r\n}\r\n","import ListItemMetadata from './ListItemMetadata';\r\nimport ListMetadata from './ListMetadata';\r\nimport WordConverter from './wordConverter';\r\nimport WordConverterArguments from './WordConverterArguments';\r\nimport { createLevelLists } from './LevelLists';\r\nimport { getObject, setObject } from './CustomData';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/** Word list metadata style name */\r\nconst LOOKUP_DEPTH = 5;\r\n\r\n/** Name for the word list id property in the custom data */\r\nconst UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';\r\n\r\n/** Word list metadata style name */\r\nconst MSO_LIST_STYLE_NAME = 'mso-list';\r\n\r\n/** Regular expression to match line breaks */\r\nconst LINE_BREAKS = /[\\n|\\r]/gi;\r\n\r\n/**\r\n * Handles the pass 1: Discovery\r\n * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.\r\n * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these\r\n * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.\r\n */\r\nexport function processNodesDiscovery(wordConverter: WordConverter): boolean {\r\n    let args = wordConverter.wordConverterArgs;\r\n    while (args.currentIndex < args.nodes.length) {\r\n        let node = args.nodes.item(args.currentIndex);\r\n\r\n        // Try to get the list metadata for the specified node\r\n        let itemMetadata = getListItemMetadata(node);\r\n        if (itemMetadata) {\r\n            let levelInfo =\r\n                args.currentListIdsByLevels[itemMetadata.level - 1] || createLevelLists();\r\n            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;\r\n\r\n            // We need to drop some list information if this is not an item next to another\r\n            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {\r\n                // This list item is not next to the previous one. This means that there is some content in between them\r\n                // so we need to reset our list of list ids per level\r\n                resetCurrentLists(args);\r\n            }\r\n\r\n            // Get the list metadata for the list that will hold this item\r\n            let listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];\r\n            if (!listMetadata) {\r\n                // Get the first item fake bullet.. This will be used later to check what is the right type of list\r\n                let firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\r\n\r\n                // This is a the first item of a list.. We'll create the list metadata using the information\r\n                // we already have from this first item\r\n                listMetadata = {\r\n                    numberOfItems: 0,\r\n                    uniqueListId: wordConverter.nextUniqueId++,\r\n                    firstFakeBullet: firstFakeBullet,\r\n\r\n                    // If the bullet we got is emtpy or not found, we ignore the list out.. this means\r\n                    // that this is not an item we need to convert of that the format doesn't match what\r\n                    // we are expecting\r\n                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,\r\n\r\n                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second\r\n                    // item, we'll perform a better comparasion, but for one item lists, this will be check that will determine the list type\r\n                    tagName: getFakeBulletTagName(firstFakeBullet),\r\n                };\r\n                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;\r\n                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;\r\n            } else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {\r\n                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet\r\n                // items we have an decide if we create ordered or unordered lists based on this.\r\n                // This is the best way we can do this since we cannot read the metadata that Word\r\n                // puts in the head of the HTML...\r\n                let secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\r\n                listMetadata.tagName =\r\n                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';\r\n            }\r\n\r\n            // Set the unique id to the list\r\n            itemMetadata.uniqueListId = listMetadata.uniqueListId;\r\n\r\n            // Check if we need to ignore this list... we'll either know already that we need to ignore\r\n            // it, or we'll know it because the previous list items are not next to this one\r\n            if (\r\n                listMetadata.ignore ||\r\n                (listMetadata.tagName == 'OL' &&\r\n                    listMetadata.numberOfItems > 0 &&\r\n                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)\r\n            ) {\r\n                // We need to ignore this item... and we also need to forget about the lists that\r\n                // are not at the root level\r\n                listMetadata.ignore = true;\r\n                args.currentListIdsByLevels[0].currentUniqueListId = -1;\r\n                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);\r\n            } else {\r\n                // This is an item we don't need to ignore... If added lists deep under this one before\r\n                // we'll drop their ids from the list of ids per level.. this is because this list item\r\n                // breaks the deeper lists.\r\n                if (args.currentListIdsByLevels.length > itemMetadata.level) {\r\n                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(\r\n                        0,\r\n                        itemMetadata.level\r\n                    );\r\n                }\r\n\r\n                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;\r\n\r\n                // Add the list item into the list of items to be processed\r\n                args.listItems.push(itemMetadata);\r\n                listMetadata.numberOfItems++;\r\n            }\r\n\r\n            args.lastProcessedItem = node;\r\n        } else {\r\n            // Here, we know that this is not a list item, but we'll want to check if it is one \"no bullet\" list items...\r\n            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will\r\n            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but\r\n            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips\r\n            // the list conversion thinking that the list items are not together...\r\n            let last = args.lastProcessedItem;\r\n            if (\r\n                last &&\r\n                getRealPreviousSibling(node) == last &&\r\n                node.tagName == last.tagName &&\r\n                node.className == last.className\r\n            ) {\r\n                // Add 2 line breaks and move all the nodes to the last item\r\n                last.appendChild(last.ownerDocument.createElement('br'));\r\n                last.appendChild(last.ownerDocument.createElement('br'));\r\n                while (node.firstChild != null) {\r\n                    last.appendChild(node.firstChild);\r\n                }\r\n\r\n                // Remove the item that we don't need anymore\r\n                node.parentNode.removeChild(node);\r\n            }\r\n        }\r\n\r\n        // Move to the next element are return true if more elements need to be processed\r\n        args.currentIndex++;\r\n    }\r\n\r\n    return args.listItems.length > 0;\r\n}\r\n\r\n/**\r\n * Handles the pass 2: Conversion\r\n * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the\r\n * conversion needed\r\n */\r\nexport function processNodeConvert(wordConverter: WordConverter): boolean {\r\n    let args = wordConverter.wordConverterArgs;\r\n    args.currentIndex = 0;\r\n\r\n    while (args.currentIndex < args.listItems.length) {\r\n        let metadata = args.listItems[args.currentIndex];\r\n        let node = metadata.originalNode;\r\n        let listMetadata = args.lists[metadata.uniqueListId.toString()];\r\n        if (!listMetadata.ignore) {\r\n            // We have a list item that we need to convert, get or create the list\r\n            // that hold this item out\r\n            let list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);\r\n            if (list) {\r\n                // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes\r\n                cleanupListIgnore(node, LOOKUP_DEPTH);\r\n\r\n                // Create a new list item and transfer the children\r\n                let li = node.ownerDocument.createElement('LI');\r\n                while (node.firstChild) {\r\n                    li.appendChild(node.firstChild);\r\n                }\r\n\r\n                // Append the list item into the list\r\n                list.appendChild(li);\r\n\r\n                // Remove the node we just converted\r\n                node.parentNode.removeChild(node);\r\n\r\n                if (listMetadata.tagName == 'UL') {\r\n                    wordConverter.numBulletsConverted++;\r\n                } else {\r\n                    wordConverter.numNumberedConverted++;\r\n                }\r\n            }\r\n        }\r\n\r\n        args.currentIndex++;\r\n    }\r\n\r\n    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;\r\n}\r\n\r\n/**\r\n * Gets or creates the list (UL or OL) that holds this item out based on the\r\n * items content and the specified metadata\r\n */\r\nfunction getOrCreateListForNode(\r\n    wordConverter: WordConverter,\r\n    node: HTMLElement,\r\n    metadata: ListItemMetadata,\r\n    listMetadata: ListMetadata\r\n): Node {\r\n    // First get the last list next to this node under the specified level. This code\r\n    // path will return the list or will create lists if needed\r\n    let list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);\r\n\r\n    // Here use the unique list ID to detect if we have the right list...\r\n    // it is possible to have 2 different lists next to each other with different formats, so\r\n    // we want to detect this an create separate lists for those cases\r\n    let listId = getObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA);\r\n\r\n    // If we have a list with and ID, but the ID is different than the ID for this list item, this\r\n    // is a completely new list, so we'll append a new list for that\r\n    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {\r\n        let newList = node.ownerDocument.createElement(listMetadata.tagName);\r\n        list.parentNode.insertBefore(newList, list.nextSibling);\r\n        list = newList;\r\n    }\r\n\r\n    // Set the list id into the custom data\r\n    setObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA, metadata.uniqueListId);\r\n\r\n    // This call will convert the list if needed to the right type of list required. This can happen\r\n    // on the cases where the first list item for this list is located after a deeper list. for that\r\n    // case, we will have created a UL for it, and we may need to convert it\r\n    return convertListIfNeeded(wordConverter, list, listMetadata);\r\n}\r\n\r\n/**\r\n * Converts the list between UL and OL if needed, by using the fake bullet and\r\n * information already stored in the list itself\r\n */\r\nfunction convertListIfNeeded(\r\n    wordConverter: WordConverter,\r\n    list: Node,\r\n    listMetadata: ListMetadata\r\n): Node {\r\n    // Check if we need to convert the list out\r\n    if (listMetadata.tagName != getTagOfNode(list)) {\r\n        // We have the wrong list type.. convert it, set the id again and tranfer all the childs\r\n        let newList = list.ownerDocument.createElement(listMetadata.tagName);\r\n        setObject(\r\n            wordConverter.customData,\r\n            newList,\r\n            UNIQUE_LIST_ID_CUSTOM_DATA,\r\n            getObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA)\r\n        );\r\n        while (list.firstChild) {\r\n            newList.appendChild(list.firstChild);\r\n        }\r\n        list.parentNode.insertBefore(newList, list);\r\n        list.parentNode.removeChild(list);\r\n        list = newList;\r\n    }\r\n\r\n    return list;\r\n}\r\n\r\n/**\r\n * Gets or creates the specified list\r\n */\r\nfunction recurringGetOrCreateListAtNode(\r\n    node: HTMLElement,\r\n    level: number,\r\n    listMetadata: ListMetadata\r\n): Node {\r\n    let parent: Node = null;\r\n    let possibleList: Node;\r\n    if (level == 1) {\r\n        // Root case, we'll check if the list is the previous sibling of the node\r\n        possibleList = getRealPreviousSibling(node);\r\n    } else {\r\n        // If we get here, we are looking for level 2 or deeper... get the upper list\r\n        // and check if the last element is a list\r\n        parent = recurringGetOrCreateListAtNode(node, level - 1, null);\r\n        possibleList = parent.lastChild;\r\n    }\r\n\r\n    // Check the element that we got and verify that it is a list\r\n    if (possibleList && possibleList.nodeType == NodeType.Element) {\r\n        let tag = getTagOfNode(possibleList);\r\n        if (tag == 'UL' || tag == 'OL') {\r\n            // We have a list.. use it\r\n            return possibleList;\r\n        }\r\n    }\r\n\r\n    // If we get here, it means we don't have a list and we need to create one\r\n    // this code path will always create new lists as UL lists\r\n    let newList = node.ownerDocument.createElement(listMetadata ? listMetadata.tagName : 'UL');\r\n    if (level == 1) {\r\n        // For level 1, we'll insert the list beofre the node\r\n        node.parentNode.insertBefore(newList, node);\r\n    } else {\r\n        // Any level 2 or above, we insert the list as the last\r\n        // child of the upper level list\r\n        parent.appendChild(newList);\r\n    }\r\n\r\n    return newList;\r\n}\r\n\r\n/**\r\n * Cleans up the node children by removing the childs marked as mso-list: Ignore.\r\n * This nodes hold the fake bullet information that Word puts in and when\r\n * conversion is happening, we want to get rid of these elements\r\n */\r\nfunction cleanupListIgnore(node: Node, levels: number) {\r\n    let nodesToRemove: Node[] = [];\r\n\r\n    for (let child: Node = node.firstChild; child; child = child.nextSibling) {\r\n        // Clean up the item internally first if we need to based on the number of levels\r\n        if (child.nodeType == NodeType.Element && levels > 1) {\r\n            cleanupListIgnore(child, levels - 1);\r\n        }\r\n\r\n        // Try to convert word comments into ignore elements if we haven't done so for this element\r\n        child = fixWordListComments(child, true /*removeComments*/);\r\n\r\n        // Check if we can remove this item out\r\n        if (isEmptySpan(child) || isIgnoreNode(child)) {\r\n            nodesToRemove.push(child);\r\n        }\r\n    }\r\n\r\n    nodesToRemove.forEach(child => node.removeChild(child));\r\n}\r\n\r\n/**\r\n * Reads the word list metadada out of the specified node. If the node\r\n * is not a Word list item, it returns null.\r\n */\r\nfunction getListItemMetadata(node: HTMLElement): ListItemMetadata {\r\n    if (node.nodeType == NodeType.Element) {\r\n        let listatt = getStyleValue(node, MSO_LIST_STYLE_NAME);\r\n        if (listatt && listatt.length > 0) {\r\n            try {\r\n                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0\r\n                // Where:\r\n                // (0) List identified for the metadata in the <head> of the document. We cannot read the <head> metada\r\n                // (1) Level of the list. This also maps to the <head> metadata that we cannot read, but\r\n                // for almost all cases, it maps to the list identation (or level). We'll use it as the\r\n                // list indentation value\r\n                // (2) Contains a specific list identifier.\r\n                // Example value: \"l0 level1 lfo1\"\r\n                let listprops = listatt.split(' ');\r\n                if (listprops.length == 3) {\r\n                    return <ListItemMetadata>{\r\n                        level: parseInt(listprops[1].substr('level'.length)),\r\n                        wordListId: listatt,\r\n                        originalNode: node,\r\n                        uniqueListId: 0,\r\n                    };\r\n                }\r\n            } catch (e) {}\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction isFakeBullet(fakeBullet: string): boolean {\r\n    return ['o', '·', '§', '-'].indexOf(fakeBullet) >= 0;\r\n}\r\n\r\n/** Given a fake bullet text, returns the type of list that should be used for it */\r\nfunction getFakeBulletTagName(fakeBullet: string): string {\r\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\r\n}\r\n\r\n/**\r\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\r\n * a bullet string. If not found, it returns null...\r\n */\r\nfunction getFakeBulletText(node: Node, levels: number): string {\r\n    // Word uses the following format for their bullets:\r\n    // <p style=\"mso-list:l1 level1 lfo2\">\r\n    // <span style=\"...\">\r\n    // <span style=\"mso-list:Ignore\">1.<span style=\"...\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>\r\n    // </span>\r\n    // Content here...\r\n    // </p>\r\n    //\r\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\r\n    // text or image node will be the fake bullet we are looking for\r\n    let result: string = null;\r\n    let child: Node = node.firstChild;\r\n    while (!result && child) {\r\n        // First, check if we need to convert the Word list comments into real elements\r\n        child = fixWordListComments(child, true /*removeComments*/);\r\n\r\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\r\n        if (isIgnoreNode(child)) {\r\n            // Yes... this is the node that holds either the text or image data\r\n            result = child.textContent.trim();\r\n\r\n            // This is the case for image case\r\n            if (result.length == 0) {\r\n                result = 'o';\r\n            }\r\n        } else if (child.nodeType == NodeType.Element && levels > 1) {\r\n            // If this is an element and we are not in the last level, try to get the fake bullet\r\n            // out of the child\r\n            result = getFakeBulletText(child, levels - 1);\r\n        }\r\n\r\n        child = child.nextSibling;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * If the specified element is a Word List comments, this code verifies and fixes\r\n * the markup when needed to ensure that Chrome bullet conversions work as expected\r\n * -----\r\n * We'll convert <!--[if !supportLists]--> and <!--[endif]--> comments into\r\n * <span style=\"mso-list:Ignore\"></span>... Chrome has a bug where it drops the\r\n * styles of the span, but we'll use these comments to recreate them out\r\n */\r\nfunction fixWordListComments(child: Node, removeComments: boolean): Node {\r\n    if (child.nodeType == NodeType.Comment) {\r\n        let value = (child as Comment).data;\r\n        if (value && value.trim().toLowerCase() == '[if !supportlists]') {\r\n            // We have a list ignore start, find the end.. We know is not more than\r\n            // 3 nodes away, so we'll optimize our checks\r\n            let nextElement = child;\r\n            let endComment: Node = null;\r\n            for (let j = 0; j < 4; j++) {\r\n                nextElement = getRealNextSibling(nextElement);\r\n                if (!nextElement) {\r\n                    break;\r\n                }\r\n                if (nextElement.nodeType == NodeType.Comment) {\r\n                    value = (nextElement as Comment).data;\r\n                    if (value && value.trim().toLowerCase() == '[endif]') {\r\n                        endComment = nextElement;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if we found the end node, wrap everything out\r\n            if (endComment) {\r\n                let newSpan = child.ownerDocument.createElement('span');\r\n                newSpan.setAttribute('style', 'mso-list: ignore');\r\n                nextElement = getRealNextSibling(child);\r\n                while (nextElement != endComment) {\r\n                    nextElement = nextElement.nextSibling as HTMLElement;\r\n                    newSpan.appendChild(nextElement.previousSibling);\r\n                }\r\n\r\n                // Insert the element out and use that one as the current child\r\n                endComment.parentNode.insertBefore(newSpan, endComment);\r\n\r\n                // Remove the comments out if the call specified it out\r\n                if (removeComments) {\r\n                    child.parentNode.removeChild(child);\r\n                    endComment.parentNode.removeChild(endComment);\r\n                }\r\n\r\n                // Last, make sure we return the new element out instead of the comment\r\n                child = newSpan;\r\n            }\r\n        }\r\n    }\r\n\r\n    return child;\r\n}\r\n\r\n/** Finds the real previous sibling, ignoring emtpy text nodes */\r\nfunction getRealPreviousSibling(node: Node): Node {\r\n    let prevSibling = node;\r\n    do {\r\n        prevSibling = prevSibling.previousSibling;\r\n    } while (prevSibling && isEmptyTextNode(prevSibling));\r\n    return prevSibling;\r\n}\r\n\r\n/** Finds the real next sibling, ignoring empty text nodes */\r\nfunction getRealNextSibling(node: Node): Node {\r\n    let nextSibling = node;\r\n    do {\r\n        nextSibling = nextSibling.nextSibling;\r\n    } while (nextSibling && isEmptyTextNode(nextSibling));\r\n\r\n    return nextSibling;\r\n}\r\n\r\n/**\r\n * Checks if the specified node is marked as a mso-list: Ignore. These\r\n * nodes need to be ignored when a list item is converted into standard\r\n * HTML lists\r\n */\r\nfunction isIgnoreNode(node: Node): boolean {\r\n    if (node.nodeType == NodeType.Element) {\r\n        let listatt = getStyleValue(node as HTMLElement, MSO_LIST_STYLE_NAME);\r\n        if (listatt && listatt.length > 0 && listatt.trim().toLowerCase() == 'ignore') {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/** Checks if the specified node is an empty span. */\r\nfunction isEmptySpan(node: Node): boolean {\r\n    return getTagOfNode(node) == 'SPAN' && !node.firstChild;\r\n}\r\n\r\n/** Reads the specified style value from the node */\r\nfunction getStyleValue(node: HTMLElement, styleName: string): string {\r\n    // Word uses non-standard names for the metadata that puts in the style of the element...\r\n    // Most browsers will not provide the information for those unstandard values throug the node.style\r\n    // property, so the only reliable way to read them is to get the attribute directly and do\r\n    // the required parsing..\r\n    let textStyle = node.getAttribute('style');\r\n    if (textStyle && textStyle.length > 0 && textStyle.indexOf(styleName) >= 0) {\r\n        // Split all the CSS name: value pairs\r\n        let inStyles = textStyle.split(';');\r\n        for (let i = 0; i < inStyles.length; i++) {\r\n            // Split the name and value\r\n            let nvpair = inStyles[i].split(':');\r\n            if (nvpair.length == 2 && nvpair[0].trim() == styleName) {\r\n                return nvpair[1].trim();\r\n            }\r\n        }\r\n    }\r\n\r\n    // As a backup mechanism, we'll still try to get the value from the style object\r\n    // Dictionary styles = (Dictionary)(object)node.Style;\r\n    // return (string)styles[styleName];\r\n    return null;\r\n}\r\n\r\n/** Checks if the node is an empty text node that can be ignored */\r\nfunction isEmptyTextNode(node: Node): boolean {\r\n    // No node is empty\r\n    if (!node) {\r\n        return true;\r\n    }\r\n\r\n    // Empty text node is empty\r\n    if (node.nodeType == NodeType.Text) {\r\n        let value = node.nodeValue;\r\n        value = value.replace(LINE_BREAKS, '');\r\n        return value.trim().length == 0;\r\n    }\r\n\r\n    // Span or Font with an empty child node is empty\r\n    let tagName = getTagOfNode(node);\r\n    if (node.firstChild == node.lastChild && (tagName == 'SPAN' || tagName == 'FONT')) {\r\n        return isEmptyTextNode(node.firstChild);\r\n    }\r\n\r\n    // If not found, then this is not empty\r\n    return false;\r\n}\r\n\r\n/** Resets the list */\r\nfunction resetCurrentLists(args: WordConverterArguments) {\r\n    for (let i = 0; i < args.currentListIdsByLevels.length; i++) {\r\n        let ll = args.currentListIdsByLevels[i];\r\n        if (ll) {\r\n            ll.currentUniqueListId = -1;\r\n        }\r\n    }\r\n}\r\n","import { Browser, matchLink } from 'roosterjs-editor-dom';\r\n\r\nvar ZERO_WIDTH_SPACE = '&#8203;';\r\n\r\n/**\r\n * Convert plain to HTML\r\n * @param text The plain text to convert\r\n * @param parseLink True to parse hyperlink from the text and generate HTML A tag, otherwise false\r\n * @returns HTML string to present the input text\r\n */\r\nexport default function textToHtml(text: string, parseLink?: boolean): string {\r\n    let linkData = parseLink && matchLink(text);\r\n    text = (text || '')\r\n        .replace(/&/g, '&amp;')\r\n        .replace(/</g, '&lt;')\r\n        .replace(/>/g, '&gt;')\r\n        .replace(/'/g, '&#39;')\r\n        .replace(/\"/g, '&quot;')\r\n        .replace(/^ /gm, '&nbsp;')\r\n        .replace(/\\r/g, '');\r\n    let lines = text.split('\\n');\r\n    if (lines.length == 2) {\r\n        text = `<span>${lines[0]}<br></span><span>${lines[1]}</span>`;\r\n    } else if (lines.length > 2) {\r\n        text = '';\r\n        let lineEnd = Browser.isIEOrEdge ? ZERO_WIDTH_SPACE : '<br>';\r\n        lines.forEach((line, i) => {\r\n            if (i == 0) {\r\n                text += `<span>${line}<br></span>`;\r\n            } else if (i == lines.length - 1) {\r\n                text += `<span>${line}</span>`;\r\n            } else {\r\n                text += `<div>${line}${lineEnd}</div>`;\r\n            }\r\n        });\r\n    }\r\n    text = text.replace(/\\s\\s/g, ' &nbsp;');\r\n    return linkData ? `<a href=\"${linkData.normalizedUrl}\">${text}</a>` : text;\r\n}\r\n","import { applyFormat, wrap } from 'roosterjs-editor-dom';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport {\r\n    ChangeSource,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    ContentPosition,\r\n    ContentChangedEvent,\r\n    ExtractContentEvent,\r\n    DefaultFormat,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst WATERMARK_SPAN_ID = '_rooster_watermarkSpan';\r\nconst WATERMARK_REGEX = new RegExp(\r\n    `<span[^>]*id=['\"]?${WATERMARK_SPAN_ID}['\"]?[^>]*>[^<]*</span>`,\r\n    'ig'\r\n);\r\n\r\n/**\r\n * A watermark plugin to manage watermark string for roosterjs\r\n */\r\nclass Watermark implements EditorPlugin {\r\n    private editor: Editor;\r\n    private isWatermarkShowing: boolean;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Create an instance of Watermark plugin\r\n     * @param watermark The watermark string\r\n     */\r\n    constructor(private watermark: string, private format?: DefaultFormat) {\r\n        this.format = this.format || {\r\n            fontSize: '14px',\r\n            textColor: '#aaa',\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Watermark';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.showHideWatermark(false /*ignoreCachedState*/);\r\n        this.disposer = this.editor.addDomEventHandler({\r\n            focus: this.handleWatermark,\r\n            blur: this.handleWatermark,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.hideWatermark();\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.ContentChanged) {\r\n            // When content is changed from setContent() API, current cached state\r\n            // may not be accurate, so we ignore it\r\n            this.showHideWatermark((<ContentChangedEvent>event).source == ChangeSource.SetContent);\r\n        } else if (event.eventType == PluginEventType.ExtractContent && this.isWatermarkShowing) {\r\n            this.removeWartermarkFromHtml(event as ExtractContentEvent);\r\n        }\r\n    }\r\n\r\n    private handleWatermark = () => {\r\n        this.showHideWatermark(false /*ignoreCachedState*/);\r\n    };\r\n\r\n    private showHideWatermark(ignoreCachedState: boolean) {\r\n        if (this.editor.hasFocus() && (ignoreCachedState || this.isWatermarkShowing)) {\r\n            this.hideWatermark();\r\n            this.editor.focus();\r\n        } else if (\r\n            !this.editor.hasFocus() &&\r\n            (ignoreCachedState || !this.isWatermarkShowing) &&\r\n            this.editor.isEmpty(true /*trim*/)\r\n        ) {\r\n            this.showWatermark();\r\n        }\r\n    }\r\n\r\n    private showWatermark() {\r\n        let document = this.editor.getDocument();\r\n        let watermarkNode = wrap(\r\n            document.createTextNode(this.watermark),\r\n            `<span id=\"${WATERMARK_SPAN_ID}\"></span>`\r\n        ) as HTMLElement;\r\n        applyFormat(watermarkNode, this.format);\r\n        this.editor.insertNode(watermarkNode, {\r\n            position: ContentPosition.Begin,\r\n            updateCursor: false,\r\n            replaceSelection: false,\r\n            insertOnNewLine: false,\r\n        });\r\n        this.isWatermarkShowing = true;\r\n    }\r\n\r\n    private hideWatermark() {\r\n        this.editor.queryElements(`span[id=\"${WATERMARK_SPAN_ID}\"]`, span =>\r\n            this.editor.deleteNode(span)\r\n        );\r\n        this.isWatermarkShowing = false;\r\n    }\r\n\r\n    private removeWartermarkFromHtml(event: ExtractContentEvent) {\r\n        let content = event.content;\r\n        content = content.replace(WATERMARK_REGEX, '');\r\n        event.content = content;\r\n    }\r\n}\r\n\r\nexport default Watermark;\r\n","import { contains, fromHtml, getComputedStyle, VTable } from 'roosterjs-editor-dom';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport {\r\n    ContentPosition,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginMouseEvent,\r\n    ChangeSource,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst TABLE_RESIZE_HANDLE_KEY = 'TABLE_RESIZE_HANDLE';\r\nconst HANDLE_WIDTH = 6;\r\nconst CONTAINER_HTML = `<div style=\"position: fixed; cursor: col-resize; width: ${HANDLE_WIDTH}px; border: solid 0 #C6C6C6;\"></div>`;\r\n\r\nexport default class TableResize implements EditorPlugin {\r\n    private editor: Editor;\r\n    private onMouseOverDisposer: () => void;\r\n    private td: HTMLTableCellElement;\r\n    private pageX = -1;\r\n    private initialPageX: number;\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.onMouseOverDisposer = this.editor.addDomEventHandler('mouseover', this.onMouseOver);\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'TableResize';\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.detachMouseEvents();\r\n        this.editor = null;\r\n        this.onMouseOverDisposer();\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (\r\n            this.td &&\r\n            (event.eventType == PluginEventType.KeyDown ||\r\n                event.eventType == PluginEventType.ContentChanged ||\r\n                (event.eventType == PluginEventType.MouseDown && !this.clickIntoCurrentTd(event)))\r\n        ) {\r\n            this.td = null;\r\n            this.calcAndShowHandle();\r\n        }\r\n    }\r\n\r\n    private clickIntoCurrentTd(event: PluginMouseEvent) {\r\n        let mouseEvent = event.rawEvent;\r\n        let target = mouseEvent.target;\r\n        return (\r\n            target instanceof Node &&\r\n            contains(this.td, <Node>target, true /*treatSameNodeAsContain*/)\r\n        );\r\n    }\r\n\r\n    private onMouseOver = (e: MouseEvent) => {\r\n        let node = <HTMLElement>(e.srcElement || e.target);\r\n        if (\r\n            this.pageX < 0 &&\r\n            node &&\r\n            (node.tagName == 'TD' || node.tagName == 'TH') &&\r\n            node != this.td\r\n        ) {\r\n            this.td = <HTMLTableCellElement>node;\r\n            this.calcAndShowHandle();\r\n        }\r\n    };\r\n\r\n    private calcAndShowHandle() {\r\n        if (this.td) {\r\n            let tr = <HTMLTableRowElement>this.editor.getElementAtCursor('TR', this.td);\r\n            let table = <HTMLTableElement>this.editor.getElementAtCursor('TABLE', tr);\r\n            if (tr && table) {\r\n                let [left, top] = this.getPosition(table);\r\n                let handle = this.getResizeHandle();\r\n\r\n                left +=\r\n                    this.td.offsetLeft +\r\n                    (this.isRtl(table) ? 0 : this.td.offsetWidth - HANDLE_WIDTH);\r\n                handle.style.display = '';\r\n                handle.style.top = top + 'px';\r\n                handle.style.height = table.offsetHeight + 'px';\r\n                handle.style.left = left + 'px';\r\n            }\r\n        } else {\r\n            this.getResizeHandle().style.display = 'none';\r\n        }\r\n    }\r\n\r\n    private adjustHandle(pageX: number) {\r\n        let handle = this.getResizeHandle();\r\n        handle.style.left = handle.offsetLeft + pageX - this.pageX + 'px';\r\n        this.pageX = pageX;\r\n    }\r\n\r\n    private getPosition(e: HTMLElement): [number, number] {\r\n        let parent = <HTMLElement>e.offsetParent;\r\n        let [left, top] = parent ? this.getPosition(parent) : [0, 0];\r\n        return [left + e.offsetLeft - e.scrollLeft, top + e.offsetTop - e.scrollTop];\r\n    }\r\n\r\n    private getResizeHandle() {\r\n        return this.editor.getCustomData(\r\n            TABLE_RESIZE_HANDLE_KEY,\r\n            () => {\r\n                let document = this.editor.getDocument();\r\n                let handle = fromHtml(CONTAINER_HTML, document)[0] as HTMLElement;\r\n                this.editor.insertNode(handle, {\r\n                    position: ContentPosition.Outside,\r\n                    updateCursor: false,\r\n                    replaceSelection: false,\r\n                    insertOnNewLine: false,\r\n                });\r\n                handle.addEventListener('mousedown', this.onMouseDown);\r\n                return handle;\r\n            },\r\n            handle => {\r\n                handle.removeEventListener('mousedown', this.onMouseDown);\r\n                handle.parentNode.removeChild(handle);\r\n            }\r\n        );\r\n    }\r\n\r\n    private cancelEvent(e: MouseEvent) {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    }\r\n\r\n    private onMouseDown = (e: MouseEvent) => {\r\n        if (!this.editor || this.editor.isDisposed()) {\r\n            return;\r\n        }\r\n\r\n        this.pageX = e.pageX;\r\n        this.initialPageX = e.pageX;\r\n        this.attachMouseEvents();\r\n\r\n        let handle = this.getResizeHandle();\r\n        handle.style.borderWidth = '0 1px';\r\n\r\n        this.cancelEvent(e);\r\n    };\r\n\r\n    private onMouseMove = (e: MouseEvent) => {\r\n        this.adjustHandle(e.pageX);\r\n        this.cancelEvent(e);\r\n    };\r\n\r\n    private onMouseUp = (e: MouseEvent) => {\r\n        this.detachMouseEvents();\r\n\r\n        let handle = this.getResizeHandle();\r\n        handle.style.borderWidth = '0';\r\n\r\n        let table = this.editor.getElementAtCursor('TABLE', this.td) as HTMLTableElement;\r\n        let cellPadding = parseInt(table.cellPadding);\r\n        cellPadding = isNaN(cellPadding) ? 0 : cellPadding;\r\n\r\n        if (e.pageX != this.initialPageX) {\r\n            let newWidth =\r\n                this.td.clientWidth -\r\n                cellPadding * 2 +\r\n                (e.pageX - this.initialPageX) * (this.isRtl(table) ? -1 : 1);\r\n            this.editor.addUndoSnapshot((start, end) => {\r\n                this.setTableColumnWidth(newWidth + 'px');\r\n                this.editor.select(start, end);\r\n            }, ChangeSource.Format);\r\n        }\r\n\r\n        this.pageX = -1;\r\n        this.calcAndShowHandle();\r\n        this.editor.focus();\r\n        this.cancelEvent(e);\r\n    };\r\n\r\n    private attachMouseEvents() {\r\n        if (this.editor && !this.editor.isDisposed()) {\r\n            let document = this.editor.getDocument();\r\n            document.addEventListener('mousemove', this.onMouseMove, true);\r\n            document.addEventListener('mouseup', this.onMouseUp, true);\r\n        }\r\n    }\r\n\r\n    private detachMouseEvents() {\r\n        if (this.editor && !this.editor.isDisposed()) {\r\n            let document = this.editor.getDocument();\r\n            document.removeEventListener('mousemove', this.onMouseMove, true);\r\n            document.removeEventListener('mouseup', this.onMouseUp, true);\r\n        }\r\n    }\r\n\r\n    private setTableColumnWidth(width: string) {\r\n        let vtable = new VTable(this.td);\r\n        vtable.table.style.width = '';\r\n        vtable.table.width = '';\r\n        vtable.forEachCellOfCurrentColumn(cell => {\r\n            if (cell.td) {\r\n                cell.td.style.width = cell.td == this.td ? width : '';\r\n            }\r\n        });\r\n        vtable.writeBack();\r\n        return this.editor.contains(this.td) ? this.td : vtable.getCurrentTd();\r\n    }\r\n\r\n    private isRtl(element: HTMLElement) {\r\n        return getComputedStyle(element, 'direction') == 'rtl';\r\n    }\r\n}\r\n","export { default as ImageResize } from './ImageResize';\r\n","import { contains, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport {\r\n    ContentChangedEvent,\r\n    ChangeSource,\r\n    NodeType,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    ExtractContentEvent,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst BEGIN_TAG = 'RoosterJsImageResizingBegin';\r\nconst END_TAG = 'RoosterJsImageResizingEnd';\r\nconst EXTRACT_HTML_REGEX = new RegExp(\r\n    `<!--${BEGIN_TAG}-->[\\\\s\\\\S]*(<img\\\\s[^>]+>)[\\\\s\\\\S]*<!--${END_TAG}-->`,\r\n    'gim'\r\n);\r\nconst DELETE_KEYCODE = 46;\r\nconst BACKSPACE_KEYCODE = 8;\r\nconst SHIFT_KEYCODE = 16;\r\nconst CTRL_KEYCODE = 17;\r\nconst ALT_KEYCODE = 18;\r\n\r\nexport default class ImageResize implements EditorPlugin {\r\n    private editor: Editor;\r\n    private startPageX: number;\r\n    private startPageY: number;\r\n    private startWidth: number;\r\n    private startHeight: number;\r\n    private resizeDiv: HTMLElement;\r\n    private direction: string;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Create a new instance of ImageResize\r\n     * @param minWidth Minimum width of image when resize in pixel, default value is 10\r\n     * @param minHeight Minimum height of image when resize in pixel, default value is 10\r\n     * @param selectionBorderColor Color of resize border and handles, default value is #DB626C\r\n     * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false\r\n     * @param resizableImageSelector Selector for picking which image is resizable (e.g. for all images not placeholders), note\r\n     * that the tag must be IMG regardless what the selector is\r\n     */\r\n    constructor(\r\n        private minWidth: number = 10,\r\n        private minHeight: number = 10,\r\n        private selectionBorderColor: string = '#DB626C',\r\n        private forcePreserveRatio: boolean = false,\r\n        private resizableImageSelector: string = 'img'\r\n    ) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'ImageResize';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.disposer = editor.addDomEventHandler({\r\n            dragstart: this.onDragStart,\r\n            blur: this.onBlur,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        if (this.resizeDiv) {\r\n            this.hideResizeHandle();\r\n        }\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(e: PluginEvent) {\r\n        if (e.eventType == PluginEventType.MouseDown) {\r\n            const event = e.rawEvent;\r\n            const target = <HTMLElement>(event.srcElement || event.target);\r\n\r\n            if (getTagOfNode(target) == 'IMG') {\r\n                const parent = target.parentNode as HTMLElement;\r\n                const elements = parent\r\n                    ? ([].slice.call(\r\n                          parent.querySelectorAll(this.resizableImageSelector)\r\n                      ) as HTMLElement[])\r\n                    : [];\r\n                if (elements.indexOf(target) < 0) {\r\n                    return;\r\n                }\r\n\r\n                target.contentEditable = 'false';\r\n                const currentImg = this.getSelectedImage();\r\n                if (currentImg && currentImg != target) {\r\n                    this.hideResizeHandle();\r\n                }\r\n\r\n                if (!this.resizeDiv) {\r\n                    this.showResizeHandle(<HTMLImageElement>target);\r\n                }\r\n            } else if (this.resizeDiv && !contains(this.resizeDiv, target)) {\r\n                this.hideResizeHandle();\r\n            }\r\n        } else if (e.eventType == PluginEventType.KeyDown && this.resizeDiv) {\r\n            const event = e.rawEvent;\r\n            if (event.which == DELETE_KEYCODE || event.which == BACKSPACE_KEYCODE) {\r\n                this.editor.addUndoSnapshot(() => {\r\n                    this.removeResizeDiv(this.resizeDiv);\r\n                });\r\n                this.resizeDiv = null;\r\n                event.preventDefault();\r\n                this.resizeDiv = null;\r\n            } else if (\r\n                event.which != SHIFT_KEYCODE &&\r\n                event.which != CTRL_KEYCODE &&\r\n                event.which != ALT_KEYCODE\r\n            ) {\r\n                this.hideResizeHandle(true /*selectImage*/);\r\n            }\r\n        } else if (\r\n            e.eventType == PluginEventType.ContentChanged &&\r\n            (<ContentChangedEvent>e).source != ChangeSource.ImageResize\r\n        ) {\r\n            this.editor.queryElements('img', this.removeResizeDivIfAny);\r\n            this.resizeDiv = null;\r\n        } else if (e.eventType == PluginEventType.ExtractContent) {\r\n            const event = <ExtractContentEvent>e;\r\n            event.content = this.extractHtml(event.content);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select a given IMG element, show the resize handle\r\n     * @param img The IMG element to select\r\n     */\r\n    showResizeHandle(img: HTMLImageElement) {\r\n        this.resizeDiv = this.createResizeDiv(img);\r\n        img.contentEditable = 'false';\r\n        this.editor.select(this.resizeDiv, PositionType.After);\r\n    }\r\n\r\n    /**\r\n     * Hide resize handle of current selected image\r\n     * @param selectImageAfterUnSelect Optional, when set to true, select the image element after hide the resize handle\r\n     */\r\n    hideResizeHandle(selectImageAfterUnSelect?: boolean) {\r\n        let img = this.getSelectedImage();\r\n        let parent = this.resizeDiv && this.resizeDiv.parentNode;\r\n        if (parent) {\r\n            if (img) {\r\n                img.removeAttribute('contentEditable');\r\n                let referenceNode =\r\n                    this.resizeDiv.previousSibling &&\r\n                    this.resizeDiv.previousSibling.nodeType == NodeType.Comment\r\n                        ? this.resizeDiv.previousSibling\r\n                        : this.resizeDiv;\r\n                parent.insertBefore(img, referenceNode);\r\n\r\n                if (selectImageAfterUnSelect) {\r\n                    this.editor.select(img);\r\n                } else {\r\n                    this.editor.select(img, PositionType.After);\r\n                }\r\n            }\r\n            this.removeResizeDiv(this.resizeDiv);\r\n            this.resizeDiv = null;\r\n        }\r\n    }\r\n\r\n    private startResize = (e: MouseEvent) => {\r\n        let img = this.getSelectedImage();\r\n        if (this.editor && img) {\r\n            this.startPageX = e.pageX;\r\n            this.startPageY = e.pageY;\r\n            this.startWidth = img.clientWidth;\r\n            this.startHeight = img.clientHeight;\r\n            this.editor.addUndoSnapshot();\r\n\r\n            let document = this.editor.getDocument();\r\n            document.addEventListener('mousemove', this.doResize, true /*useCapture*/);\r\n            document.addEventListener('mouseup', this.finishResize, true /*useCapture*/);\r\n            this.direction = (<HTMLElement>(e.srcElement || e.target)).style.cursor;\r\n        }\r\n\r\n        this.stopEvent(e);\r\n    };\r\n\r\n    private doResize = (e: MouseEvent) => {\r\n        let img = this.getSelectedImage();\r\n        if (this.editor && img) {\r\n            let widthChange = e.pageX - this.startPageX;\r\n            let heightChange = e.pageY - this.startPageY;\r\n            let newWidth = Math.max(\r\n                this.startWidth + (this.isWest(this.direction) ? -widthChange : widthChange),\r\n                this.minWidth\r\n            );\r\n            let newHeight = Math.max(\r\n                this.startHeight + (this.isNorth(this.direction) ? -heightChange : heightChange),\r\n                this.minHeight\r\n            );\r\n\r\n            if (this.forcePreserveRatio || e.shiftKey) {\r\n                let ratio =\r\n                    this.startWidth > 0 && this.startHeight > 0\r\n                        ? (this.startWidth * 1.0) / this.startHeight\r\n                        : 0;\r\n                if (ratio > 0) {\r\n                    if (newWidth < newHeight * ratio) {\r\n                        newWidth = newHeight * ratio;\r\n                    } else {\r\n                        newHeight = newWidth / ratio;\r\n                    }\r\n                }\r\n            }\r\n\r\n            img.style.width = newWidth + 'px';\r\n            img.style.height = newHeight + 'px';\r\n        }\r\n        this.stopEvent(e);\r\n    };\r\n\r\n    private finishResize = (e: MouseEvent) => {\r\n        var img = this.getSelectedImage() as HTMLImageElement;\r\n        if (this.editor && img) {\r\n            let document = this.editor.getDocument();\r\n            document.removeEventListener('mousemove', this.doResize, true /*useCapture*/);\r\n            document.removeEventListener('mouseup', this.finishResize, true /*useCapture*/);\r\n            let width = img.clientWidth;\r\n            let height = img.clientHeight;\r\n            img.style.width = width + 'px';\r\n            img.style.height = height + 'px';\r\n            img.width = width;\r\n            img.height = height;\r\n            this.resizeDiv.style.width = '';\r\n            this.resizeDiv.style.height = '';\r\n        }\r\n        this.direction = null;\r\n        this.editor.addUndoSnapshot();\r\n        this.editor.triggerContentChangedEvent(ChangeSource.ImageResize);\r\n        this.stopEvent(e);\r\n    };\r\n\r\n    private createResizeDiv(target: HTMLElement) {\r\n        let document = this.editor.getDocument();\r\n        let resizeDiv = document.createElement('DIV');\r\n        let parent = target.parentNode;\r\n        parent.insertBefore(resizeDiv, target);\r\n        parent.insertBefore(document.createComment(BEGIN_TAG), resizeDiv);\r\n        parent.insertBefore(document.createComment(END_TAG), resizeDiv.nextSibling);\r\n\r\n        resizeDiv.style.position = 'relative';\r\n        resizeDiv.style.display = 'inline-flex';\r\n        resizeDiv.contentEditable = 'false';\r\n        resizeDiv.addEventListener('click', this.stopEvent);\r\n        resizeDiv.appendChild(target);\r\n        ['nw', 'ne', 'sw', 'se'].forEach(pos => {\r\n            let div = document.createElement('DIV');\r\n            resizeDiv.appendChild(div);\r\n            div.style.position = 'absolute';\r\n            div.style.width = '7px';\r\n            div.style.height = '7px';\r\n            div.style.backgroundColor = this.selectionBorderColor;\r\n            div.style.cursor = pos + '-resize';\r\n            if (this.isNorth(pos)) {\r\n                div.style.top = '-3px';\r\n            } else {\r\n                div.style.bottom = '-3px';\r\n            }\r\n            if (this.isWest(pos)) {\r\n                div.style.left = '-3px';\r\n            } else {\r\n                div.style.right = '-3px';\r\n            }\r\n            div.addEventListener('mousedown', this.startResize);\r\n        });\r\n        let div = document.createElement('DIV');\r\n        resizeDiv.appendChild(div);\r\n        div.style.position = 'absolute';\r\n        div.style.top = '0';\r\n        div.style.left = '0';\r\n        div.style.right = '0';\r\n        div.style.bottom = '0';\r\n        div.style.border = 'solid 1px ' + this.selectionBorderColor;\r\n        div.style.pointerEvents = 'none';\r\n        return resizeDiv;\r\n    }\r\n\r\n    private stopEvent = (e: UIEvent) => {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    };\r\n\r\n    private removeResizeDiv(resizeDiv: HTMLElement) {\r\n        if (this.editor && this.editor.contains(resizeDiv)) {\r\n            [resizeDiv.previousSibling, resizeDiv.nextSibling].forEach(comment => {\r\n                if (comment && comment.nodeType == NodeType.Comment) {\r\n                    this.editor.deleteNode(comment);\r\n                }\r\n            });\r\n            this.editor.deleteNode(resizeDiv);\r\n        }\r\n    }\r\n\r\n    private removeResizeDivIfAny = (img: HTMLImageElement) => {\r\n        let div = img && (img.parentNode as HTMLElement);\r\n        let previous = div && div.previousSibling;\r\n        let next = div && div.nextSibling;\r\n        if (\r\n            previous &&\r\n            previous.nodeType == NodeType.Comment &&\r\n            previous.nodeValue == BEGIN_TAG &&\r\n            next &&\r\n            next.nodeType == NodeType.Comment &&\r\n            next.nodeValue == END_TAG\r\n        ) {\r\n            div.parentNode.insertBefore(img, div);\r\n            this.removeResizeDiv(div);\r\n        }\r\n    };\r\n\r\n    private onBlur = (e: FocusEvent) => {\r\n        this.hideResizeHandle();\r\n    };\r\n\r\n    private extractHtml(html: string): string {\r\n        return html.replace(EXTRACT_HTML_REGEX, (...groups: string[]) => {\r\n            return groups[1].replace(\r\n                /(\\s*contenteditable=\"false\"(\\/?>)|contenteditable=\"false\"\\s*)/im,\r\n                '$2'\r\n            );\r\n        });\r\n    }\r\n\r\n    private getSelectedImage(): HTMLElement {\r\n        return this.resizeDiv ? <HTMLElement>this.resizeDiv.getElementsByTagName('IMG')[0] : null;\r\n    }\r\n\r\n    private isNorth(direction: string): boolean {\r\n        return direction && direction.substr(0, 1) == 'n';\r\n    }\r\n\r\n    private isWest(direction: string): boolean {\r\n        return direction && direction.substr(1, 1) == 'w';\r\n    }\r\n\r\n    private onDragStart = (e: DragEvent) => {\r\n        if ((e.srcElement || e.target) == this.getSelectedImage()) {\r\n            this.hideResizeHandle(true);\r\n        }\r\n    };\r\n}\r\n"],"sourceRoot":""}