{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./packages/roosterjs-editor-dom/lib/index.ts","webpack:///./packages/roosterjs-cross-window/lib/index.ts","webpack:///./packages/roosterjs-editor-core/lib/index.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/contains.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/getTagOfNode.ts","webpack:///./packages/roosterjs-editor-dom/lib/selection/Position.ts","webpack:///./packages/roosterjs-cross-window/lib/typeUtils/safeInstanceOf.ts","webpack:///./packages/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.ts","webpack:///./packages/roosterjs-editor-api/lib/utils/execCommand.ts","webpack:///./packages/roosterjs-editor-dom/lib/selection/createRange.ts","webpack:///./packages/roosterjs-editor-api/lib/index.ts","webpack:///./packages/roosterjs-html-sanitizer/lib/index.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/toArray.ts","webpack:///./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/getLeafSibling.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/isNodeAfter.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/splitParentNode.ts","webpack:///./packages/roosterjs-editor-api/lib/utils/applyInlineStyle.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/wrap.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.ts","webpack:///./packages/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/getComputedStyles.ts","webpack:///./packages/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.ts","webpack:///./packages/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/collapseNodes.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/isBlockElement.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.ts","webpack:///./packages/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/applyTextStyle.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/splitTextNode.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/shouldSkipNode.ts","webpack:///./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/isNodeEmpty.ts","webpack:///./packages/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.ts","webpack:///./packages/roosterjs-editor-core/lib/eventApi/isCtrlOrMetaPressed.ts","webpack:///./packages/roosterjs-editor-core/lib/eventApi/cacheGetEventData.ts","webpack:///./packages/roosterjs-editor-api/lib/utils/processList.ts","webpack:///./packages/roosterjs-editor-plugins/lib/index.ts","webpack:///./packages/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/fromHtml.ts","webpack:///./packages/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.ts","webpack:///./packages/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.ts","webpack:///./packages/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.ts","webpack:///./packages/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/getLeafNode.ts","webpack:///./packages/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/Browser.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/changeElementTag.ts","webpack:///./packages/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/queryElements.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/unwrap.ts","webpack:///./packages/roosterjs-editor-dom/lib/table/VTable.ts","webpack:///./packages/roosterjs-editor-dom/lib/selection/getSelectionPath.ts","webpack:///./packages/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.ts","webpack:///./packages/roosterjs-editor-core/lib/corePlugins/CopyPlugin.ts","webpack:///./packages/roosterjs-editor-core/lib/darkMode/getColorNormalizedContent.ts","webpack:///./packages/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.ts","webpack:///./packages/roosterjs-editor-core/lib/corePlugins/EditPlugin.ts","webpack:///./packages/roosterjs-editor-core/lib/corePlugins/FirefoxTypeAfterLink.ts","webpack:///./packages/roosterjs-editor-core/lib/eventApi/cacheGetContentSearcher.ts","webpack:///./packages/roosterjs-editor-core/lib/eventApi/clearEventDataCache.ts","webpack:///./packages/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.ts","webpack:///./packages/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.ts","webpack:///./packages/roosterjs-editor-core/lib/undo/Undo.ts","webpack:///./packages/roosterjs-editor-core/lib/eventApi/isCharacterValue.ts","webpack:///./packages/roosterjs-editor-core/lib/eventApi/isModifierKey.ts","webpack:///./packages/roosterjs-editor-core/lib/coreAPI/calculateDefaultFormat.ts","webpack:///./packages/roosterjs-editor-core/lib/coreAPI/hasFocus.ts","webpack:///./packages/roosterjs-editor-plugins/lib/ContentEdit/ContentEditFeatures.ts","webpack:///./packages/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.ts","webpack:///./packages/roosterjs-editor-api/lib/format/setBackgroundColor.ts","webpack:///./packages/roosterjs-editor-api/lib/format/setFontName.ts","webpack:///./packages/roosterjs-editor-api/lib/format/setFontSize.ts","webpack:///./packages/roosterjs-editor-api/lib/format/setTextColor.ts","webpack:///./packages/roosterjs-editor-api/lib/format/toggleBold.ts","webpack:///./packages/roosterjs-editor-api/lib/format/toggleItalic.ts","webpack:///./packages/roosterjs-editor-api/lib/format/toggleUnderline.ts","webpack:///./packages/roosterjs-html-sanitizer/lib/utils/getInheritableStyles.ts","webpack:///./packages/roosterjs-html-sanitizer/lib/utils/htmlToDom.ts","webpack:///./packages/roosterjs-html-sanitizer/lib/utils/cloneObject.ts","webpack:///./packages/roosterjs-editor-api/lib/utils/toggleTagCore.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/CustomData.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/LevelLists.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/officeOnlineConverter/constants.ts","webpack:///./packages/roosterjs/lib/index.ts","webpack:///./packages/roosterjs/lib/createEditor.ts","webpack:///./packages/roosterjs-editor-plugins/lib/HyperLink/HyperLink.ts","webpack:///./packages/roosterjs-cross-window/lib/typeUtils/isDocumentFragment.ts","webpack:///./packages/roosterjs-cross-window/lib/typeUtils/isHTMLElement.ts","webpack:///./packages/roosterjs-cross-window/lib/typeUtils/isHTMLOListElement.ts","webpack:///./packages/roosterjs-cross-window/lib/typeUtils/isHTMLTableCellElement.ts","webpack:///./packages/roosterjs-cross-window/lib/typeUtils/isHTMLTableElement.ts","webpack:///./packages/roosterjs-cross-window/lib/typeUtils/isNode.ts","webpack:///./packages/roosterjs-cross-window/lib/typeUtils/isRange.ts","webpack:///./packages/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.ts","webpack:///./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.ts","webpack:///./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.ts","webpack:///./packages/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/applyFormat.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/extractClipboardEvent.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/getPendableFormatState.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/isRtl.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/matchLink.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/adjustNodeInsertPosition.ts","webpack:///./packages/roosterjs-editor-dom/lib/utils/getTextContent.ts","webpack:///./packages/roosterjs-editor-dom/lib/selection/getPositionRect.ts","webpack:///./packages/roosterjs-editor-dom/lib/selection/getHtmlWithSelectionPath.ts","webpack:///./packages/roosterjs-editor-dom/lib/selection/setHtmlWithSelectionPath.ts","webpack:///./packages/roosterjs-editor-dom/lib/snapshots/addSnapshot.ts","webpack:///./packages/roosterjs-editor-dom/lib/snapshots/moveCurrentSnapsnot.ts","webpack:///./packages/roosterjs-editor-dom/lib/snapshots/createSnapshots.ts","webpack:///./packages/roosterjs-editor-core/lib/editor/Editor.ts","webpack:///./packages/roosterjs-editor-core/lib/editor/adjustBrowserBehavior.ts","webpack:///./packages/roosterjs-editor-core/lib/editor/createEditorCore.ts","webpack:///./packages/roosterjs-editor-core/lib/undo/UndoSnapshots.ts","webpack:///./packages/roosterjs-editor-core/lib/coreAPI/attachDomEvent.ts","webpack:///./packages/roosterjs-editor-core/lib/coreAPI/editWithUndo.ts","webpack:///./packages/roosterjs-editor-core/lib/coreAPI/focus.ts","webpack:///./packages/roosterjs-editor-core/lib/coreAPI/getCustomData.ts","webpack:///./packages/roosterjs-editor-core/lib/coreAPI/getSelectionRange.ts","webpack:///./packages/roosterjs-editor-core/lib/coreAPI/insertNode.ts","webpack:///./packages/roosterjs-editor-core/lib/coreAPI/selectRange.ts","webpack:///./packages/roosterjs-editor-core/lib/coreAPI/triggerEvent.ts","webpack:///./packages/roosterjs-editor-core/lib/editor/mapPluginEvents.ts","webpack:///./packages/roosterjs-editor-core/lib/darkMode/convertContentToDarkMode.ts","webpack:///./packages/roosterjs-editor-core/lib/eventApi/cacheGetElementAtCursor.ts","webpack:///./packages/roosterjs-editor-plugins/lib/ContentEdit/ContentEdit.ts","webpack:///./packages/roosterjs-editor-plugins/lib/ContentEdit/features/autoLinkFeatures.ts","webpack:///./packages/roosterjs-editor-api/lib/format/changeFontSize.ts","webpack:///./packages/roosterjs-editor-api/lib/format/clearBlockFormat.ts","webpack:///./packages/roosterjs-editor-api/lib/format/clearFormat.ts","webpack:///./packages/roosterjs-editor-api/lib/format/createLink.ts","webpack:///./packages/roosterjs-html-sanitizer/lib/sanitizer/HtmlSanitizer.ts","webpack:///./packages/roosterjs-html-sanitizer/lib/utils/getAllowedValues.ts","webpack:///./packages/roosterjs-editor-api/lib/format/getFormatState.ts","webpack:///./packages/roosterjs-editor-api/lib/format/insertImage.ts","webpack:///./packages/roosterjs-editor-api/lib/table/insertTable.ts","webpack:///./packages/roosterjs-editor-api/lib/table/editTable.ts","webpack:///./packages/roosterjs-editor-api/lib/table/formatTable.ts","webpack:///./packages/roosterjs-editor-api/lib/format/removeLink.ts","webpack:///./packages/roosterjs-editor-api/lib/format/replaceWithNode.ts","webpack:///./packages/roosterjs-editor-api/lib/format/setAlignment.ts","webpack:///./packages/roosterjs-editor-api/lib/format/setDirection.ts","webpack:///./packages/roosterjs-editor-api/lib/format/setImageAltText.ts","webpack:///./packages/roosterjs-editor-api/lib/format/setIndentation.ts","webpack:///./packages/roosterjs-editor-api/lib/format/toggleBullet.ts","webpack:///./packages/roosterjs-editor-api/lib/format/toggleNumbering.ts","webpack:///./packages/roosterjs-editor-api/lib/format/toggleBlockQuote.ts","webpack:///./packages/roosterjs-editor-api/lib/format/toggleCodeBlock.ts","webpack:///./packages/roosterjs-editor-api/lib/format/toggleStrikethrough.ts","webpack:///./packages/roosterjs-editor-api/lib/format/toggleSubscript.ts","webpack:///./packages/roosterjs-editor-api/lib/format/toggleSuperscript.ts","webpack:///./packages/roosterjs-editor-api/lib/format/toggleHeader.ts","webpack:///./packages/roosterjs-editor-plugins/lib/ContentEdit/features/shortcutFeatures.ts","webpack:///./packages/roosterjs-editor-plugins/lib/ContentEdit/features/insertLineBeforeStructuredNodeFeature.ts","webpack:///./packages/roosterjs-editor-plugins/lib/ContentEdit/features/noCycleCursorMove.ts","webpack:///./packages/roosterjs-editor-plugins/lib/ContentEdit/features/tableFeatures.ts","webpack:///./packages/roosterjs-editor-plugins/lib/ContentEdit/features/listFeatures.ts","webpack:///./packages/roosterjs-editor-plugins/lib/ContentEdit/features/quoteFeatures.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/Paste.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/buildClipboardData.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/fragmentHandler.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/excelConverter/convertPastedContentFromExcel.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/convertPastedContentFromWord.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/wordConverter.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/WordConverterArguments.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/converterUtils.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/officeOnlineConverter/ListItemBlock.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Paste/textToHtml.ts","webpack:///./packages/roosterjs-editor-plugins/lib/Watermark/Watermark.ts","webpack:///./packages/roosterjs-editor-plugins/lib/TableResize/TableResize.ts","webpack:///./packages/roosterjs-editor-plugins/lib/CustomReplace/CustomReplace.ts","webpack:///./packages/roosterjs-plugin-image-resize/lib/index.ts","webpack:///./packages/roosterjs-plugin-image-resize/lib/ImageResize.ts","webpack:///./packages/roosterjs-plugin-picker/lib/index.ts","webpack:///./packages/roosterjs-plugin-picker/lib/PickerPlugin.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","NodeBlockElement_1","NodeBlockElement","default","getBlockElementAtNode_1","getBlockElementAtNode","getFirstLastBlockElement_1","getFirstLastBlockElement","StartEndBlockElement_1","StartEndBlockElement","ContentTraverser_1","ContentTraverser","PositionContentSearcher_1","PositionContentSearcher","getInlineElementAtNode_1","getInlineElementAtNode","ImageInlineElement_1","ImageInlineElement","LinkInlineElement_1","LinkInlineElement","NodeInlineElement_1","NodeInlineElement","PartialInlineElement_1","PartialInlineElement","applyTextStyle_1","applyTextStyle","Browser_1","Browser","getBrowserInfo","applyFormat_1","applyFormat","changeElementTag_1","changeElementTag","collapseNodes_1","collapseNodes","contains_1","contains","extractClipboardEvent_1","extractClipboardEvent","findClosestElementAncestor_1","findClosestElementAncestor","fromHtml_1","fromHtml","getComputedStyles_1","getComputedStyles","getComputedStyle","getPendableFormatState_1","getPendableFormatState","PendableFormatCommandMap","getTagOfNode_1","getTagOfNode","isBlockElement_1","isBlockElement","isNodeEmpty_1","isNodeEmpty","isRtl_1","isRtl","isVoidHtmlElement_1","isVoidHtmlElement","matchLink_1","matchLink","adjustNodeInsertPosition_1","adjustNodeInsertPosition","queryElements_1","queryElements","splitParentNode_1","splitParentNode","splitBalancedNodeRange","unwrap_1","unwrap","wrap_1","wrap","getLeafSibling_1","getNextLeafSibling","getPreviousLeafSibling","getLeafNode_1","getFirstLeafNode","getLastLeafNode","getTextContent_1","getTextContent","splitTextNode_1","splitTextNode","toArray_1","toArray","VTable_1","VTable","Position_1","Position","createRange_1","createRange","getRangeFromSelectionPath","getPositionRect_1","getPositionRect","isPositionAtBeginningOf_1","isPositionAtBeginningOf","getSelectionPath_1","getSelectionPath","getHtmlWithSelectionPath_1","getHtmlWithSelectionPath","setHtmlWithSelectionPath_1","setHtmlWithSelectionPath","addSnapshot_1","addSnapshot","canMoveCurrentSnapshot_1","canMoveCurrentSnapshot","clearProceedingSnapshots_1","clearProceedingSnapshots","moveCurrentSnapsnot_1","moveCurrentSnapsnot","createSnapshots_1","createSnapshots","isDocumentFragment_1","isDocumentFragment","isHTMLElement_1","isHTMLElement","isHTMLOListElement_1","isHTMLOListElement","isHTMLTableCellElement_1","isHTMLTableCellElement","isHTMLTableElement_1","isHTMLTableElement","isNode_1","isNode","isRange_1","isRange","safeInstanceOf_1","safeInstanceOf","Editor_1","Editor","Undo_1","Undo","EditPlugin_1","EditPlugin","MouseUpPlugin_1","MouseUpPlugin","DOMEventPlugin_1","DOMEventPlugin","TypeInContainerPlugin_1","TypeInContainerPlugin","FirefoxTypeAfterLink_1","FirefoxTypeAfterLink","CopyPlugin_1","CopyPlugin","cacheGetEventData_1","cacheGetEventData","clearEventDataCache_1","clearEventDataCache","cacheGetContentSearcher_1","cacheGetContentSearcher","clearContentSearcherCache","cacheGetElementAtCursor_1","cacheGetElementAtCursor","isModifierKey_1","isModifierKey","isCharacterValue_1","isCharacterValue","isCtrlOrMetaPressed_1","isCtrlOrMetaPressed","roosterjs_cross_window_1","container","contained","treatSameNodeAsContain","commonAncestorContainer","nodeType","parentNode","node","tagName","toUpperCase","isNodeAfter_1","nodeOrPosition","offsetOrPosType","this","offset","getIndexOfNode","isAtEnd","nextSibling","getEndOffset","endOffset","Math","max","min","element","normalize","firstChild","newOffset","nextNode","lastChild","childNodes","equalTo","position","isAfter","move","getStart","range","startContainer","startOffset","getEnd","endContainer","previousSibling","nodeValue","length","getTargetWindow","source","document","ownerDocument","toString","apply","defaultView","window","obj","typeName","targetWindow","targetType","mainWindow","mainWindowType","findHeadTailLeafNode","containerBlockNode","isTail","result","sibling","rootNode","getBlockContext","headNode","tailNode","nodes","roosterjs_editor_dom_1","pendableFormatCommands","editor","command","focus","formatter","getDocument","execCommand","getSelectionRange","collapsed","addUndoSnapshot","keys","map","indexOf","isPendableFormatCommand","triggerPluginEvent","formatState","arg1","arg2","arg3","arg4","start","end","isNodePosition","Array","isArray","getPositionFromPath","getFocusablePosition","setStart","setEnd","arg","path","changeFontSize_1","changeFontSize","FONT_SIZES","clearBlockFormat_1","clearBlockFormat","TAGS_TO_UNWRAP","TAGS_TO_STOP_UNWRAP","ATTRIBUTES_TO_PRESERVE","clearFormat_1","clearFormat","createLink_1","createLink","getFormatState_1","getFormatState","getElementBasedFormatState","getStyleBasedFormatState","insertImage_1","insertImage","insertTable_1","insertTable","editTable_1","editTable","formatTable_1","formatTable","removeLink_1","removeLink","replaceWithNode_1","replaceWithNode","setAlignment_1","setAlignment","setBackgroundColor_1","setBackgroundColor","setTextColor_1","setTextColor","setDirection_1","setDirection","setFontName_1","setFontName","setFontSize_1","setFontSize","setImageAltText_1","setImageAltText","setIndentation_1","setIndentation","toggleBold_1","toggleBold","toggleBullet_1","toggleBullet","toggleItalic_1","toggleItalic","toggleNumbering_1","toggleNumbering","toggleBlockQuote_1","toggleBlockQuote","toggleCodeBlock_1","toggleCodeBlock","toggleStrikethrough_1","toggleStrikethrough","toggleSubscript_1","toggleSubscript","toggleSuperscript_1","toggleSuperscript","toggleUnderline_1","toggleUnderline","toggleHeader_1","toggleHeader","HtmlSanitizer_1","HtmlSanitizer","htmlToDom_1","htmlToDom","splitWithFragment","getInheritableStyles_1","getInheritableStyles","collection","slice","parent","parentBlock","inlineElement","nodeChain","parent_1","push","currentNode","tag","resolveInlineElement","shouldSkipNode_1","getLeafSibling","startNode","isNext","getSibling","getChild","curNode","shouldContinue","node1","node2","compareDocumentPosition","splitBefore","newParent","cloneNode","removeAttribute","appendChild","innerHTML","insertBefore","temp","ZERO_WIDTH_SPACE","callback","createTextNode","insertNode","select","firstNode","lastNode","contentTraverser","getSelectionTraverser","currentInlineElement","nextInlineElement","getNextInlineElement","applyStyle","isInnerNode","wrapper","document_1","test","createElement","_i","nodes_1","root","selector","closest","matches","msMatchesSelector","parentElement","containerNode","textContent","getContainerNode","getParentBlock","getStartPosition","getEndPosition","isTextualInlineElement","pos","styler","styleNames","styles","styleNames_1","style","getPropertyValue","toLowerCase","px2Pt","px","round","parseFloat","styleName","getDecoratedInline","thisStart","otherEnd","from","to","previousNode","collapseToSingleElement","getStartNode","getEndNode","equals","blockElement","collapse","ref","isStart","canSplitParent","startIndex","endIndex","BLOCK_ELEMENT_TAGS","split","BLOCK_DISPLAY_STYLES","display","HTML_VOID_ELEMENTS","BodyScoper_1","EmptyInlineElement_1","SelectionBlockScoper_1","SelectionScoper_1","getInlineElementBeforeAfter_1","scoper","createBodyTraverser","createSelectionTraverser","createBlockTraverser","currentBlock","getStartBlockElement","getNextBlockElement","getPreviousNextBlockElement","getPreviousBlockElement","current","currentBlockElement","leaf","newBlock","isBlockInScope","currentInline","getStartInlineElement","getPreviousNextInlineElement","getPreviousInlineElement","newInline","getInlineElementBeforeAfter","previousInlineElement","getNextPreviousInlineElement","trimInlineElement","STYLETAGS","callStylerWithInnerNode","formatNodes","formatNode","parentTag","every","newNode_1","shift","forEach","removeChild","textNode","returnFirstPart","firstPart","substr","secondPart","newNode","CRLF","isPartial","getInlineElementBefore","getInlineElementAfter","VISIBLE_ELEMENT_TAGS","VISIBLE_CHILD_ELEMENT_SELECTOR","join","trim","replace","trimContent","querySelectorAll","snapshots","step","newIndex","currentIndex","isMac","event","metaKey","ctrlKey","eventDataCache","existingList","getElementAtCursor","isChrome","parentLINode","currentRange","currentSelectionPath","listParent","nextElementSibling","insertAdjacentElement","wrappedContents","wrappedRange","wrappedSelectionPath","deleteNode","newRange","childElementCount","newList","HyperLink_1","HyperLink","ContentEdit_1","ContentEdit","Paste_1","Paste","ContentEditFeatures_1","getDefaultContentEditFeatures","Watermark_1","Watermark","TableResize_1","TableResize","CustomReplace_1","CustomReplace","STRUCTURE_NODE_TAGS","endNode","blockContext","html","isFirst","getFirstBlockElement","getLastBlockElement","_super","__extends","getFirstInlineElement","getLastInlineElement","getLeafNode","EmptyInlineElement","userAgent","appVersion","isIE11OrGreater","isIE","isFirefox","isSafari","isEdge","isWebKit","isWin","isIEOrEdge","navigator","newTag","newElement","attributes","attr","setAttribute","_a","marginTop","marginBottom","replaceChild","areAllPrevousNodesEmpty","targetNode","checkPosition","targets","some","target","forEachCallback","scope","elements","filter","nodeContainedByRangeOnly","startPosition","endPosition","targetPositions","isIntersectWithNodeRange","_this","trs","table","td","getTableFromTd","currentTd_1","rows","cells","row","tr","rowIndex","sourceCol","targetCol","col","colSpan","rowSpan","spanLeft","spanAbove","writeBack","moveChildren","cell","recalcSpans","format","borderCollapse","backgroundColor","bgColorOdd","bgColorEven","borderTop","getBorderStyle","topBorderColor","borderBottom","bottomBorderColor","borderLeft","verticalBorderColor","borderRight","edit","operation","currentRow","currentCell","splice","cloneCell","newRow_1","countSpanAbove","colIndex","nextCell","getCell","newCell","getTd","forEachCellOfCurrentColumn","newCol_1","countSpanLeft","forEachCellOfColumn","forEachCellOfCurrentRow","rowStep","aboveCell","belowCell","colStep","leftCell","rightCell","splitRow","forEachCellOfRow","getCurrentTd","fromNode","toNode","getPositionPath","unshift","isPreviousText","removedSize","totalSize","getColorNormalizedContent_1","onExtract","isCut","isDarkMode","selectionRange","clipboardEvent","copyFragment","cloneContents","normalizedContent","containerDiv","clipboardData","setData","innerText","deleteContents","preventDefault","getName","initialize","eventDisposer","addDomEventHandler","copy","cut","dispose","isDataAttributeSettable","newStyle","content","el","allChildElements","getElementsByTagName","dataset","color","ogsc","ogsb","ogac","ogab","disableRestoreSelectionOnFocus","inIme","onNativeEvent","e","runAsync","type","onFocus","cachedPosition","cachedFormatState","restorePendingFormatState","clear","restoreSavedRange","onBlur","saveSelectionRange","onScroll","rawEvent","scrollContainer","getScrollContainer","disposer","compositionstart","compositionend","drop","addEventListener","removeEventListener","onPluginEvent","eventType","getCurrentPosition","formatState_1","isInIME","featureMap","autoCompleteSnapshot","autoCompleteChangeSource","addFeature","shouldHandleEvent","handleEvent","setContent","contentChanged","currentFeature","findFeature","feature","array","performAutoComplete","changeSource","snapshot","data","features","hasFunctionKey","ctrlOrMeta","altKey","which","allowFunctionKeys","CONTENTSEARCHER_KEY","getContentSearcherOfCursor","onMouseUp","removeMouseUpEventListener","mouseUpEventListerAdded","onKeyPress","ensureTypeInElement","block","shouldSetNodeStyles","wasNodeJustCreatedByKeyboardEvent","updateCursor","replaceSelection","insertOnNewLine","getDefaultFormat","tryNormalizeTyping","UndoSnapshots_1","preserveSnapshots","maxBufferSize","canUndo","canRedo","onKeyDown","clearRedoForInput","isRestoring","undoSnapshots","hasNewContent","undo","restoreSnapshot","redo","getSnapshotsManager","canMove","getContent","delta","evt","lastKeyPress","clearRedo","CTRL_CHARCODE","ALT_CHARCODE","META_CHARCODE","isCtrlKey","isAltKey","isMetaKey","DARK_MODE_DEFAULT_FORMAT","backgroundColors","darkModeColor","lightModeColor","textColors","calculateDefaultFormat","baseFormat","inDarkMode","fontFamily","fontSize","textColor","bold","italic","underline","currentStyles","hasFocus","core","activeElement","contentDiv","autoLink","indentWhenTab","outdentWhenShiftTab","outdentWhenBackspaceOnEmptyFirstLine","outdentWhenEnterOnEmptyLine","mergeInNewLineWhenBackspaceOnFirstChar","unquoteWhenBackspaceOnEmptyFirstLine","unquoteWhenEnterOnEmptyLine","autoBullet","tabInTable","upDownInTable","insertLineBeforeStructuredNodeFeature","defaultShortcut","unlinkWhenBackspaceAfterLink","noCycleCursorMove","smartOrderedList","smartOrderedListStyles","isEmptyBlockUnderTR","traverser","blocks","applyInlineStyle_1","trimmedColor_1","darkMode_1","appliedColor_1","fontName","lineHeight","execCommand_1","INHERITABLE_PROPERTIES","win","START_FRAGMENT","END_FRAGMENT","lastIndexOf","before","after","substring","preserveFragmentOnly","fragmentHandler","doc","DOMParser","parseFromString","body","sourceHtml","cloneObject","assign","existingObj","UNWRAPPABLE_NODES","DEFAULT_STYLER","_","wrapFunction","unwrapFunction","startBlock","endBlock","tag_1","NODE_ID_ATTRIBUTE_NAME","getAndSetNodeId","customData","id","getAttribute","nextNodeId","createCustomData","dict","setObject","getObject","createLevelLists","listsMetadata","currentUniqueListId","WORD_ORDERED_LIST_SELECTOR","WORD_UNORDERED_LIST_SELECTOR","WORD_ONLINE_IDENTIFYING_SELECTOR","LIST_CONTAINER_ELEMENT_CLASS_NAME","UNORDERED_LIST_TAG_NAME","ORDERED_LIST_TAG_NAME","WAC_IDENTIFING_SELECTOR","createEditor_1","createEditor","__export","roosterjs_editor_plugins_1","roosterjs_editor_core_1","additionalPlugins","initialContent","plugins","concat","options","defaultFormat","getTooltipCallback","onLinkClick","href","onMouse","a","tryGetHref","setEditorDomAttribute","mouseover","mouseout","anchor","button","open","getFirstLastInlineElement_1","BodyScoper","SelectionBlockScoper","startFrom","blockNode","getFirstLastInlineElementFromBlockElement","startInline","SelectionScoper","inScope","selStartBlock","selEndBlock","inline","startPartial","endPartial","WHITESPACE_REGEX","text","inlineElements","getWordBefore","word","traverse","inlineBefore","inlineAfter","getSubStringBefore","getRangeFromText","exactMatch","textIndex","forEachTextInlineElement","textInline","nodeContent","nodeIndex","charCodeAt","getNearestNonTextInlineElement","nearestNonTextInlineElement","traversingComplete","previousInline","exec","elementStyle","fontWeight","fontStyle","textDecoration","CLIPBOARD_HTML_HEADER_REGEX","getImage","dataTransfer","fileCount","items","item","getAsFile","files","file","workaroundForEdge","headerValues","parseInt","types","getData","image","undefined","getAsString","isBold","isItalic","isUnderline","isStrikeThrough","isSubscript","isSuperscript","reduce","state","queryCommandState","httpExcludeRegEx","domainPortWithUrlRegEx","domainPortRegEx","linkMatchRules","http","match","RegExp","except","normalizeUrl","url","https","mailto","notes","unc","ftp","news","telnet","gopher","wais","schema","rule","scheme","originalUrl","normalizedUrl","adjustSteps","nodeToInsert","safeRemove","querySelector","normalizedPosition","splitter","rootNodeToInsert","rootNodes","hasBrNextToRoot","listItem","listNode","tdNode","trNode","newTable","currentTable","shouldInsertListAsText","div","handler","normalizeRect","clientRect","left","right","top","bottom","rect","getBoundingClientRect","rects","getClientRects","span","selectionPath","JSON","stringify","pathComment","parse","removeCount","maxSize","adjustBrowserBehavior_1","createEditorCore_1","mapPluginEvents_1","calculateDefaultFormat_1","convertContentToDarkMode_1","Error","plugin","eventDisposers","additionalEditFeatures","addContentEditFeature","omitContentEditableAttributeChanges","isContentEditable","userSelect","msUserSelect","webkitUserSelect","contenteditableChanged","corePlugins","typeInContainer","getFocusedPosition","isDisposed","option","darkModeOptions","getDarkModeOptions","darkModeTransform","convertContentToDarkMode","onExternalContentTransform","api","replaceNode","existingNode","scopeOrCallback","Function","isEmpty","triggerExtractContentEvent","includeSelectionMarker","triggerContentChangedEvent","convertFunction","insertContent","allNodes","fragment_1","createDocumentFragment","selectRange","getSelection","cachedSelectionRange","sel","focusNode","focusOffset","getCursorRect","isPositionAtBeginning","nameOrMap","handlers_1","eventName","attachDomEvent","x","broadcast","__assign","triggerEvent","pluginEvent","editWithUndo","getCustomData","domEvent","getBodyTraverser","getBlockTraverser","requestAnimationFrame","getEditorDomAttribute","setDarkModeState","nextDarkMode","currentContent","changedToDarkMode","COMMANDS","_b","attachDomEvent_1","editWithUndo_1","focus_1","getCustomData_1","getSelectionRange_1","hasFocus_1","insertNode_1","selectRange_1","triggerEvent_1","createCoreApiMap","initValue","mouseUp","firefoxTypeAfterLink","copyPlugin","allPlugins","buildPluginList","eventHandlerPlugins","willHandleEventExclusively","currentUndoSnapshot","coreApiOverride","defaultApi","MAXSIZELIMIT","UndoSnapshots","pluginEventType","beforeDispatch","onEvent","stopPropagation","isNested","event_1","tryGetFromCache","selection","rangeCount","getRangeAt","insertedNode_1","isBegin","refNode","insertedNode","rangeToRestore","cloneRange","getInitialRange","nodeForCursor","skipSameRange","needAddRange","removeAllRanges","addRange","handledExclusively","EVENT_MAPPING","keypress","keydown","keyup","mousedown","skipRootElement","childElements","CACHE_KEY_PREFIX","autoLinkFeatures_1","shortcutFeatures_1","insertLineBeforeStructuredNodeFeature_1","noCycleCursorMove_1","tableFeatures_1","listFeatures_1","quoteFeatures_1","featureSet","getFilteredFeatures","allFeatures","IndentWhenTab","OutdentWhenShiftTab","OutdentWhenBackOn1stEmptyLine","OutdentWhenEnterOnEmptyLine","MergeInNewLine","UnquoteWhenBackOnEmpty1stLine","UnquoteWhenEnterOnEmptyLine","TabInTable","UpDownInTable","InsertLineBeforeStructuredNodeFeature","AutoBullet","AutoLink","UnlinkWhenBackspaceAfterLink","DefaultShortcut","NoCycleCursorMove","getSmartOrderedList","roosterjs_editor_api_1","TRAILING_PUNCTUATION_REGEX","MINIMUM_LENGTH","cacheGetLinkData","link","searcher","trailingPunctuation","candidate_1","str","linkData","MIN_FONT_SIZE","MAX_FONT_SIZE","getNewFontSize","pt","changeBase","fontSizes","floor","ceil","last","change","collapseSelectedBlocks_1","canCollapse","tagsToStopUnwrap","tagsToUnwrap","attributesToPreserve","groups","stopUnwrapSelector","group","first","clearNodeFormat","allChildrenAreBlock","previousValue","returnBlockElement","clearAttribute","styleArray","STYLES_TO_REMOVE","isDefaultFormatEmpty","removeProperty","roosterjs_html_sanitizer_1","URI_REGEX","MAILTO_REGEX","FTP_REGEX","TEMP_TITLE","getAnchorNodeAtCursor","updateAnchorDisplayText","displayText","altText","santizer","sanitize","checkXss","normalizedUrl_1","prefix","search","applyLinkPrefix","originalUrl_1","title","cloneObject_1","getAllowedValues_1","elementCallbacks","styleCallbacks","getStyleCallbacks","attributeCallbacks","allowedTags","getAllowedTags","additionalAllowedTags","allowedAttributes","getAllowedAttributes","additionalAllowAttributes","defaultStyleValues","getDefaultStyleValues","additionalDefaultStyleValues","additionalGlobalStyleNodes","allowPreserveWhiteSpace","convertInlineCss","additionalStyleNodes","sanitizeHtml","sanitizer","currentElementOrStyle","convertCssOnly","convertGlobalCssToInlineCss","processNode","styleNodes","styleSheets_1","reverse","sheet","styleSheet","j","styleRule","cssRules","cssText","CSSRule","STYLE_RULE","selectorText","currentStyle","context","isElement","Node","ELEMENT_NODE","isText","TEXT_NODE","allowElement","insidePRE","thisStyle","processAttributes","processCss","child","next","styleNode","getAttributeNode","pair","isInheritable","keep","attribute","name_1","list","ALLOWED_HTML_TAGS","ALLOWED_HTML_ATTRIBUTES","DEFAULT_STYLE_VALUES","background-color","border-bottom-color","border-bottom-style","border-bottom-width","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-left-color","border-left-style","border-left-width","border-right-color","border-right-style","border-right-width","border-top-color","border-top-style","border-top-width","outline-color","outline-style","outline-width","overflow","text-decoration","-webkit-text-stroke-width","word-wrap","margin-left","margin-right","padding","padding-top","padding-left","padding-right","padding-bottom","border","border-top","border-left","border-right","border-bottom","vertical-align","float","removeValue","removeWidthForLiAndDiv","unique","index","self","additionalTags","additionalAttributes","toLocaleLowerCase","additionalDefaultStyles","callbacks","width","roosterjs_editor_dom_2","listTag","headerTag","isBullet","isNumbering","headerLevel","canUnlink","canAddImageAltText","isBlockQuote","insertImageWithSrc","src","maxWidth","imageFile","reader","FileReader","onload","readAsDataURL","getTableCellWidth","columns","fragment","cellSpacing","cellPadding","vtable","textOrRange","backupRange","alignment","align","textAlign","direction","processList_1","indentation","toggleTagCore_1","BLOCKQUOTE_TAG","borderColor","paddingLeft","PRE_TAG","CODE_TAG","CODE_NODE_TAG","codeBlock","level","wrapped","header","font-size","createCommand","winKey","macKey","action","commands","cacheGetCommand","shiftKey","cmd","NEWLINE_HTML","CHILD_PARENT_TAG_MAP","TD","TH","LI","CHILD_SELECTOR","cacheGetStructuredElement","rtl","cacheGetTableCell","firstTd","isUp","targetTd","hasShiftKey","anchorNode","anchorOffset","newContainer","newPos","setBaseAndExtent","toggleListAndPreventDefault","listInfo","cacheGetListElement","listElement","li","br","textBeforeCursor","rangeToDelete","tempBr","styleList","ol","parentOl","listStyle","QUOTE_TAG","STRUCTURED_TAGS","cacheGetQuoteChild","quote","splitQuote","childOfQuote","buildClipboardData_1","fragmentHandler_1","textToHtml_1","roosterjs_editor_api_2","preserved","onPaste","pasteOriginal","snapshotBeforePaste","originalFormat","getCurrentFormat","rawHtml","applyFormatting","pasteDisposer","paste","detectPasteOption","pasteText","pasteAndMergeFormat","pasteOption","mergeCurrentFormat","applyToElements","internalPaste","elementTransform","parents","parents_1","CONTAINER_HTML","originalSelectionRange","tempDiv","pasteDiv","getTempDivForPaste","retrieveHtmlViaTempDiv","convertPastedContentFromExcel_1","convertPastedContentFromWord_1","convertPastedContentFromWordOnline_1","constants_1","WORD_ATTRIBUTE_NAME","WORD_ATTRIBUTE_VALUE","EXCEL_ATTRIBUTE_NAME","EXCEL_ATTRIBUTE_VALUE","LAST_TD_END_REGEX","LAST_TR_END_REGEX","LAST_TR_REGEX","LAST_TABLE_REGEX","wacListElements","margin","isWordOnlineWithList","trMatch","tableMatch","wordConverter_1","WordConverterArguments_1","converterUtils_1","wordConverter","createWordConverter","wordConverterArgs","createWordConverterArguments","processNodesDiscovery","processNodeConvert","CustomData_1","nextUniqueId","numBulletsConverted","numNumberedConverted","LevelLists_1","lists","listItems","currentListIdsByLevels","lastProcessedItem","LOOKUP_DEPTH","UNIQUE_LIST_ID_CUSTOM_DATA","MSO_LIST_STYLE_NAME","LINE_BREAKS","getOrCreateListForNode","metadata","listMetadata","recurringGetOrCreateListAtNode","possibleList","getRealPreviousSibling","listId","uniqueListId","convertListIfNeeded","cleanupListIgnore","levels","nodesToRemove","isEmptySpan","fixWordListComments","isIgnoreNode","getListItemMetadata","listatt","getStyleValue","listprops","wordListId","originalNode","isFakeBullet","fakeBullet","getFakeBulletText","removeComments","nextElement","endComment","getRealNextSibling","newSpan","prevSibling","isEmptyTextNode","textStyle","inStyles","nvpair","resetCurrentLists","args","ll","itemMetadata","levelInfo","ignore","numberOfItems","secondFakeBullet","firstFakeBullet","className","ListItemBlock_1","insertConvertedListToDoc","convertedListElement","rootElement","listItemBlock","insertPositionNode","startElement","append","replaceRegex","prevParent","nextParent","sanitizeListItemContainer","curListItemBlock","listElements","getElementsByClassName","curItem","listItemContainers","lastItemInCurBlock","endElement","createListItemBlock","getListItemBlocks","itemBlock","section","listItemContainer","listType","getContainerListType","itemLevel","listRootElement","itemToInsert","curListLevel","lastElementChild","lastChildTag","firstElementChild","insertListItem","parentContainer","lines","lineEnd_1","line","WATERMARK_REGEX","watermark","handleWatermark","showHideWatermark","blur","spellcheckInitialValue","hideWatermark","isWatermarkShowing","removeWartermarkFromHtml","ignoreCachedState","showWatermark","watermarkNode","pageX","onMouseOver","srcElement","calcAndShowHandle","onMouseDown","initialPageX","attachMouseEvents","getResizeHandle","borderWidth","cancelEvent","onMouseMove","adjustHandle","detachMouseEvents","isNaN","newWidth_1","clientWidth","setTableColumnWidth","onMouseOverDisposer","clickIntoCurrentTd","getPosition","top_1","handle","offsetLeft","offsetWidth","height","offsetHeight","offsetParent","scrollLeft","offsetTop","scrollTop","document_2","makeReplacement","sourceString","replacementHTML","matchSourceCaseSensitive","defaultReplacements","CustomReplacePlugin","replacements","updateReplacements","newReplacements","longestReplacementLength","replacement","replacementEndCharacters","endChars","Set","replacements_1","lastChar","add","toLocaleUpperCase","getReplacementEndCharacters","has","stringToSearch","getMatchingReplacement","matchingText","matchingRange","parsingSpan","lowerCaseStringToSearch","sourceMatch","replacementMatch","ImageResize_1","ImageResize","BEGIN_TAG","END_TAG","EXTRACT_HTML_REGEX","minWidth","minHeight","selectionBorderColor","forcePreserveRatio","resizableImageSelector","startResize","img","getSelectedImage","startPageX","startPageY","pageY","startWidth","startHeight","clientHeight","doResize","finishResize","cursor","stopEvent","widthChange","heightChange","newWidth","isWest","newHeight","isNorth","ratio","resizeDiv","removeResizeDivIfAny","previous","removeResizeDiv","hideResizeHandle","onDragStart","dragstart","contentEditable","currentImg","showResizeHandle","event_2","event_3","extractHtml","createResizeDiv","selectImageAfterUnSelect","referenceNode","createComment","pointerEvents","comment","arguments","PickerPlugin_1","PickerPlugin","ESC_CHARCODE","LEFT_ARROW_CHARCODE","UP_ARROW_CHARCODE","RIGHT_ARROW_CHARCODE","DOWN_ARROW_CHARCODE","DELETE_CHARCODE","dataProvider","pickerOptions","isPendingInputEventHandling","onInitalize","htmlNode","wordToReplace","getWord","lastKnownRange","setIsSuggesting","handleAutoComplete","isSuggesting","onDispose","onContentChanged","elementIds_1","elementIdPrefix","eventHandledOnKeyDown","currentInputLength","calcInputLength","onKeyDownEvent","onAndroidInputEvent","shouldHandleKeyUpEvent","onKeyUpDomEvent","setLastKnownRange","onIsSuggestingChanged","setAriaOwns","setAriaActiveDescendant","cancelDefaultKeyDownEvent","stopImmediatePropagation","getIdValue","getNamedItem","getWordBeforeCursor","replacementNode","getRangeUntilAt","startPos","endPos","hasMatched","triggerCharacter","trimmedWordBeforeCursor","wordBeforeCursorWithoutTriggerChar","wordBeforeCursor","queryStringUpdated","blockSuggestions","setCursorPoint","rangeNode","nodeBeforeCursor","setRangeStart","nodeBeforeNodeBeforeCursor","detach","targetPoint","y","bufferZone","keyboardEvent","shiftHighlight","isHorizontal","getSelectedIndex","selectOption","tryRemoveNode","nodeAfterCursor","nodeId","onRemove","newInputLength","inputType","wordBeforCursor","getInlineElementBeforeCursor","inlineElementBefore","inlineElementAfter","replacementNode_1","wordFromRange","wordFromCache","nodeOffset","suggestionsLabel","selectedIndex","suggestionLabelPrefix"],"mappings":"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","file":"rooster-amd-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 84);\n","export { default as NodeBlockElement } from './blockElements/NodeBlockElement';\r\nexport { default as getBlockElementAtNode } from './blockElements/getBlockElementAtNode';\r\nexport { default as getFirstLastBlockElement } from './blockElements/getFirstLastBlockElement';\r\nexport { default as StartEndBlockElement } from './blockElements/StartEndBlockElement';\r\n\r\nexport { default as ContentTraverser } from './contentTraverser/ContentTraverser';\r\nexport { default as PositionContentSearcher } from './contentTraverser/PositionContentSearcher';\r\n\r\nexport { default as getInlineElementAtNode } from './inlineElements/getInlineElementAtNode';\r\nexport { default as ImageInlineElement } from './inlineElements/ImageInlineElement';\r\nexport { default as LinkInlineElement } from './inlineElements/LinkInlineElement';\r\nexport { default as NodeInlineElement } from './inlineElements/NodeInlineElement';\r\nexport { default as PartialInlineElement } from './inlineElements/PartialInlineElement';\r\n\r\nexport { default as applyTextStyle } from './utils/applyTextStyle';\r\nexport { Browser, getBrowserInfo } from './utils/Browser';\r\nexport { default as applyFormat } from './utils/applyFormat';\r\nexport { default as changeElementTag } from './utils/changeElementTag';\r\nexport { default as collapseNodes } from './utils/collapseNodes';\r\nexport { default as contains } from './utils/contains';\r\nexport { default as extractClipboardEvent } from './utils/extractClipboardEvent';\r\nexport { default as findClosestElementAncestor } from './utils/findClosestElementAncestor';\r\nexport { default as fromHtml } from './utils/fromHtml';\r\nexport { default as getComputedStyles, getComputedStyle } from './utils/getComputedStyles';\r\nexport {\r\n    default as getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from './utils/getPendableFormatState';\r\nexport { default as getTagOfNode } from './utils/getTagOfNode';\r\nexport { default as isBlockElement } from './utils/isBlockElement';\r\nexport { default as isNodeEmpty } from './utils/isNodeEmpty';\r\nexport { default as isRtl } from './utils/isRtl';\r\nexport { default as isVoidHtmlElement } from './utils/isVoidHtmlElement';\r\nexport { default as matchLink } from './utils/matchLink';\r\nexport { default as adjustNodeInsertPosition } from './utils/adjustNodeInsertPosition';\r\nexport { default as queryElements } from './utils/queryElements';\r\nexport { default as splitParentNode, splitBalancedNodeRange } from './utils/splitParentNode';\r\nexport { default as unwrap } from './utils/unwrap';\r\nexport { default as wrap } from './utils/wrap';\r\nexport { getNextLeafSibling, getPreviousLeafSibling } from './utils/getLeafSibling';\r\nexport { getFirstLeafNode, getLastLeafNode } from './utils/getLeafNode';\r\nexport { default as getTextContent } from './utils/getTextContent';\r\nexport { default as splitTextNode } from './utils/splitTextNode';\r\nexport { default as toArray } from './utils/toArray';\r\n\r\nexport { default as VTable, VCell } from './table/VTable';\r\n\r\nexport { default as Position } from './selection/Position';\r\nexport { default as createRange, getRangeFromSelectionPath } from './selection/createRange';\r\nexport { default as getPositionRect } from './selection/getPositionRect';\r\nexport { default as isPositionAtBeginningOf } from './selection/isPositionAtBeginningOf';\r\nexport { default as getSelectionPath } from './selection/getSelectionPath';\r\nexport { default as getHtmlWithSelectionPath } from './selection/getHtmlWithSelectionPath';\r\nexport { default as setHtmlWithSelectionPath } from './selection/setHtmlWithSelectionPath';\r\n\r\nexport { default as addSnapshot } from './snapshots/addSnapshot';\r\nexport { default as canMoveCurrentSnapshot } from './snapshots/canMoveCurrentSnapshot';\r\nexport { default as clearProceedingSnapshots } from './snapshots/clearProceedingSnapshots';\r\nexport { default as moveCurrentSnapsnot } from './snapshots/moveCurrentSnapsnot';\r\nexport { default as createSnapshots } from './snapshots/createSnapshots';\r\n","export { default as isDocumentFragment } from './typeUtils/isDocumentFragment';\nexport { default as isHTMLElement } from './typeUtils/isHTMLElement';\nexport { default as isHTMLOListElement } from './typeUtils/isHTMLOListElement';\nexport { default as isHTMLTableCellElement } from './typeUtils/isHTMLTableCellElement';\nexport { default as isHTMLTableElement } from './typeUtils/isHTMLTableElement';\nexport { default as isNode } from './typeUtils/isNode';\nexport { default as isRange } from './typeUtils/isRange';\nexport { default as safeInstanceOf } from './typeUtils/safeInstanceOf';\nexport { default as TargetWindow } from './types/TargetWindow';\n","// Interfaces\r\nexport {\r\n    ContentEditFeature,\r\n    GenericContentEditFeature,\r\n    Keys,\r\n} from './interfaces/ContentEditFeature';\r\nexport { default as CustomData, CustomDataMap } from './interfaces/CustomData';\r\nexport {\r\n    default as EditorCore,\r\n    CorePlugins,\r\n    CoreApiMap,\r\n    AttachDomEvent,\r\n    EditWithUndo,\r\n    Focus,\r\n    GetCustomData,\r\n    GetSelectionRange,\r\n    HasFocus,\r\n    InsertNode,\r\n    Select,\r\n    SelectRange,\r\n    TriggerEvent,\r\n} from './interfaces/EditorCore';\r\nexport { default as EditorOptions } from './interfaces/EditorOptions';\r\nexport { default as EditorPlugin } from './interfaces/EditorPlugin';\r\nexport { default as UndoService } from './interfaces/UndoService';\r\nexport { default as UndoSnapshotsService } from './interfaces/UndoSnapshotsService';\r\n\r\n// Classes\r\nexport { default as Editor } from './editor/Editor';\r\nexport { default as Undo } from './undo/Undo';\r\n\r\n// Core Plugins\r\nexport { default as EditPlugin } from './corePlugins/EditPlugin';\r\nexport { default as MouseUpPlugin } from './corePlugins/MouseUpPlugin';\r\nexport { default as DOMEventPlugin } from './corePlugins/DOMEventPlugin';\r\nexport { default as TypeInContainerPlugin } from './corePlugins/TypeInContainerPlugin';\r\nexport { default as FirefoxTypeAfterLink } from './corePlugins/FirefoxTypeAfterLink';\r\nexport { default as CopyPlugin } from './corePlugins/CopyPlugin';\r\n\r\n// Event APIs\r\nexport { default as cacheGetEventData } from './eventApi/cacheGetEventData';\r\nexport { default as clearEventDataCache } from './eventApi/clearEventDataCache';\r\nexport {\r\n    cacheGetContentSearcher,\r\n    clearContentSearcherCache,\r\n} from './eventApi/cacheGetContentSearcher';\r\nexport { default as cacheGetElementAtCursor } from './eventApi/cacheGetElementAtCursor';\r\nexport { default as isModifierKey } from './eventApi/isModifierKey';\r\nexport { default as isCharacterValue } from './eventApi/isCharacterValue';\r\nexport { default as isCtrlOrMetaPressed } from './eventApi/isCtrlOrMetaPressed';\r\n","import { isRange } from 'roosterjs-cross-window';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Test if a node contains another node\r\n * @param container The container node\r\n * @param contained The node to check if it is inside container\r\n * @param treatSameNodeAsContain When container and contained are the same node,\r\n * return true if this param is set to true, otherwise return false. Default value is false\r\n * @returns True if contained is insied container, or they are the same node when treatSameNodeAsContain is true.\r\n * Otherwise false.\r\n */\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean;\r\n\r\n/**\r\n * Test if a node contains a given range\r\n * @param container The container node\r\n * @param contained The range to check if it is inside container\r\n * @returns True if contained is insied container, otherwise false\r\n */\r\nexport default function contains(container: Node, contained: Range): boolean;\r\n\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node | Range,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean {\r\n    if (!container || !contained) {\r\n        return false;\r\n    }\r\n\r\n    if (treatSameNodeAsContain && container == contained) {\r\n        return true;\r\n    }\r\n\r\n    if (isRange(contained)) {\r\n        contained = contained && contained.commonAncestorContainer;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (contained && contained.nodeType == NodeType.Text) {\r\n        contained = contained.parentNode;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (container.nodeType != NodeType.Element) {\r\n        return !!treatSameNodeAsContain && container == contained;\r\n    }\r\n\r\n    return !!(treatSameNodeAsContain || container != contained) && container.contains(contained);\r\n}\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the html tag of a node, or empty if it is not an element\r\n * @param node The node to get tag of\r\n * @returns Tag name in upper case if the given node is an Element, or empty string otherwise\r\n */\r\nexport default function getTagOfNode(node: Node): string {\r\n    return node && node.nodeType == NodeType.Element ? (<Element>node).tagName.toUpperCase() : '';\r\n}\r\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a position in DOM tree by the node and its offset index\r\n */\r\nexport default class Position implements NodePosition {\r\n    readonly node: Node;\r\n    readonly element: HTMLElement;\r\n    readonly offset: number;\r\n    readonly isAtEnd: boolean;\r\n\r\n    /**\r\n     * Clone and validate a position from existing position.\r\n     * If the given position has invalid offset, this function will return a corrected value.\r\n     * @param position The original position to clone from\r\n     */\r\n    constructor(position: NodePosition);\r\n\r\n    /**\r\n     * Create a Position from node and an offset number\r\n     * @param node The node of this position\r\n     * @param offset Offset of this position\r\n     */\r\n    constructor(node: Node, offset: number);\r\n\r\n    /**\r\n     * Create a Position from node and a type of position\r\n     * @param node The node of this position\r\n     * @param positionType Type of the postion, can be Begin, End, Before, After\r\n     */\r\n    constructor(node: Node, positionType: PositionType);\r\n\r\n    constructor(nodeOrPosition: Node | NodePosition, offsetOrPosType?: number) {\r\n        if ((<NodePosition>nodeOrPosition).node) {\r\n            this.node = (<NodePosition>nodeOrPosition).node;\r\n            offsetOrPosType = (<NodePosition>nodeOrPosition).offset;\r\n        } else {\r\n            this.node = <Node>nodeOrPosition;\r\n        }\r\n\r\n        switch (offsetOrPosType) {\r\n            case PositionType.Before:\r\n                this.offset = getIndexOfNode(this.node);\r\n                this.node = this.node.parentNode;\r\n                this.isAtEnd = false;\r\n                break;\r\n\r\n            case PositionType.After:\r\n                this.offset = getIndexOfNode(this.node) + 1;\r\n                this.isAtEnd = !this.node.nextSibling;\r\n                this.node = this.node.parentNode;\r\n                break;\r\n\r\n            case PositionType.End:\r\n                this.offset = getEndOffset(this.node);\r\n                this.isAtEnd = true;\r\n                break;\r\n\r\n            default:\r\n                let endOffset = getEndOffset(this.node);\r\n                this.offset = Math.max(0, Math.min(<number>offsetOrPosType, endOffset));\r\n                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;\r\n                break;\r\n        }\r\n\r\n        this.element = findClosestElementAncestor(this.node);\r\n    }\r\n\r\n    /**\r\n     * Normalize this position to the leaf node, return the normalize result.\r\n     * If current position is already using leaf node, return this position object itself\r\n     */\r\n    normalize(): NodePosition {\r\n        if (this.node.nodeType == NodeType.Text || !this.node.firstChild) {\r\n            return this;\r\n        }\r\n\r\n        let node = this.node;\r\n        let newOffset: number | PositionType.Begin | PositionType.End = this.isAtEnd\r\n            ? PositionType.End\r\n            : this.offset;\r\n        while (node.nodeType == NodeType.Element) {\r\n            const nextNode =\r\n                newOffset == PositionType.Begin\r\n                    ? node.firstChild\r\n                    : newOffset == PositionType.End\r\n                    ? node.lastChild\r\n                    : node.childNodes[<number>newOffset];\r\n\r\n            if (nextNode) {\r\n                node = nextNode;\r\n                newOffset = this.isAtEnd ? PositionType.End : PositionType.Begin;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return new Position(node, newOffset);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is equal to the given position\r\n     * @param position The position to check\r\n     */\r\n    equalTo(position: NodePosition): boolean {\r\n        return (\r\n            position &&\r\n            (this == position ||\r\n                (this.node == position.node &&\r\n                    this.offset == position.offset &&\r\n                    this.isAtEnd == position.isAtEnd))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if this position is after the given position\r\n     */\r\n    isAfter(position: NodePosition): boolean {\r\n        return this.node == position.node\r\n            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset\r\n            : isNodeAfter(this.node, position.node);\r\n    }\r\n\r\n    /**\r\n     * Move this position with offset, returns a new position with a valid offset in the same node\r\n     * @param offset Offset to move with\r\n     */\r\n    move(offset: number) {\r\n        return new Position(this.node, Math.max(this.offset + offset, 0));\r\n    }\r\n\r\n    /**\r\n     * Get start position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getStart(range: Range) {\r\n        return new Position(range.startContainer, range.startOffset);\r\n    }\r\n\r\n    /**\r\n     * Get end position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getEnd(range: Range) {\r\n        return new Position(range.endContainer, range.endOffset);\r\n    }\r\n}\r\n\r\nfunction getIndexOfNode(node: Node): number {\r\n    let i = 0;\r\n    while ((node = node.previousSibling)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nfunction getEndOffset(node: Node): number {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return node.nodeValue.length;\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return node.childNodes.length;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n","import TargetWindow from '../types/TargetWindow';\n\n// NOTE: Type TargetWindow is an auto-generated type.\n// Run node ./tools/generateTargetWindow.js to generate it.\n\n/**\n * Try get window from the given node or range\n * @param source Source node or range\n */\nexport function getTargetWindow(source: Node | Range): TargetWindow {\n    const node = source && ((<Range>source).commonAncestorContainer || <Node>source);\n    const document =\n        node &&\n        (node.ownerDocument ||\n            (Object.prototype.toString.apply(node) == '[object HTMLDocument]'\n                ? <Document>node\n                : null));\n\n    // If document exists but document.defaultView doesn't exist, it is a detached object, just use current window instead\n    const targetWindow = document && ((document.defaultView || window) as any);\n    return targetWindow as TargetWindow;\n}\n\n/**\n * Check if the given object is instance of the target type\n * @param obj Object to check\n * @param typeName Target type name\n */\nexport default function safeInstanceOf<T extends keyof TargetWindow>(\n    obj: Node | Range,\n    typeName: T\n): obj is TargetWindow[T] {\n    const targetWindow = getTargetWindow(obj);\n    const targetType = targetWindow && (targetWindow[typeName] as any);\n    const mainWindow = (window as any) as TargetWindow;\n    const mainWindowType = mainWindow && (mainWindow[typeName] as any);\n    return (\n        (mainWindowType && obj instanceof mainWindowType) ||\n        (targetType && obj instanceof targetType)\n    );\n}\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport NodeBlockElement from './NodeBlockElement';\r\nimport StartEndBlockElement from './StartEndBlockElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This produces a block element from a a node\r\n * It needs to account for various HTML structure. Examples:\r\n * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;\r\n *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;\r\n * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;\r\n *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;\r\n * 3) &lt;root&gt;abc&lt;/root&gt;\r\n *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc\r\n *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node\r\n * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;\r\n *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:\r\n *   block1: 1) abc&lt;br&gt; block2: 123\r\n * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;\r\n * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;\r\n *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456\r\n * In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:\r\n * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered\r\n * 2) same for identifying tail\r\n * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node\r\n * @param rootNode Root node of the scope, the block element will be inside of this node\r\n * @param node The node to get BlockElement start from\r\n */\r\nexport default function getBlockElementAtNode(rootNode: Node, node: Node): BlockElement {\r\n    if (!contains(rootNode, node)) {\r\n        return null;\r\n    }\r\n\r\n    // Identify the containing block. This serves as ceiling for traversing down below\r\n    // NOTE: this container block could be just the rootNode,\r\n    // which cannot be used to create block element. We will special case handle it later on\r\n    let containerBlockNode = StartEndBlockElement.getBlockContext(node);\r\n    if (containerBlockNode == node) {\r\n        return new NodeBlockElement(containerBlockNode);\r\n    }\r\n\r\n    // Find the head and leaf node in the block\r\n    let headNode = findHeadTailLeafNode(node, containerBlockNode, false /*isTail*/);\r\n    let tailNode = findHeadTailLeafNode(node, containerBlockNode, true /*isTail*/);\r\n\r\n    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to\r\n    // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;\r\n    // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style=\"font-family: Arial\"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world\r\n    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block\r\n    // So we shall try to collapse as much as we can to the nearest common ancester\r\n    let nodes = collapseNodes(rootNode, headNode, tailNode, false /*canSplitParent*/);\r\n    headNode = nodes[0];\r\n    tailNode = nodes[nodes.length - 1];\r\n\r\n    if (headNode.parentNode != tailNode.parentNode) {\r\n        // Un-Balanced start and end, create a start-end block\r\n        return new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    } else {\r\n        // Balanced start and end (point to same parent), need to see if further collapsing can be done\r\n        while (!headNode.previousSibling && !tailNode.nextSibling) {\r\n            let parentNode = headNode.parentNode;\r\n            if (parentNode == containerBlockNode) {\r\n                // Has reached the container block\r\n                if (containerBlockNode != rootNode) {\r\n                    // If the container block is not the root, use the container block\r\n                    headNode = tailNode = parentNode;\r\n                }\r\n                break;\r\n            } else {\r\n                // Continue collapsing to parent\r\n                headNode = tailNode = parentNode;\r\n            }\r\n        }\r\n\r\n        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block\r\n        return headNode == tailNode && isBlockElement(headNode)\r\n            ? new NodeBlockElement(headNode as HTMLElement)\r\n            : new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    }\r\n}\r\n\r\n/**\r\n * Given a node and container block, identify the first/last leaf node\r\n * A leaf node is defined as deepest first/last node in a block\r\n * i.e. &lt;div&gt;&lt;span style=\"font-family: Arial\"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block\r\n * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf\r\n * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;\r\n * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;\r\n */\r\nfunction findHeadTailLeafNode(node: Node, containerBlockNode: Node, isTail: boolean): Node {\r\n    let result = node;\r\n\r\n    if (getTagOfNode(result) == 'BR' && isTail) {\r\n        return result;\r\n    }\r\n\r\n    while (result) {\r\n        let sibling = node;\r\n        while (!(sibling = isTail ? node.nextSibling : node.previousSibling)) {\r\n            node = node.parentNode;\r\n            if (node == containerBlockNode) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        while (sibling) {\r\n            if (isBlockElement(sibling)) {\r\n                return result;\r\n            } else if (getTagOfNode(sibling) == 'BR') {\r\n                return isTail ? sibling : result;\r\n            }\r\n\r\n            node = sibling;\r\n            sibling = isTail ? node.firstChild : node.lastChild;\r\n        }\r\n\r\n        result = node;\r\n    }\r\n    return result;\r\n}\r\n","import { ChangeSource, DocumentCommand, PluginEventType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from 'roosterjs-editor-dom';\r\n\r\nlet pendableFormatCommands: string[] = null;\r\n\r\n/**\r\n * Execute a document command\r\n * @param editor The editor instance\r\n * @param command The command to execute\r\n * @param addUndoSnapshotWhenCollapsed Optional, set to true to always add undo snapshot even current selection is collapsed.\r\n * Default value is false.\r\n * @param doWorkaroundForList Optional, set to true to do workaround for list in order to keep current format.\r\n * Default value is false.\r\n */\r\nexport default function execCommand(editor: Editor, command: DocumentCommand) {\r\n    editor.focus();\r\n    let formatter = () => editor.getDocument().execCommand(command, false, null);\r\n\r\n    let range = editor.getSelectionRange();\r\n    if (range && range.collapsed) {\r\n        editor.addUndoSnapshot();\r\n        formatter();\r\n\r\n        if (isPendableFormatCommand(command)) {\r\n            // Trigger PendingFormatStateChanged event since we changed pending format state\r\n            editor.triggerPluginEvent(PluginEventType.PendingFormatStateChanged, {\r\n                formatState: getPendableFormatState(editor.getDocument()),\r\n            });\r\n        }\r\n    } else {\r\n        editor.addUndoSnapshot(formatter, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction isPendableFormatCommand(command: DocumentCommand): boolean {\r\n    if (!pendableFormatCommands) {\r\n        pendableFormatCommands = Object.keys(PendableFormatCommandMap).map(\r\n            key => PendableFormatCommandMap[key as PendableFormatNames]\r\n        );\r\n    }\r\n    return pendableFormatCommands.indexOf(command) >= 0;\r\n}\r\n","import isVoidHtmlElement from '../utils/isVoidHtmlElement';\r\nimport Position from './Position';\r\nimport { isNode } from 'roosterjs-cross-window';\r\nimport { NodePosition, NodeType, PositionType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create a range around the given node(s)\r\n * @param startNode The start node to create range from\r\n * @param endNode The end node to create range from. If specified, the range will start before startNode and\r\n * end after endNode, otherwise, the range will start before and end after the start node\r\n * @returns A range start before the given node and end after the given node\r\n */\r\nexport default function createRange(startNode: Node, endNode?: Node): Range;\r\n\r\n/**\r\n * Create a collapsed range at the given node and offset\r\n * @param node The container node of the range\r\n * @param offset The offset of the range, can be a number or value of PositionType\r\n * @returns A range at the given node and offset\r\n */\r\nexport default function createRange(node: Node, offset: number | PositionType): Range;\r\n\r\n/**\r\n * Create a range with the given start/end container node and offset\r\n * @param startNode The start container node of the range\r\n * @param startOffset The start offset of the range\r\n * @param endNode The end container node of the range\r\n * @param endOffset The end offset of the range\r\n * @returns A range at the given start/end container node and offset\r\n */\r\nexport default function createRange(\r\n    startNode: Node,\r\n    startOffset: number | PositionType,\r\n    endNode: Node,\r\n    endOffset: number | PositionType\r\n): Range;\r\n\r\n/**\r\n * Create a range under the given rootNode with start and end selection paths\r\n * @param rootNode The root node that the selection paths start from\r\n * @param startPath The selection path of the start position of the range\r\n * @param endPath The selection path of the end position of the range\r\n * @returns A range with the given start and end selection paths\r\n */\r\nexport default function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n\r\n/**\r\n * Create a range with the start and end position\r\n * @param startPosition The start position of the range\r\n * @param endPosition The end position of the range, if not specified, the range will be collapsed at start position\r\n * @returns A range start at startPosition, end at endPosition, or startPosition when endPosition is not specified\r\n */\r\nexport default function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n\r\nexport default function createRange(\r\n    arg1: Node | NodePosition,\r\n    arg2?: number | number[] | Node | NodePosition,\r\n    arg3?: Node | number[],\r\n    arg4?: number\r\n): Range {\r\n    let start: NodePosition;\r\n    let end: NodePosition;\r\n\r\n    if (isNodePosition(arg1)) {\r\n        // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n        start = arg1;\r\n        end = isNodePosition(arg2) ? arg2 : null;\r\n    } else if (isNode(arg1)) {\r\n        if (Array.isArray(arg2)) {\r\n            // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n            start = getPositionFromPath(arg1, arg2);\r\n            end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;\r\n        } else if (typeof arg2 == 'number') {\r\n            // function createRange(node: Node, offset: number | PositionType): Range;\r\n            // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;\r\n            start = new Position(arg1, arg2);\r\n            end = isNode(arg3) ? new Position(arg3, arg4) : null;\r\n        } else if (isNode(arg2) || !arg2) {\r\n            // function createRange(startNode: Node, endNode?: Node): Range;\r\n            start = new Position(arg1, PositionType.Before);\r\n            end = new Position(<Node>arg2 || arg1, PositionType.After);\r\n        }\r\n    }\r\n\r\n    if (start && start.node) {\r\n        let range = start.node.ownerDocument.createRange();\r\n        start = getFocusablePosition(start);\r\n        end = getFocusablePosition(end || start);\r\n        range.setStart(start.node, start.offset);\r\n        range.setEnd(end.node, end.offset);\r\n\r\n        return range;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Convert to focusable position\r\n * If current node is a void element, we need to move up one level to put cursor outside void element\r\n */\r\nfunction getFocusablePosition(position: NodePosition) {\r\n    return position.node.nodeType == NodeType.Element && isVoidHtmlElement(position.node)\r\n        ? new Position(position.node, position.isAtEnd ? PositionType.After : PositionType.Before)\r\n        : position;\r\n}\r\n\r\nfunction isNodePosition(arg: any): arg is NodePosition {\r\n    return arg && arg.node;\r\n}\r\n\r\nfunction getPositionFromPath(node: Node, path: number[]): NodePosition {\r\n    if (!node || !path) {\r\n        return null;\r\n    }\r\n\r\n    // Iterate with a for loop to avoid mutating the passed in element path stack\r\n    // or needing to copy it.\r\n    let offset: number;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        offset = path[i];\r\n        if (\r\n            i < path.length - 1 &&\r\n            node &&\r\n            node.nodeType == NodeType.Element &&\r\n            node.childNodes.length > offset\r\n        ) {\r\n            node = node.childNodes[offset];\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return new Position(node, offset);\r\n}\r\n\r\n/**\r\n * @deprecated Use createRange instead\r\n * Get range from the given selection path\r\n * @param rootNode Root node of the selection path\r\n * @param path The selection path which contains start and end position path\r\n */\r\nexport function getRangeFromSelectionPath(rootNode: HTMLElement, path: SelectionPath) {\r\n    return createRange(rootNode, path.start, path.end);\r\n}\r\n","export { default as changeFontSize, FONT_SIZES } from './format/changeFontSize';\r\nexport {\r\n    default as clearBlockFormat,\r\n    TAGS_TO_UNWRAP,\r\n    TAGS_TO_STOP_UNWRAP,\r\n    ATTRIBUTES_TO_PRESERVE,\r\n} from './format/clearBlockFormat';\r\nexport { default as clearFormat } from './format/clearFormat';\r\nexport { default as createLink } from './format/createLink';\r\nexport {\r\n    default as getFormatState,\r\n    getElementBasedFormatState,\r\n    getStyleBasedFormatState,\r\n} from './format/getFormatState';\r\nexport { default as insertImage } from './format/insertImage';\r\nexport { default as insertTable } from './table/insertTable';\r\nexport { default as editTable } from './table/editTable';\r\nexport { default as formatTable } from './table/formatTable';\r\nexport { default as removeLink } from './format/removeLink';\r\nexport { default as replaceWithNode } from './format/replaceWithNode';\r\nexport { default as setAlignment } from './format/setAlignment';\r\nexport { default as setBackgroundColor } from './format/setBackgroundColor';\r\nexport { default as setTextColor } from './format/setTextColor';\r\nexport { default as setDirection } from './format/setDirection';\r\nexport { default as setFontName } from './format/setFontName';\r\nexport { default as setFontSize } from './format/setFontSize';\r\nexport { default as setImageAltText } from './format/setImageAltText';\r\nexport { default as setIndentation } from './format/setIndentation';\r\nexport { default as toggleBold } from './format/toggleBold';\r\nexport { default as toggleBullet } from './format/toggleBullet';\r\nexport { default as toggleItalic } from './format/toggleItalic';\r\nexport { default as toggleNumbering } from './format/toggleNumbering';\r\nexport { default as toggleBlockQuote } from './format/toggleBlockQuote';\r\nexport { default as toggleCodeBlock } from './format/toggleCodeBlock';\r\nexport { default as toggleStrikethrough } from './format/toggleStrikethrough';\r\nexport { default as toggleSubscript } from './format/toggleSubscript';\r\nexport { default as toggleSuperscript } from './format/toggleSuperscript';\r\nexport { default as toggleUnderline } from './format/toggleUnderline';\r\nexport { default as toggleHeader } from './format/toggleHeader';\r\n\r\n// @deprecated the function getPendableFormatState will still be available from\r\n// roosterjs-editor-dom package, keep export it here just for compatibility\r\nexport { getPendableFormatState } from 'roosterjs-editor-dom';\r\n","export { default as HtmlSanitizer } from './sanitizer/HtmlSanitizer';\r\nexport { default as HtmlSanitizerOptions } from './types/HtmlSanitizerOptions';\r\nexport { default as SanitizeHtmlOptions } from './types/SanitizeHtmlOptions';\r\nexport { default as htmlToDom, splitWithFragment } from './utils/htmlToDom';\r\nexport { default as getInheritableStyles } from './utils/getInheritableStyles';\r\nexport {\r\n    AttributeCallback,\r\n    AttributeCallbackMap,\r\n    ElementCallback,\r\n    Map,\r\n    StringMap,\r\n    StyleCallback,\r\n    StyleCallbackMap,\r\n    ElementCallbackMap,\r\n} from './types/maps';\r\n","/**\n * Convert a named node map to an array\n * @param collection The map to convert\n */\nexport default function toArray(collection: NamedNodeMap): Attr[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Node>(collection: NodeListOf<T>): T[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Element>(collection: HTMLCollectionOf<T>): T[];\n\n/**\n * Convert an array to an array.\n * This is to satisfy typescript compiler. For some cases the object can be a collection at runtime,\n * but the declaration is an array. e.g. ClipboardData.types\n * @param array The array to convert\n */\nexport default function toArray<T>(array: readonly T[]): T[];\n\nexport default function toArray(collection: any): any[] {\n    return [].slice.call(collection);\n}\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport ImageInlineElement from './ImageInlineElement';\r\nimport LinkInlineElement from './LinkInlineElement';\r\nimport NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\nimport { isNode } from 'roosterjs-cross-window';\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param rootNode The root node of current scope\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(rootNode: Node, node: Node): InlineElement;\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param parentBlock Parent BlockElement of this node\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(\r\n    parentBlock: BlockElement,\r\n    node: Node\r\n): InlineElement;\r\n\r\nexport default function getInlineElementAtNode(\r\n    parent: Node | BlockElement,\r\n    node: Node\r\n): InlineElement {\r\n    // An inline element has to be in a block element, get the block first and then resolve through the factory\r\n    let parentBlock = isNode(parent) ? getBlockElementAtNode(parent, node) : parent;\r\n    return node && parentBlock && resolveInlineElement(node, parentBlock);\r\n}\r\n\r\n/**\r\n * Resolve an inline element by a leaf node\r\n * @param node The node to resolve from\r\n * @param parentBlock The parent block element\r\n */\r\nfunction resolveInlineElement(node: Node, parentBlock: BlockElement): InlineElement {\r\n    let nodeChain = [node];\r\n    for (\r\n        let parent = node.parentNode;\r\n        parent && parentBlock.contains(parent);\r\n        parent = parent.parentNode\r\n    ) {\r\n        nodeChain.push(parent);\r\n    }\r\n\r\n    let inlineElement: InlineElement;\r\n\r\n    for (let i = nodeChain.length - 1; i >= 0 && !inlineElement; i--) {\r\n        let currentNode = nodeChain[i];\r\n        let tag = getTagOfNode(currentNode);\r\n        if (tag == 'A') {\r\n            inlineElement = new LinkInlineElement(currentNode, parentBlock);\r\n        } else if (tag == 'IMG') {\r\n            inlineElement = new ImageInlineElement(currentNode, parentBlock);\r\n        }\r\n    }\r\n\r\n    return inlineElement || new NodeInlineElement(node, parentBlock);\r\n}\r\n","import contains from './contains';\r\nimport shouldSkipNode from './shouldSkipNode';\r\n\r\n/**\r\n * This walks forwards/backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node\r\n */\r\nexport function getLeafSibling(rootNode: Node, startNode: Node, isNext: boolean): Node {\r\n    let result = null;\r\n    let getSibling = isNext\r\n        ? (node: Node) => node.nextSibling\r\n        : (node: Node) => node.previousSibling;\r\n    let getChild = isNext ? (node: Node) => node.firstChild : (node: Node) => node.lastChild;\r\n    if (contains(rootNode, startNode)) {\r\n        let curNode = startNode;\r\n        let shouldContinue = true;\r\n\r\n        while (shouldContinue) {\r\n            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent\r\n            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)\r\n            let parentNode = curNode.parentNode;\r\n            curNode = getSibling(curNode);\r\n            while (!curNode && parentNode != rootNode) {\r\n                curNode = getSibling(parentNode);\r\n                parentNode = parentNode.parentNode;\r\n            }\r\n\r\n            // Now traverse down to get first/last child\r\n            while (curNode && getChild(curNode)) {\r\n                curNode = getChild(curNode);\r\n            }\r\n\r\n            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so\r\n            shouldContinue = curNode && shouldSkipNode(curNode);\r\n            if (!shouldContinue) {\r\n                // Found a good leaf node, assign and exit\r\n                result = curNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This walks forwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n */\r\nexport function getNextLeafSibling(rootNode: Node, startNode: Node): Node {\r\n    return getLeafSibling(rootNode, startNode, true /*isNext*/);\r\n}\r\n\r\n/**\r\n * This walks backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n */\r\nexport function getPreviousLeafSibling(rootNode: Node, startNode: Node): Node {\r\n    return getLeafSibling(rootNode, startNode, false /*isNext*/);\r\n}\r\n","import { DocumentPosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Checks if node1 is after node2\r\n * @param node1 The node to check if it is after another node\r\n * @param node2 The node to check if another node is after this one\r\n * @returns True if node1 is after node2, otherwise false\r\n */\r\nexport default function isNodeAfter(node1: Node, node2: Node): boolean {\r\n    return !!(\r\n        node1 &&\r\n        node2 &&\r\n        (node2.compareDocumentPosition(node1) & DocumentPosition.Following) ==\r\n            DocumentPosition.Following\r\n    );\r\n}\r\n","import isNodeAfter from './isNodeAfter';\r\n\r\n/**\r\n * Split parent node of the given node before/after the given node.\r\n * When a parent node contains [A,B,C] and pass B as the given node,\r\n * If split before, the new nodes will be [A][B,C] and returns [A];\r\n * otherwise, it will be [A,B][C] and returns [C].\r\n * @param node The node to split before/after\r\n * @param splitBefore Whether split before or after\r\n * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),\r\n * we remove it. @default false\r\n * @returns The new parent node\r\n */\r\nexport default function splitParentNode(node: Node, splitBefore: boolean): Node {\r\n    if (!node || !node.parentNode) {\r\n        return null;\r\n    }\r\n\r\n    let parentNode = node.parentNode;\r\n    let newParent = parentNode.cloneNode(false /*deep*/) as HTMLElement;\r\n    newParent.removeAttribute('id');\r\n    if (splitBefore) {\r\n        while (parentNode.firstChild && parentNode.firstChild != node) {\r\n            newParent.appendChild(parentNode.firstChild);\r\n        }\r\n    } else {\r\n        while (node.nextSibling) {\r\n            newParent.appendChild(node.nextSibling);\r\n        }\r\n    }\r\n\r\n    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true\r\n    if (newParent.firstChild && newParent.innerHTML != '') {\r\n        parentNode.parentNode.insertBefore(\r\n            newParent,\r\n            splitBefore ? parentNode : parentNode.nextSibling\r\n        );\r\n    } else {\r\n        newParent = null;\r\n    }\r\n\r\n    return newParent;\r\n}\r\n\r\n/**\r\n * Split parent node by a balanced node range\r\n * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.\r\n * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored\r\n * @returns The parent node of the given node range if the given nodes are balanced, otherwise null\r\n */\r\nexport function splitBalancedNodeRange(nodes: Node | Node[]): HTMLElement {\r\n    let start = Array.isArray(nodes) ? nodes[0] : nodes;\r\n    let end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;\r\n    let parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;\r\n    if (parentNode) {\r\n        if (isNodeAfter(start, end)) {\r\n            let temp = end;\r\n            end = start;\r\n            start = temp;\r\n        }\r\n        splitParentNode(start, true /*splitBefore*/);\r\n        splitParentNode(end, false /*splitBefore*/);\r\n    }\r\n\r\n    return parentNode as HTMLElement;\r\n}\r\n","import { applyTextStyle, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { ChangeSource, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\nconst ZERO_WIDTH_SPACE = '\\u200B';\r\n\r\n/**\r\n * Apply inline style to current selection\r\n * @param editor The editor instance\r\n * @param callback The callback function to apply style\r\n */\r\nexport default function applyInlineStyle(\r\n    editor: Editor,\r\n    callback: (element: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    editor.focus();\r\n    let range = editor.getSelectionRange();\r\n\r\n    if (range && range.collapsed) {\r\n        let node = range.startContainer;\r\n        let isEmptySpan =\r\n            getTagOfNode(node) == 'SPAN' &&\r\n            (!node.firstChild ||\r\n                (getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));\r\n        if (isEmptySpan) {\r\n            editor.addUndoSnapshot();\r\n            callback(node as HTMLElement);\r\n        } else {\r\n            let isZWSNode =\r\n                node &&\r\n                node.nodeType == NodeType.Text &&\r\n                node.nodeValue == ZERO_WIDTH_SPACE &&\r\n                getTagOfNode(node.parentNode) == 'SPAN';\r\n\r\n            if (!isZWSNode) {\r\n                editor.addUndoSnapshot();\r\n                // Create a new text node to hold the selection.\r\n                // Some content is needed to position selection into the span\r\n                // for here, we inject ZWS - zero width space\r\n                node = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);\r\n                range.insertNode(node);\r\n            }\r\n\r\n            applyTextStyle(node, callback);\r\n            editor.select(node, PositionType.End);\r\n        }\r\n    } else {\r\n        // This is start and end node that get the style. The start and end needs to be recorded so that selection\r\n        // can be re-applied post-applying style\r\n        editor.addUndoSnapshot(() => {\r\n            let firstNode: Node;\r\n            let lastNode: Node;\r\n            let contentTraverser = editor.getSelectionTraverser();\r\n            let inlineElement = contentTraverser && contentTraverser.currentInlineElement;\r\n            while (inlineElement) {\r\n                let nextInlineElement = contentTraverser.getNextInlineElement();\r\n                inlineElement.applyStyle((element, isInnerNode) => {\r\n                    callback(element, isInnerNode);\r\n                    firstNode = firstNode || element;\r\n                    lastNode = element;\r\n                });\r\n                inlineElement = nextInlineElement;\r\n            }\r\n            if (firstNode && lastNode) {\r\n                editor.select(firstNode, PositionType.Before, lastNode, PositionType.After);\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import fromHtml from './fromHtml';\r\nimport { isHTMLElement, isNode } from 'roosterjs-cross-window';\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML tag name\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap<T extends keyof HTMLElementTagNameMap>(\r\n    nodes: Node | Node[],\r\n    wrapper?: T\r\n): HTMLElementTagNameMap[T];\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML string, default value is DIV\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string): HTMLElement;\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML element, default value is a new DIV element\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: HTMLElement): HTMLElement;\r\n\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string | HTMLElement): HTMLElement {\r\n    nodes = !nodes ? [] : isNode(nodes) ? [nodes] : nodes;\r\n    if (nodes.length == 0 || !nodes[0]) {\r\n        return null;\r\n    }\r\n\r\n    if (!isHTMLElement(wrapper)) {\r\n        let document = nodes[0].ownerDocument;\r\n        wrapper = wrapper || 'div';\r\n        wrapper = /^\\w+$/.test(wrapper)\r\n            ? document.createElement(wrapper)\r\n            : (fromHtml(wrapper, document)[0] as HTMLElement);\r\n    }\r\n\r\n    let parentNode = nodes[0].parentNode;\r\n\r\n    if (parentNode) {\r\n        parentNode.insertBefore(wrapper, nodes[0]);\r\n    }\r\n\r\n    for (let node of nodes) {\r\n        wrapper.appendChild(node);\r\n    }\r\n\r\n    return wrapper;\r\n}\r\n","import contains from './contains';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\ninterface HTMLElementForIE extends HTMLElement {\r\n    msMatchesSelector: (selector: string) => boolean;\r\n}\r\n\r\n/**\r\n * Find closest element ancestor start from the given node which matches the given selector\r\n * @param node Find ancestor start from this node\r\n * @param root Root node where the search should stop at. The return value can never be this node\r\n * @param selector The expected selector. If null, return the first HTML Element found from start node\r\n * @returns An HTML element which matches the given selector. If the given start node matches the selector,\r\n * returns the given node\r\n */\r\nexport default function findClosestElementAncestor(\r\n    node: Node,\r\n    root?: Node,\r\n    selector?: string\r\n): HTMLElement {\r\n    node = !node ? null : node.nodeType == NodeType.Element ? node : node.parentNode;\r\n    let element = node && node.nodeType == NodeType.Element ? <HTMLElement>node : null;\r\n\r\n    if (element && selector) {\r\n        if (element.closest) {\r\n            element = element.closest(selector) as HTMLElement;\r\n        } else {\r\n            while (\r\n                element &&\r\n                element != root &&\r\n                !(element.matches || (<HTMLElementForIE>element).msMatchesSelector).call(\r\n                    element,\r\n                    selector\r\n                )\r\n            ) {\r\n                element = element.parentElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    return !root || contains(root, element) ? element : null;\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport Position from '../selection/Position';\r\nimport {\r\n    BlockElement,\r\n    InlineElement,\r\n    NodePosition,\r\n    NodeType,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents an inline element that can be reprented by a single html node.\r\n * This serves as base for most inline element as it contains most implentation\r\n * of all operations that can happen on an inline element. Other sub inline elements mostly\r\n * just identify themself for a certain type\r\n */\r\nexport default class NodeInlineElement implements InlineElement {\r\n    constructor(private containerNode: Node, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * The text content for this inline element\r\n     */\r\n    public getTextContent(): string {\r\n        // nodeValue is better way to retrieve content for a text. Others, just use textContent\r\n        return this.containerNode.nodeType == NodeType.Text\r\n            ? this.containerNode.nodeValue\r\n            : this.containerNode.textContent;\r\n    }\r\n\r\n    /**\r\n     * Get the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.containerNode;\r\n    }\r\n\r\n    // Get the parent block\r\n    public getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of the inline element\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest first child node from the container\r\n        return new Position(this.containerNode, 0).normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the end position of the inline element\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest last child node from the container\r\n        return new Position(this.containerNode, PositionType.End).normalize();\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.containerNode && this.containerNode.nodeType == NodeType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks if an inline element is after the current inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if the given position is contained in the inline element\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        let start = this.getStartPosition();\r\n        let end = this.getEndPosition();\r\n        return pos && pos.isAfter(start) && end.isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to an inline element\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void {\r\n        applyTextStyle(this.containerNode, styler);\r\n    }\r\n}\r\n","import findClosestElementAncestor from './findClosestElementAncestor';\r\n\r\n/**\r\n * Get computed styles of a node\r\n * @param node The node to get computed styles from\r\n * @param styleNames Names of style to get, can be a single name or an array.\r\n * Default value is font-family, font-size, color, background-color\r\n * @returns An array of the computed styles\r\n */\r\nexport default function getComputedStyles(\r\n    node: Node,\r\n    styleNames: string | string[] = ['font-family', 'font-size', 'color', 'background-color']\r\n): string[] {\r\n    let element = findClosestElementAncestor(node);\r\n    let result: string[] = [];\r\n    styleNames = Array.isArray(styleNames) ? styleNames : [styleNames];\r\n    if (element) {\r\n        let win = element.ownerDocument.defaultView || window;\r\n        let styles = win.getComputedStyle(element);\r\n\r\n        if (styles) {\r\n            for (let style of styleNames) {\r\n                let value = (styles.getPropertyValue(style) || '').toLowerCase();\r\n                value = style == 'font-size' ? px2Pt(value) : value;\r\n                result.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * A shortcut for getComputedStyles() when only one style is to be retrieved\r\n * @param node The node to get style from\r\n * @param styleName The style name\r\n * @returns The style value\r\n */\r\nexport function getComputedStyle(node: Node, styleName: string): string {\r\n    return getComputedStyles(node, styleName)[0] || '';\r\n}\r\n\r\nfunction px2Pt(px: string) {\r\n    if (px && px.indexOf('px') == px.length - 2) {\r\n        // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value\r\n        // So add 0.05 to fix it\r\n        return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';\r\n    }\r\n    return px;\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { BlockElement, InlineElement, NodePosition, PositionType } from 'roosterjs-editor-types';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * This is a special version of inline element that identifies a section of an inline element\r\n * We often have the need to cut an inline element in half and perform some operation only on half of an inline element\r\n * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element\r\n * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter\r\n * It also offers some special methods that others don't have, i.e. nextInlineElement etc.\r\n */\r\nexport default class PartialInlineElement implements InlineElement {\r\n    constructor(\r\n        private inlineElement: InlineElement,\r\n        private start?: NodePosition,\r\n        private end?: NodePosition\r\n    ) {}\r\n\r\n    /**\r\n     * Get the full inline element that this partial inline decorates\r\n     */\r\n    public getDecoratedInline(): InlineElement {\r\n        return this.inlineElement;\r\n    }\r\n\r\n    /**\r\n     * Gets the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.inlineElement.getContainerNode();\r\n    }\r\n\r\n    /**\r\n     * Gets the parent block\r\n     */\r\n    public getParentBlock(): BlockElement {\r\n        return this.inlineElement.getParentBlock();\r\n    }\r\n\r\n    /**\r\n     * Gets the text content\r\n     */\r\n    public getTextContent(): string {\r\n        let range = createRange(this.getStartPosition(), this.getEndPosition());\r\n\r\n        return range.toString();\r\n    }\r\n\r\n    /**\r\n     * Get start position of this inline element.\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        return this.start || this.inlineElement.getStartPosition();\r\n    }\r\n\r\n    /**\r\n     * Get end position of this inline element.\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        return this.end || this.inlineElement.getEndPosition();\r\n    }\r\n\r\n    /**\r\n     * Get next partial inline element if it is not at the end boundary yet\r\n     */\r\n    public get nextInlineElement(): PartialInlineElement {\r\n        return this.end && new PartialInlineElement(this.inlineElement, this.end, null);\r\n    }\r\n\r\n    /**\r\n     * Get previous partial inline element if it is not at the begin boundary yet\r\n     */\r\n    public get previousInlineElement(): PartialInlineElement {\r\n        return this.start && new PartialInlineElement(this.inlineElement, null, this.start);\r\n    }\r\n\r\n    /**\r\n     * Checks if it contains a position\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.inlineElement && this.inlineElement.isTextualInlineElement();\r\n    }\r\n\r\n    /**\r\n     * Check if this inline element is after the other inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        let thisStart = this.getStartPosition();\r\n        let otherEnd = inlineElement && inlineElement.getEndPosition();\r\n        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));\r\n    }\r\n\r\n    /**\r\n     * apply style\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any) {\r\n        let from = this.getStartPosition().normalize();\r\n        let to = this.getEndPosition().normalize();\r\n        let container = this.getContainerNode();\r\n\r\n        if (from.isAtEnd) {\r\n            let nextNode = getNextLeafSibling(container, from.node);\r\n            from = nextNode ? new Position(nextNode, PositionType.Begin) : null;\r\n        }\r\n        if (to.offset == 0) {\r\n            let previousNode = getPreviousLeafSibling(container, to.node);\r\n            to = previousNode ? new Position(previousNode, PositionType.End) : null;\r\n        }\r\n\r\n        applyTextStyle(container, styler, from, to);\r\n    }\r\n}\r\n","import contains from '../utils/contains';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents a content block that can be reprented by a single html block type element.\r\n * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.\r\n */\r\nexport default class NodeBlockElement implements BlockElement {\r\n    constructor(private element: HTMLElement) { }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the start node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the end node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Checks if it refers to same block\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        // Ideally there is only one unique way to generate a block so we only need to compare the startNode\r\n        return this.element == blockElement.getStartNode();\r\n    }\r\n\r\n    /**\r\n     * Checks if a block is after the current block\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        // if the block's startNode is after current node endEnd, we say it is after\r\n        return isNodeAfter(this.element, blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if a certain html node is within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return contains(this.element, node, true /*treatSameNodeAsContain*/);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return this.element.textContent;\r\n    }\r\n}\r\n","import contains from './contains';\r\nimport splitParentNode from './splitParentNode';\r\nimport toArray from './toArray';\r\n\r\n/**\r\n * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n * split parent nodes if necessary\r\n * @param root The root node of the scope\r\n * @param start The start node\r\n * @param end The end node\r\n * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n * and the returned nodes will be all nodes from start trhough end after splitting\r\n * False to disallow split parent\r\n * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n * otherwise just return start and end\r\n */\r\nexport default function collapseNodes(\r\n    root: Node,\r\n    start: Node,\r\n    end: Node,\r\n    canSplitParent: boolean\r\n): Node[] {\r\n    if (!contains(root, start) || !contains(root, end)) {\r\n        return [];\r\n    }\r\n\r\n    start = collapse(root, start, end, true /*isStart*/, canSplitParent);\r\n    end = collapse(root, end, start, false /*isStart*/, canSplitParent);\r\n\r\n    if (contains(start, end, true /*treateSameNodeAsContain*/)) {\r\n        return [start];\r\n    } else if (contains(end, start)) {\r\n        return [end];\r\n    } else if (start.parentNode == end.parentNode) {\r\n        let nodes: Node[] = toArray(start.parentNode.childNodes);\r\n        let startIndex = nodes.indexOf(start);\r\n        let endIndex = nodes.indexOf(end);\r\n        return nodes.slice(startIndex, endIndex + 1);\r\n    } else {\r\n        return [start, end];\r\n    }\r\n}\r\n\r\nfunction collapse(\r\n    root: Node,\r\n    node: Node,\r\n    ref: Node,\r\n    isStart: boolean,\r\n    canSplitParent: boolean\r\n): Node {\r\n    while (node.parentNode != root && !contains(node.parentNode, ref)) {\r\n        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {\r\n            if (!canSplitParent) {\r\n                break;\r\n            }\r\n            splitParentNode(node, isStart);\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return node;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\nconst BLOCK_ELEMENT_TAGS = 'ADDRESS,ARTICLE,ASIDE,BLOCKQUOTE,CANVAS,DD,DIV,DL,DT,FIELDSET,FIGCAPTION,FIGURE,FOOTER,FORM,H1,H2,H3,H4,H5,H6,HEADER,HR,LI,MAIN,NAV,NOSCRIPT,OL,OUTPUT,P,PRE,SECTION,TABLE,TD,TH,TFOOT,UL,VIDEO'.split(\r\n    ','\r\n);\r\nconst BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table-cell'];\r\n\r\n/**\r\n * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.\r\n * @param node The node to check\r\n * @returns True if the node is a block element, otherwise false\r\n */\r\nexport default function isBlockElement(node: Node): boolean {\r\n    let tag = getTagOfNode(node);\r\n    return !!(\r\n        tag &&\r\n        (BLOCK_DISPLAY_STYLES.indexOf((<HTMLElement>node).style.display) >= 0 ||\r\n            BLOCK_ELEMENT_TAGS.indexOf(tag) >= 0)\r\n    );\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * HTML void elements\r\n * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes\r\n * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside\r\n * void elements so users don't accidently create child nodes in them\r\n */\r\nconst HTML_VOID_ELEMENTS = 'AREA,BASE,BR,COL,COMMAND,EMBED,HR,IMG,INPUT,KEYGEN,LINK,META,PARAM,SOURCE,TRACK,WBR'.split(\r\n    ','\r\n);\r\n\r\n/**\r\n * Check if the given node is html void element. Void element cannot have childen\r\n * @param node The node to check\r\n */\r\nexport default function isVoidHtmlElement(node: Node): boolean {\r\n    return !!node && HTML_VOID_ELEMENTS.indexOf(getTagOfNode(node)) >= 0;\r\n}\r\n","import BodyScoper from './BodyScoper';\r\nimport EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport SelectionBlockScoper from './SelectionBlockScoper';\r\nimport SelectionScoper from './SelectionScoper';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementBeforeAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * The provides traversing of content inside editor.\r\n * There are two ways to traverse, block by block, or inline element by inline element\r\n * Block and inline traversing is independent from each other, meanning if you traverse block by block, it does not change\r\n * the current inline element position\r\n */\r\nexport default class ContentTraverser {\r\n    private currentInline: InlineElement;\r\n    private currentBlock: BlockElement;\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param scoper Traversing scoper object to help scope the traversing\r\n     */\r\n    private constructor(private scoper: TraversingScoper) {}\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param rootNode The root node to traverse in\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    public static createBodyTraverser(rootNode: Node, startNode?: Node): ContentTraverser {\r\n        return new ContentTraverser(new BodyScoper(rootNode, startNode));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for the given selection\r\n     * @param rootNode The root node to traverse in\r\n     * @param range The selection range to scope the traversing\r\n     */\r\n    public static createSelectionTraverser(rootNode: Node, range: Range): ContentTraverser {\r\n        return new ContentTraverser(new SelectionScoper(rootNode, range));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for a block element which contains the given position\r\n     * @param rootNode The root node to traverse in\r\n     * @param position A position inside a block, traversing will be scoped within this block.\r\n     * If passing a range, the start position of this range will be used\r\n     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart\r\n     */\r\n    public static createBlockTraverser(\r\n        rootNode: Node,\r\n        position: NodePosition | Range,\r\n        start: ContentPosition = ContentPosition.SelectionStart\r\n    ): ContentTraverser {\r\n        return new ContentTraverser(new SelectionBlockScoper(rootNode, position, start));\r\n    }\r\n\r\n    /**\r\n     * Get current block\r\n     */\r\n    public get currentBlockElement(): BlockElement {\r\n        // Prepare currentBlock from the scoper\r\n        if (!this.currentBlock) {\r\n            this.currentBlock = this.scoper.getStartBlockElement();\r\n        }\r\n\r\n        return this.currentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get next block element\r\n     */\r\n    public getNextBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous block element\r\n     */\r\n    public getPreviousBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextBlockElement(isNext: boolean): BlockElement {\r\n        let current = this.currentBlockElement;\r\n        let leaf = getLeafSibling(\r\n            this.scoper.rootNode,\r\n            isNext ? current.getEndNode() : current.getStartNode(),\r\n            isNext\r\n        );\r\n        let newBlock = leaf ? getBlockElementAtNode(this.scoper.rootNode, leaf) : null;\r\n\r\n        // Make sure this is right block:\r\n        // 1) the block is in scope per scoper\r\n        // 2) the block is after (for next) or before (for previous) the current block\r\n        // Then:\r\n        // 1) Re-position current block to newly found block\r\n        if (\r\n            newBlock &&\r\n            this.scoper.isBlockInScope(newBlock) &&\r\n            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))\r\n        ) {\r\n            this.currentBlock = newBlock;\r\n            return this.currentBlock;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current inline element getter\r\n     */\r\n    public get currentInlineElement(): InlineElement {\r\n        // Retrieve a start inline from scoper\r\n        if (!this.currentInline) {\r\n            this.currentInline = this.scoper.getStartInlineElement();\r\n        }\r\n\r\n        return this.currentInline instanceof EmptyInlineElement ? null : this.currentInline;\r\n    }\r\n\r\n    /**\r\n     * Get next inline element\r\n     */\r\n    public getNextInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous inline element\r\n     */\r\n    public getPreviousInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextInlineElement(isNext: boolean): InlineElement {\r\n        let current = this.currentInlineElement || this.currentInline;\r\n        let newInline: InlineElement;\r\n\r\n        if (current instanceof EmptyInlineElement) {\r\n            newInline = getInlineElementBeforeAfter(\r\n                this.scoper.rootNode,\r\n                current.getStartPosition(),\r\n                isNext\r\n            );\r\n            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {\r\n                newInline = null;\r\n            }\r\n        } else {\r\n            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);\r\n            newInline =\r\n                newInline &&\r\n                current &&\r\n                ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))\r\n                    ? newInline\r\n                    : null;\r\n        }\r\n\r\n        // For inline, we need to make sure:\r\n        // 1) it is really next/previous to current\r\n        // 2) pass on the new inline to this.scoper to do the triming and we still get back an inline\r\n        // Then\r\n        // 1) re-position current inline\r\n        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {\r\n            this.currentInline = newInline;\r\n            return this.currentInline;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getNextPreviousInlineElement(\r\n    rootNode: Node,\r\n    current: InlineElement,\r\n    isNext: boolean\r\n): InlineElement {\r\n    if (!current) {\r\n        return null;\r\n    }\r\n    if (current instanceof PartialInlineElement) {\r\n        // if current is partial, get the the othe half of the inline unless it is no more\r\n        let result = isNext ? current.nextInlineElement : current.previousInlineElement;\r\n\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get a leaf node after startNode and use that base to find next inline\r\n    let startNode = current.getContainerNode();\r\n    startNode = getLeafSibling(rootNode, startNode, isNext);\r\n    return getInlineElementAtNode(rootNode, startNode);\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport Position from '../selection/Position';\r\nimport splitTextNode from './splitTextNode';\r\nimport wrap from './wrap';\r\nimport { getNextLeafSibling } from './getLeafSibling';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst STYLETAGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL'.split(',');\r\n\r\n/**\r\n * Apply style using a styler function to the given container node in the given range\r\n * @param container The container node to apply style to\r\n * @param styler The styler function\r\n * @param from From position\r\n * @param to To position\r\n */\r\nexport default function applyTextStyle(\r\n    container: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any,\r\n    from: NodePosition = new Position(container, PositionType.Begin).normalize(),\r\n    to: NodePosition = new Position(container, PositionType.End).normalize()\r\n) {\r\n    let formatNodes: Node[] = [];\r\n\r\n    while (from && to && to.isAfter(from)) {\r\n        let formatNode = from.node;\r\n        let parentTag = getTagOfNode(formatNode.parentNode);\r\n\r\n        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node\r\n        let nextNode = getNextLeafSibling(container, formatNode);\r\n\r\n        if (formatNode.nodeType == NodeType.Text && ['TR', 'TABLE'].indexOf(parentTag) < 0) {\r\n            if (formatNode == to.node && !to.isAtEnd) {\r\n                formatNode = splitTextNode(<Text>formatNode, to.offset, true /*returnFirstPart*/);\r\n            }\r\n\r\n            if (from.offset > 0) {\r\n                formatNode = splitTextNode(\r\n                    <Text>formatNode,\r\n                    from.offset,\r\n                    false /*returnFirstPart*/\r\n                );\r\n            }\r\n\r\n            formatNodes.push(formatNode);\r\n        }\r\n\r\n        from = nextNode && new Position(nextNode, PositionType.Begin);\r\n    }\r\n\r\n    if (formatNodes.length > 0) {\r\n        if (formatNodes.every(node => node.parentNode == formatNodes[0].parentNode)) {\r\n            let newNode = formatNodes.shift();\r\n            formatNodes.forEach(node => {\r\n                newNode.nodeValue += node.nodeValue;\r\n                node.parentNode.removeChild(node);\r\n            });\r\n            formatNodes = [newNode];\r\n        }\r\n\r\n        formatNodes.forEach(node => {\r\n            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them\r\n            // So that the inner style tag such as U, STRIKE can inherit the style we added\r\n            while (\r\n                getTagOfNode(node) != 'SPAN' &&\r\n                STYLETAGS.indexOf(getTagOfNode(node.parentNode)) >= 0\r\n            ) {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (getTagOfNode(node) != 'SPAN') {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = wrap(node, 'SPAN');\r\n            }\r\n            styler(<HTMLElement>node);\r\n        });\r\n    }\r\n}\r\n\r\nfunction callStylerWithInnerNode(\r\n    node: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    if (node && node.nodeType == NodeType.Element) {\r\n        styler(node as HTMLElement, true /*isInnerNode*/);\r\n    }\r\n}\r\n","/**\r\n * Split a text node into two parts by an offset number, and return one of them\r\n * @param textNode The text node to split\r\n * @param offset The offset number to split at\r\n * @param returnFirstPart True to return the first part, then the passed in textNode will become the second part.\r\n * Otherwise return the second part, and the passed in textNode will become the first part\r\n */\r\nexport default function splitTextNode(textNode: Text, offset: number, returnFirstPart: boolean) {\r\n    const firstPart = textNode.nodeValue.substr(0, offset);\r\n    const secondPart = textNode.nodeValue.substr(offset);\r\n    const newNode = textNode.ownerDocument.createTextNode(returnFirstPart ? firstPart : secondPart);\r\n    textNode.nodeValue = returnFirstPart ? secondPart : firstPart;\r\n    textNode.parentNode.insertBefore(newNode, returnFirstPart ? textNode : textNode.nextSibling);\r\n    return newNode;\r\n}\r\n","import { getComputedStyle } from './getComputedStyles';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst CRLF = /^[\\r\\n]+$/gm;\r\n\r\n/**\r\n * Skip a node when any of following conditions are true\r\n * - it is neither Element nor Text\r\n * - it is a text node but is empty\r\n * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)\r\n * - has a display:none\r\n */\r\nexport default function shouldSkipNode(node: Node): boolean {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return !node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue);\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return getComputedStyle(node, 'display') == 'none';\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport PartialInlineElement from './PartialInlineElement';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport { InlineElement, NodePosition, NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get inline element before a position\r\n * This is mostly used when we want to get the inline element before selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement before\r\n */\r\nexport function getInlineElementBefore(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);\r\n}\r\n\r\n/**\r\n * Get inline element after a position\r\n * This is mostly used when we want to get the inline element after selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement after\r\n */\r\nexport function getInlineElementAfter(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);\r\n}\r\n\r\nexport function getInlineElementBeforeAfter(root: Node, position: NodePosition, isAfter: boolean) {\r\n    if (!root || !position || !position.node) {\r\n        return null;\r\n    }\r\n\r\n    position = position.normalize();\r\n    let { node, offset, isAtEnd } = position;\r\n    let isPartial = false;\r\n\r\n    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    } else if (\r\n        node.nodeType == NodeType.Text &&\r\n        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))\r\n    ) {\r\n        isPartial = true;\r\n    }\r\n\r\n    if (node && shouldSkipNode(node)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    }\r\n\r\n    let inlineElement = getInlineElementAtNode(root, node);\r\n\r\n    if (inlineElement && (isPartial || inlineElement.contains(position))) {\r\n        inlineElement = isAfter\r\n            ? new PartialInlineElement(inlineElement, position, null)\r\n            : new PartialInlineElement(inlineElement, null, position);\r\n    }\r\n\r\n    return inlineElement;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst VISIBLE_ELEMENT_TAGS = ['IMG'];\r\nconst VISIBLE_CHILD_ELEMENT_SELECTOR = ['TABLE', 'IMG', 'LI'].join(',');\r\nconst ZERO_WIDTH_SPACE = /\\u200b/g;\r\n\r\n/**\r\n * Check if a given node has no visible content\r\n * @param node The node to check\r\n * @param trimContent Whether trim the text content so that spaces will be treated as empty.\r\n * Default value is false\r\n * @returns True if there isn't any visible element inside node, otherwise false\r\n */\r\nexport default function isNodeEmpty(node: Node, trimContent?: boolean) {\r\n    if (!node) {\r\n        return false;\r\n    } else if (node.nodeType == NodeType.Text) {\r\n        return trim(node.nodeValue, trimContent) == '';\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        let element = node as Element;\r\n        let textContent = trim(element.textContent, trimContent);\r\n        if (\r\n            textContent != '' ||\r\n            VISIBLE_ELEMENT_TAGS.indexOf(getTagOfNode(element)) >= 0 ||\r\n            element.querySelectorAll(VISIBLE_CHILD_ELEMENT_SELECTOR)[0]\r\n        ) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction trim(s: string, trim: boolean) {\r\n    s = s.replace(ZERO_WIDTH_SPACE, '');\r\n    return trim ? s.trim() : s;\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check whether can move current snapshot with the given step\r\n * @param snapshots The snapshots data structure to check\r\n * @param step The step to check, can be positive, negative or 0\r\n * @returns True if can move current snapshot with the given step, otherwise false\r\n */\r\nexport default function canMoveCurrentSnapshot(snapshots: Snapshots, step: number): boolean {\r\n    let newIndex = snapshots.currentIndex + step;\r\n    return newIndex >= 0 && newIndex < snapshots.snapshots.length;\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\n\n/**\n * Check if Ctrl key (Windows) or Meta key (Mac) is pressed for the given Event\n * @param event A Keyboard event or Mouse event object\n * @returns True if Ctrl key is pressed on Windows or Meta key is pressed on Mac\n */\nconst isCtrlOrMetaPressed: (event: KeyboardEvent | MouseEvent) => boolean = Browser.isMac\n    ? event => event.metaKey\n    : event => event.ctrlKey;\nexport default isCtrlOrMetaPressed;\n","import { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Gets the cached event data by cache key from event object if there is already one.\r\n * Otherwise, call getter function to create one, and cache it.\r\n * @param event The event object\r\n * @param key Cache key string, need to be unique\r\n * @param getter Getter function to get the object when it is not in cache yet\r\n */\r\nexport default function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T {\r\n    let result =\r\n        event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)\r\n            ? <T>event.eventDataCache[key]\r\n            : getter();\r\n    if (event) {\r\n        event.eventDataCache = event.eventDataCache || {};\r\n        event.eventDataCache[key] = result;\r\n    }\r\n\r\n    return result;\r\n}\r\n","import { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    Browser,\r\n    createRange,\r\n    getSelectionPath,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nexport type ValidProcessListDocumentCommands =\r\n    | DocumentCommand.Outdent\r\n    | DocumentCommand.Indent\r\n    | DocumentCommand.InsertOrderedList\r\n    | DocumentCommand.InsertUnorderedList;\r\n\r\n/**\r\n * Browsers don't handle bullet/numbering list well, especially the formats when switching list statue\r\n * So we workaround it by always adding format to list element\r\n */\r\nexport default function processList(\r\n    editor: Editor,\r\n    command: ValidProcessListDocumentCommands\r\n): Node {\r\n    let existingList = editor.getElementAtCursor('OL,UL');\r\n    if (Browser.isChrome && command !== DocumentCommand.Indent) {\r\n        // Chrome has a bug where certain information about elements are deleted when outdent or enter on empty line occurs.\r\n        // We need to clone our current LI node so we can replace the new LI node with it post outdent / enter.\r\n        const parentLINode = editor.getElementAtCursor('LI');\r\n        // We must first be in an LI node to do something to fix this.\r\n        if (parentLINode) {\r\n            // We also don't want to try to handle the multi select outdent case at this time.\r\n            // These are already pretty stable in Chromium.\r\n            const currentRange = editor.getSelectionRange();\r\n            const currentSelectionPath = getSelectionPath(parentLINode, currentRange);\r\n            if (\r\n                currentRange &&\r\n                (currentRange.collapsed ||\r\n                    (editor.getElementAtCursor('LI', currentRange.startContainer) == parentLINode &&\r\n                        editor.getElementAtCursor('LI', currentRange.endContainer) == parentLINode))\r\n            ) {\r\n                // Handle the case for toggling between the two list types as a special case.\r\n                // We'll let the browser handle this for now.\r\n                if (\r\n                    (existingList.tagName === 'OL' &&\r\n                        command === DocumentCommand.InsertUnorderedList) ||\r\n                    (existingList.tagName === 'UL' && command === DocumentCommand.InsertOrderedList)\r\n                ) {\r\n                    editor.getDocument().execCommand(command, false, null);\r\n                } else {\r\n                    // Get the next highest list element.\r\n                    // In well formed HTML, this should just be the existing list's parent container.\r\n                    const listParent = existingList.parentElement;\r\n                    if (listParent.tagName == 'OL' || listParent.tagName == 'UL') {\r\n                        if (parentLINode.nextElementSibling) {\r\n                            splitBalancedNodeRange(parentLINode);\r\n                        }\r\n                        existingList.insertAdjacentElement('afterend', parentLINode);\r\n                        editor.select(\r\n                            createRange(\r\n                                parentLINode,\r\n                                currentSelectionPath.start,\r\n                                currentSelectionPath.end\r\n                            )\r\n                        );\r\n                    } else {\r\n                        // In this case, we're going out to the parent root.\r\n                        if (parentLINode.nextElementSibling) {\r\n                            splitBalancedNodeRange(parentLINode);\r\n                        }\r\n\r\n                        const wrappedContents = wrap(toArray(parentLINode.childNodes));\r\n                        const wrappedRange = createRange(\r\n                            wrappedContents,\r\n                            currentSelectionPath.start,\r\n                            currentSelectionPath.end\r\n                        );\r\n                        const wrappedSelectionPath = getSelectionPath(\r\n                            wrappedContents,\r\n                            wrappedRange\r\n                        );\r\n\r\n                        existingList.insertAdjacentElement('afterend', wrappedContents);\r\n                        editor.deleteNode(parentLINode);\r\n                        let newRange = createRange(\r\n                            wrappedContents,\r\n                            wrappedSelectionPath.start,\r\n                            wrappedSelectionPath.end\r\n                        );\r\n                        editor.select(newRange);\r\n                    }\r\n\r\n                    if (existingList.childElementCount == 0) {\r\n                        editor.deleteNode(existingList);\r\n                    }\r\n                }\r\n            } else {\r\n                editor.getDocument().execCommand(command, false, null);\r\n            }\r\n        } else {\r\n            editor.getDocument().execCommand(command, false, null);\r\n        }\r\n    } else {\r\n        editor.getDocument().execCommand(command, false, null);\r\n    }\r\n    let newList = editor.getElementAtCursor('OL,UL');\r\n    if (newList == existingList) {\r\n        newList = null;\r\n    }\r\n    return newList;\r\n}\r\n","export { default as HyperLink } from './HyperLink/HyperLink';\r\nexport { default as ContentEdit } from './ContentEdit/ContentEdit';\r\nexport { default as Paste } from './Paste/Paste';\r\nexport {\r\n    default as ContentEditFeatures,\r\n    getDefaultContentEditFeatures,\r\n} from './ContentEdit/ContentEditFeatures';\r\nexport { default as Watermark } from './Watermark/Watermark';\r\nexport { default as TableResize } from './TableResize/TableResize';\r\nexport { default as CustomReplace, Replacement } from './CustomReplace/CustomReplace';\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport wrap from '../utils/wrap';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\r\nimport createRange from '../selection/createRange';\r\n\r\nconst STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];\r\n\r\n/**\r\n * This reprents a block that is identified by a start and end node\r\n * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;\r\n * in that case, Hello&lt;BR&gt; is a block, World is another block\r\n * Such block cannot be represented by a NodeBlockElement since they don't chained up\r\n * to a single parent node, instead they have a start and end\r\n * This start and end must be in same sibling level and have same parent in DOM tree\r\n */\r\nexport default class StartEndBlockElement implements BlockElement {\r\n    constructor(private rootNode: Node, private startNode: Node, private endNode: Node) { }\r\n\r\n    static getBlockContext(node: Node): HTMLElement {\r\n        while (node && !isBlockElement(node)) {\r\n            node = node.parentNode;\r\n        }\r\n        return node as HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        let nodes = collapseNodes(\r\n            StartEndBlockElement.getBlockContext(this.startNode),\r\n            this.startNode,\r\n            this.endNode,\r\n            true /*canSplitParent*/\r\n        );\r\n        let blockContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        while (\r\n            nodes[0] &&\r\n            nodes[0] != blockContext &&\r\n            nodes[0].parentNode != this.rootNode &&\r\n            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0\r\n        ) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n        return nodes.length == 1 && isBlockElement(nodes[0])\r\n            ? (nodes[0] as HTMLElement)\r\n            : wrap(nodes);\r\n    }\r\n\r\n    /**\r\n     * Gets the start node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.startNode;\r\n    }\r\n\r\n    /**\r\n     * Gets the end node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.endNode;\r\n    }\r\n\r\n    /**\r\n     * Checks equals of two blocks\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        return (\r\n            this.startNode == blockElement.getStartNode() &&\r\n            this.endNode == blockElement.getEndNode()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if another block is after this current\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if an Html node is contained within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return (\r\n            contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||\r\n            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||\r\n            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return createRange(this.getStartNode(), this.getEndNode()).toString();\r\n    }\r\n}\r\n","import toArray from './toArray';\r\n\r\n/**\r\n * Creates an HTML node array from html\r\n * @param html the html string to create HTML elements from\r\n * @param ownerDocument Owner document of the result HTML elements\r\n * @returns An HTML node array to represent the given html string\r\n */\r\nexport default function fromHtml(html: string, ownerDocument: HTMLDocument): Node[] {\r\n    let element = ownerDocument.createElement('DIV');\r\n    element.innerHTML = html;\r\n\r\n    return toArray(element.childNodes);\r\n}\r\n","import getBlockElementAtNode from './getBlockElementAtNode';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first/last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n * @param isFirst True to get first BlockElement, false to get last BlockElement\r\n */\r\nexport default function getFirstLastBlockElement(rootNode: Node, isFirst: boolean): BlockElement {\r\n    let node = rootNode;\r\n    do {\r\n        node = node && (isFirst ? node.firstChild : node.lastChild);\r\n    } while (node && node.firstChild);\r\n    return node && getBlockElementAtNode(rootNode, node);\r\n}\r\n\r\n/**\r\n * Get the first BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n */\r\nexport function getFirstBlockElement(rootNode: Node): BlockElement {\r\n    return getFirstLastBlockElement(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n */\r\nexport function getLastBlockElement(rootNode: Node): BlockElement {\r\n    return getFirstLastBlockElement(rootNode, false /*isFirst*/);\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is an inline element representing an Html image\r\n */\r\nexport default class ImageInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is inline element presenting an html hyperlink\r\n */\r\nexport default class LinkInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport { getFirstLeafNode, getLastLeafNode } from '../utils/getLeafNode';\r\nimport { InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first inline element inside the given node\r\n */\r\nexport function getFirstInlineElement(rootNode: Node): InlineElement {\r\n    // getFirstLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getFirstLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n\r\n/**\r\n * Get the last inline element inside the given node\r\n */\r\nexport function getLastInlineElement(rootNode: Node): InlineElement {\r\n    // getLastLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getLastLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n","import shouldSkipNode from './shouldSkipNode';\r\nimport { getLeafSibling } from './getLeafSibling';\r\n\r\n/**\r\n * Get first/last leaf node of the given root node.\r\n * @param rootNode Root node to get leaf node from\r\n * @param isFirst True to get first leaf node, false to get last leaf node\r\n */\r\nfunction getLeafNode(rootNode: Node, isFirst: boolean): Node {\r\n    let getChild = (node: Node): Node => (isFirst ? node.firstChild : node.lastChild);\r\n    let result = getChild(rootNode);\r\n    while (result && getChild(result)) {\r\n        result = getChild(result);\r\n    }\r\n\r\n    if (result && shouldSkipNode(result)) {\r\n        result = getLeafSibling(rootNode, result, isFirst);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Get the first meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getFirstLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getLastLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, false /*isFirst*/);\r\n}\r\n","import { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represents an empty InlineElement.\r\n * This is used for ContentTraverser internally only.\r\n * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element\r\n */\r\nexport default class EmptyInlineElement implements InlineElement {\r\n    constructor(private position: NodePosition, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string {\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node {\r\n        return this.position.node;\r\n    }\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element.\r\n     */\r\n    applyStyle(styler: (element: HTMLElement) => any): void {}\r\n}\r\n","import { BrowserInfo } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get current browser information from user agent string\r\n * @param userAgent The userAgent string of a browser\r\n * @param appVersion The appVersion string of a browser\r\n * @returns The BrowserInfo object calculated from the given userAgent and appVersion\r\n */\r\nexport function getBrowserInfo(userAgent: string, appVersion: string): BrowserInfo {\r\n    // checks whether the browser is running in IE\r\n    // IE11 will use rv in UA instead of MSIE. Unfortunately Firefox also uses this. We should also look for \"Trident\" to confirm this.\r\n    // There have been cases where companies using older version of IE and custom UserAgents have broken this logic (e.g. IE 10 and KellyServices)\r\n    // therefore we should check that the Trident/rv combo is not just from an older IE browser\r\n    let isIE11OrGreater = userAgent.indexOf('rv:') != -1 && userAgent.indexOf('Trident') != -1;\r\n    let isIE = userAgent.indexOf('MSIE') != -1 || isIE11OrGreater;\r\n\r\n    // IE11+ may also have 'Chrome', 'Firefox' and 'Safari' in user agent. But it will have 'trident' as well\r\n    let isChrome = false;\r\n    let isFirefox = false;\r\n    let isSafari = false;\r\n    let isEdge = false;\r\n    let isWebKit = userAgent.indexOf('WebKit') != -1;\r\n\r\n    if (!isIE) {\r\n        isChrome = userAgent.indexOf('Chrome') != -1;\r\n        isFirefox = userAgent.indexOf('Firefox') != -1;\r\n        if (userAgent.indexOf('Safari') != -1) {\r\n            // Android and Chrome have Safari in the user string\r\n            isSafari = userAgent.indexOf('Chrome') == -1 && userAgent.indexOf('Android') == -1;\r\n        }\r\n\r\n        // Sample Edge UA: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10121\r\n        isEdge = userAgent.indexOf('Edge') != -1;\r\n\r\n        // When it is edge, it should not be chrome or firefox. and it is also not webkit\r\n        if (isEdge) {\r\n            isWebKit = isChrome = isFirefox = false;\r\n        }\r\n    }\r\n\r\n    let isMac = appVersion.indexOf('Mac') != -1;\r\n    let isWin = appVersion.indexOf('Win') != -1 || appVersion.indexOf('NT') != -1;\r\n\r\n    return {\r\n        isMac,\r\n        isWin,\r\n        isWebKit,\r\n        isIE,\r\n        isIE11OrGreater,\r\n        isSafari,\r\n        isChrome,\r\n        isFirefox,\r\n        isEdge,\r\n        isIEOrEdge: isIE || isEdge,\r\n    };\r\n}\r\n\r\n/**\r\n * Browser object contains browser and operating system informations of current environment\r\n */\r\nexport const Browser = window\r\n    ? getBrowserInfo(window.navigator.userAgent, window.navigator.appVersion)\r\n    : {};\r\n","import getComputedStyles from './getComputedStyles';\r\nimport getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag<K extends keyof HTMLElementTagNameMap>(\r\n    element: HTMLElement,\r\n    newTag: K\r\n): HTMLElementTagNameMap[K];\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement;\r\n\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement {\r\n    if (!element || !newTag) {\r\n        return null;\r\n    }\r\n\r\n    let newElement = element.ownerDocument.createElement(newTag);\r\n\r\n    for (let i = 0; i < element.attributes.length; i++) {\r\n        let attr = element.attributes[i];\r\n        newElement.setAttribute(attr.name, attr.value);\r\n    }\r\n\r\n    while (element.firstChild) {\r\n        newElement.appendChild(element.firstChild);\r\n    }\r\n\r\n    if (getTagOfNode(element) == 'P' || getTagOfNode(newElement) == 'P') {\r\n        [newElement.style.marginTop, newElement.style.marginBottom] = getComputedStyles(element, [\r\n            'margin-top',\r\n            'margin-bottom',\r\n        ]);\r\n    }\r\n\r\n    if (element.parentNode) {\r\n        element.parentNode.replaceChild(newElement, element);\r\n    }\r\n\r\n    return newElement;\r\n}\r\n","import contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isNodeEmpty from '../utils/isNodeEmpty';\r\nimport { NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check if this position is at beginning of the given node.\r\n * This will return true if all nodes between the beginning of target node and the position are empty.\r\n * @param position The position to check\r\n * @param targetNode The node to check\r\n * @returns True if position is at beginning of the node, otherwise false\r\n */\r\nexport default function isPositionAtBeginningOf(position: NodePosition, targetNode: Node) {\r\n    if (position) {\r\n        let { node, offset } = position.normalize();\r\n        if (offset == 0) {\r\n            while (contains(targetNode, node) && areAllPrevousNodesEmpty(node)) {\r\n                node = node.parentNode;\r\n            }\r\n\r\n            return node == targetNode;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction areAllPrevousNodesEmpty(node: Node): boolean {\r\n    while (node.previousSibling) {\r\n        node = node.previousSibling;\r\n        if (getTagOfNode(node) == 'BR' || !isNodeEmpty(node)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n","import toArray from './toArray';\r\nimport { DocumentPosition } from 'roosterjs-editor-types';\r\nimport { QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Query HTML elements in the container by a selector string\r\n * @param container Container element to query from\r\n * @param selector Selector string to query\r\n * @param forEachCallback An optional callback to be invoked on each node in query result\r\n * @param scope The scope of the query, default value is QueryScope.Body\r\n * @param range The selection range to query with. This is required when scope is not Body\r\n * @returns HTML Element array of the query result\r\n */\r\nexport default function queryElements(\r\n    container: HTMLElement,\r\n    selector: string,\r\n    forEachCallback?: (node: HTMLElement) => any,\r\n    scope: QueryScope = QueryScope.Body,\r\n    range?: Range\r\n): HTMLElement[] {\r\n    if (!container || !selector) {\r\n        return [];\r\n    }\r\n\r\n    let elements = toArray(container.querySelectorAll<HTMLElement>(selector));\r\n\r\n    if (scope != QueryScope.Body && range) {\r\n        elements = elements.filter(element =>\r\n            isIntersectWithNodeRange(element, range, scope == QueryScope.InSelection)\r\n        );\r\n    }\r\n\r\n    if (forEachCallback) {\r\n        elements.forEach(forEachCallback);\r\n    }\r\n    return elements;\r\n}\r\n\r\nfunction isIntersectWithNodeRange(\r\n    node: Node,\r\n    range: Range,\r\n    nodeContainedByRangeOnly: boolean\r\n): boolean {\r\n    let startPosition = node.compareDocumentPosition(range.startContainer);\r\n    let endPosition = node.compareDocumentPosition(range.endContainer);\r\n    let targetPositions = [DocumentPosition.Same, DocumentPosition.Contains];\r\n\r\n    if (!nodeContainedByRangeOnly) {\r\n        targetPositions.push(DocumentPosition.ContainedBy);\r\n    }\r\n\r\n    return (\r\n        checkPosition(startPosition, targetPositions) || // intersectStart\r\n        checkPosition(endPosition, targetPositions) || // intersectEnd\r\n        (checkPosition(startPosition, [DocumentPosition.Preceding]) && // Contains\r\n            checkPosition(endPosition, [DocumentPosition.Following]) &&\r\n            !checkPosition(endPosition, [DocumentPosition.ContainedBy]))\r\n    );\r\n}\r\n\r\nfunction checkPosition(position: DocumentPosition, targets: DocumentPosition[]): boolean {\r\n    return targets.some(target =>\r\n        target == DocumentPosition.Same\r\n            ? position == DocumentPosition.Same\r\n            : (position & target) == target\r\n    );\r\n}\r\n","/**\r\n * Removes the node and keep all children in place, return the parentNode where the children are attached\r\n * @param node the node to remove\r\n */\r\nexport default function unwrap(node: Node): Node {\r\n    // Unwrap requires a parentNode\r\n    let parentNode = node ? node.parentNode : null;\r\n    if (!parentNode) {\r\n        return null;\r\n    }\r\n\r\n    while (node.firstChild) {\r\n        parentNode.insertBefore(node.firstChild, node);\r\n    }\r\n\r\n    parentNode.removeChild(node);\r\n    return parentNode;\r\n}\r\n","import { isHTMLTableCellElement, isHTMLTableElement } from 'roosterjs-cross-window';\r\nimport { TableFormat, TableOperation } from 'roosterjs-editor-types';\r\nimport { toArray } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Represent a virtual cell of a virtual table\r\n */\r\nexport interface VCell {\r\n    /**\r\n     * The table cell object. The value will be null if this is an expanded virtual cell\r\n     */\r\n    td?: HTMLTableCellElement;\r\n\r\n    /**\r\n     * Whether this cell is spanned from left\r\n     */\r\n    spanLeft?: boolean;\r\n\r\n    /**\r\n     * Whether this cell is spanned from above\r\n     */\r\n    spanAbove?: boolean;\r\n}\r\n\r\n/**\r\n * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells\r\n */\r\nexport default class VTable {\r\n    /**\r\n     * The HTML table object\r\n     */\r\n    table: HTMLTableElement;\r\n\r\n    /**\r\n     * Virtual cells\r\n     */\r\n    cells: VCell[][];\r\n\r\n    /**\r\n     * Current row index\r\n     */\r\n    row: number;\r\n\r\n    /**\r\n     * Current column index\r\n     */\r\n    col: number;\r\n\r\n    private trs: HTMLTableRowElement[] = [];\r\n\r\n    /**\r\n     * Create a new instance of VTable object using HTML TABLE or TD node\r\n     * @param node The HTML Table or TD node\r\n     */\r\n    constructor(node: HTMLTableElement | HTMLTableCellElement) {\r\n        this.table = isHTMLTableElement(node) ? node : getTableFromTd(node);\r\n        if (this.table) {\r\n            let currentTd = isHTMLTableElement(node) ? null : node;\r\n            let trs = toArray(this.table.rows);\r\n            this.cells = trs.map(row => []);\r\n            trs.forEach((tr, rowIndex) => {\r\n                this.trs[rowIndex % 2] = tr;\r\n                for (let sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {\r\n                    // Skip the cells which already initialized\r\n                    for (; this.cells[rowIndex][targetCol]; targetCol++) {}\r\n\r\n                    let td = tr.cells[sourceCol];\r\n                    if (td == currentTd) {\r\n                        this.col = targetCol;\r\n                        this.row = rowIndex;\r\n                    }\r\n\r\n                    for (let colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {\r\n                        for (let rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {\r\n                            this.cells[rowIndex + rowSpan][targetCol] = {\r\n                                td: colSpan + rowSpan == 0 ? td : null,\r\n                                spanLeft: colSpan > 0,\r\n                                spanAbove: rowSpan > 0,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write the virtual table back to DOM tree to represent the change of VTable\r\n     */\r\n    writeBack() {\r\n        if (this.cells) {\r\n            moveChildren(this.table);\r\n            this.cells.forEach((row, r) => {\r\n                let tr = cloneNode(this.trs[r % 2] || this.trs[0]);\r\n                this.table.appendChild(tr);\r\n                row.forEach((cell, c) => {\r\n                    if (cell.td) {\r\n                        this.recalcSpans(r, c);\r\n                        tr.appendChild(cell.td);\r\n                    }\r\n                });\r\n            });\r\n        } else if (this.table) {\r\n            this.table.parentNode.removeChild(this.table);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the given table format to this virtual table\r\n     * @param format Table format to apply\r\n     */\r\n    applyFormat(format: Partial<TableFormat>) {\r\n        if (!format || !this.table) {\r\n            return;\r\n        }\r\n        this.table.style.borderCollapse = 'collapse';\r\n        this.trs[0].style.backgroundColor = format.bgColorOdd || 'transparent';\r\n        if (this.trs[1]) {\r\n            this.trs[1].style.backgroundColor = format.bgColorEven || 'transparent';\r\n        }\r\n        this.cells.forEach(row =>\r\n            row\r\n                .filter(cell => cell.td)\r\n                .forEach(cell => {\r\n                    cell.td.style.borderTop = getBorderStyle(format.topBorderColor);\r\n                    cell.td.style.borderBottom = getBorderStyle(format.bottomBorderColor);\r\n                    cell.td.style.borderLeft = getBorderStyle(format.verticalBorderColor);\r\n                    cell.td.style.borderRight = getBorderStyle(format.verticalBorderColor);\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Edit table with given operation.\r\n     * @param operation Table operation\r\n     */\r\n    edit(operation: TableOperation) {\r\n        if (!this.table) {\r\n            return;\r\n        }\r\n\r\n        let currentRow = this.cells[this.row];\r\n        let currentCell = currentRow[this.col];\r\n        switch (operation) {\r\n            case TableOperation.InsertAbove:\r\n                this.cells.splice(this.row, 0, currentRow.map(cloneCell));\r\n                break;\r\n            case TableOperation.InsertBelow:\r\n                let newRow = this.row + this.countSpanAbove(this.row, this.col);\r\n                this.cells.splice(\r\n                    newRow,\r\n                    0,\r\n                    this.cells[newRow - 1].map((cell, colIndex) => {\r\n                        let nextCell = this.getCell(newRow, colIndex);\r\n                        if (nextCell.spanAbove) {\r\n                            return cloneCell(nextCell);\r\n                        } else if (cell.spanLeft) {\r\n                            let newCell = cloneCell(cell);\r\n                            newCell.spanAbove = false;\r\n                            return newCell;\r\n                        } else {\r\n                            return {\r\n                                td: cloneNode(this.getTd(this.row, colIndex)),\r\n                            };\r\n                        }\r\n                    })\r\n                );\r\n                break;\r\n\r\n            case TableOperation.InsertLeft:\r\n                this.forEachCellOfCurrentColumn((cell, row) => {\r\n                    row.splice(this.col, 0, cloneCell(cell));\r\n                });\r\n                break;\r\n            case TableOperation.InsertRight:\r\n                let newCol = this.col + this.countSpanLeft(this.row, this.col);\r\n                this.forEachCellOfColumn(newCol - 1, (cell, row, i) => {\r\n                    let nextCell = this.getCell(i, newCol);\r\n                    let newCell: VCell;\r\n                    if (nextCell.spanLeft) {\r\n                        newCell = cloneCell(nextCell);\r\n                    } else if (cell.spanAbove) {\r\n                        newCell = cloneCell(cell);\r\n                        newCell.spanLeft = false;\r\n                    } else {\r\n                        newCell = {\r\n                            td: cloneNode(this.getTd(i, this.col)),\r\n                        };\r\n                    }\r\n\r\n                    row.splice(newCol, 0, newCell);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.DeleteRow:\r\n                this.forEachCellOfCurrentRow((cell, i) => {\r\n                    let nextCell = this.getCell(this.row + 1, i);\r\n                    if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                });\r\n                this.cells.splice(this.row, 1);\r\n                break;\r\n\r\n            case TableOperation.DeleteColumn:\r\n                this.forEachCellOfCurrentColumn((cell, row, i) => {\r\n                    let nextCell = this.getCell(i, this.col + 1);\r\n                    if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                    row.splice(this.col, 1);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.MergeAbove:\r\n            case TableOperation.MergeBelow:\r\n                let rowStep = operation == TableOperation.MergeAbove ? -1 : 1;\r\n                for (\r\n                    let rowIndex = this.row + rowStep;\r\n                    rowIndex >= 0 && rowIndex < this.cells.length;\r\n                    rowIndex += rowStep\r\n                ) {\r\n                    let cell = this.getCell(rowIndex, this.col);\r\n                    if (cell.td && !cell.spanAbove) {\r\n                        let aboveCell = rowIndex < this.row ? cell : currentCell;\r\n                        let belowCell = rowIndex < this.row ? currentCell : cell;\r\n                        if (aboveCell.td.colSpan == belowCell.td.colSpan) {\r\n                            moveChildren(belowCell.td, aboveCell.td);\r\n                            belowCell.td = null;\r\n                            belowCell.spanAbove = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.MergeLeft:\r\n            case TableOperation.MergeRight:\r\n                let colStep = operation == TableOperation.MergeLeft ? -1 : 1;\r\n                for (\r\n                    let colIndex = this.col + colStep;\r\n                    colIndex >= 0 && colIndex < this.cells[this.row].length;\r\n                    colIndex += colStep\r\n                ) {\r\n                    let cell = this.getCell(this.row, colIndex);\r\n                    if (cell.td && !cell.spanLeft) {\r\n                        let leftCell = colIndex < this.col ? cell : currentCell;\r\n                        let rightCell = colIndex < this.col ? currentCell : cell;\r\n                        if (leftCell.td.rowSpan == rightCell.td.rowSpan) {\r\n                            moveChildren(rightCell.td, leftCell.td);\r\n                            rightCell.td = null;\r\n                            rightCell.spanLeft = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.DeleteTable:\r\n                this.cells = null;\r\n                break;\r\n\r\n            case TableOperation.SplitVertically:\r\n                if (currentCell.td.rowSpan > 1) {\r\n                    this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    let splitRow = currentRow.map(cell => {\r\n                        return {\r\n                            td: cell == currentCell ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell != currentCell,\r\n                            spanLeft: cell.spanLeft,\r\n                        };\r\n                    });\r\n                    this.cells.splice(this.row + 1, 0, splitRow);\r\n                }\r\n                break;\r\n\r\n            case TableOperation.SplitHorizontally:\r\n                if (currentCell.td.colSpan > 1) {\r\n                    this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    this.forEachCellOfCurrentColumn((cell, row) => {\r\n                        row.splice(this.col + 1, 0, {\r\n                            td: row == currentRow ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell.spanAbove,\r\n                            spanLeft: row != currentRow,\r\n                        });\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current column and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => any) {\r\n        this.forEachCellOfColumn(this.col, callback);\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current row and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => any) {\r\n        this.forEachCellOfRow(this.row, callback);\r\n    }\r\n\r\n    /**\r\n     * Get a table cell using its row and column index. This function will always return an object\r\n     * even if the given indexes don't exist in table.\r\n     * @param row The row index\r\n     * @param col The column index\r\n     */\r\n    getCell(row: number, col: number): VCell {\r\n        return (this.cells && this.cells[row] && this.cells[row][col]) || {};\r\n    }\r\n\r\n    /**\r\n     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell\r\n     */\r\n    getCurrentTd(): HTMLTableCellElement {\r\n        return this.getTd(this.row, this.col);\r\n    }\r\n\r\n    private getTd(row: number, col: number) {\r\n        if (this.cells) {\r\n            row = Math.min(this.cells.length - 1, row);\r\n            col = Math.min(this.cells[row].length - 1, col);\r\n            while (row >= 0 && col >= 0) {\r\n                let cell = this.getCell(row, col);\r\n                if (cell.td) {\r\n                    return cell.td;\r\n                } else if (cell.spanLeft) {\r\n                    col--;\r\n                } else if (cell.spanAbove) {\r\n                    row--;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private forEachCellOfColumn(\r\n        col: number,\r\n        callback: (cell: VCell, row: VCell[], i: number) => any\r\n    ) {\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            callback(this.getCell(i, col), this.cells[i], i);\r\n        }\r\n    }\r\n\r\n    private forEachCellOfRow(row: number, callback: (cell: VCell, i: number) => any) {\r\n        for (let i = 0; i < this.cells[row].length; i++) {\r\n            callback(this.getCell(row, i), i);\r\n        }\r\n    }\r\n\r\n    private recalcSpans(row: number, col: number) {\r\n        let td = this.getCell(row, col).td;\r\n        if (td) {\r\n            td.colSpan = this.countSpanLeft(row, col);\r\n            td.rowSpan = this.countSpanAbove(row, col);\r\n            if (td.colSpan == 1) {\r\n                td.removeAttribute('colSpan');\r\n            }\r\n            if (td.rowSpan == 1) {\r\n                td.removeAttribute('rowSpan');\r\n            }\r\n        }\r\n    }\r\n\r\n    private countSpanLeft(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = col + 1; i < this.cells[row].length; i++) {\r\n            let cell = this.getCell(row, i);\r\n            if (cell.td || !cell.spanLeft) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private countSpanAbove(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = row + 1; i < this.cells.length; i++) {\r\n            let cell = this.getCell(i, col);\r\n            if (cell.td || !cell.spanAbove) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nfunction getTableFromTd(td: HTMLTableCellElement) {\r\n    let result = <HTMLElement>td;\r\n    for (; result && result.tagName != 'TABLE'; result = result.parentElement) {}\r\n    return <HTMLTableElement>result;\r\n}\r\n\r\nfunction getBorderStyle(style: string): string {\r\n    return 'solid 1px ' + (style || 'transparent');\r\n}\r\n\r\n/**\r\n * Clone a table cell\r\n * @param cell The cell to clone\r\n */\r\nfunction cloneCell(cell: VCell): VCell {\r\n    return {\r\n        td: cloneNode(cell.td),\r\n        spanAbove: cell.spanAbove,\r\n        spanLeft: cell.spanLeft,\r\n    };\r\n}\r\n\r\n/**\r\n * Clone a node without its children.\r\n * @param node The node to clone\r\n */\r\nfunction cloneNode<T extends Node>(node: T): T {\r\n    let newNode = node ? <T>node.cloneNode(false /*deep*/) : null;\r\n    if (isHTMLTableCellElement(newNode)) {\r\n        newNode.removeAttribute('id');\r\n        if (!newNode.firstChild) {\r\n            newNode.appendChild(node.ownerDocument.createElement('br'));\r\n        }\r\n    }\r\n    return newNode;\r\n}\r\n\r\n/**\r\n * Move all children from one node to another\r\n * @param fromNode The source node to move children from\r\n * @param toNode Target node. If not passed, children nodes of source node will be removed\r\n */\r\nfunction moveChildren(fromNode: Node, toNode?: Node) {\r\n    while (fromNode.firstChild) {\r\n        if (toNode) {\r\n            toNode.appendChild(fromNode.firstChild);\r\n        } else {\r\n            fromNode.removeChild(fromNode.firstChild);\r\n        }\r\n    }\r\n}\r\n","import contains from '../utils/contains';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get path of the given selection range related to the given rootNode\r\n * @param rootNode The root node where the path start from\r\n * @param range The range of selection\r\n */\r\nexport default function getSelectionPath(rootNode: HTMLElement, range: Range): SelectionPath {\r\n    if (!range) {\r\n        return null;\r\n    }\r\n\r\n    let selectionPath: SelectionPath = {\r\n        start: getPositionPath(Position.getStart(range), rootNode),\r\n        end: getPositionPath(Position.getEnd(range), rootNode),\r\n    };\r\n\r\n    return selectionPath;\r\n}\r\n\r\n/**\r\n * Get the path of the node relative to rootNode.\r\n * The path of the node is an array of integer indecies into the childNodes of the given node.\r\n *\r\n * The node path will be what the node path will be on a _normalized_ dom\r\n * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)\r\n *\r\n * @param rootNode the node the path will be relative to\r\n * @param position the position to get indexes from. Follows the same semantics\r\n * as selectionRange (if node is of type Text, it is an offset into the text of that node.\r\n * If node is of type Element, it is the index of a child in that Element node.)\r\n */\r\nfunction getPositionPath(position: NodePosition, rootNode: HTMLElement): number[] {\r\n    if (!position || !rootNode) {\r\n        return [];\r\n    }\r\n\r\n    let { node, offset } = position;\r\n    let result: number[] = [];\r\n    let parent: Node;\r\n\r\n    if (!contains(rootNode, node, true)) {\r\n        return [];\r\n    }\r\n\r\n    if (node.nodeType == NodeType.Text) {\r\n        parent = node.parentNode;\r\n        while (node.previousSibling && node.previousSibling.nodeType == NodeType.Text) {\r\n            offset += node.previousSibling.nodeValue.length;\r\n            node = node.previousSibling;\r\n        }\r\n        result.unshift(offset);\r\n    } else {\r\n        parent = node;\r\n        node = node.childNodes[offset];\r\n    }\r\n\r\n    do {\r\n        offset = 0;\r\n        let isPreviousText = false;\r\n\r\n        for (let c: Node = parent.firstChild; c && c != node; c = c.nextSibling) {\r\n            if (c.nodeType == NodeType.Text) {\r\n                if (c.nodeValue.length == 0 || isPreviousText) {\r\n                    continue;\r\n                }\r\n\r\n                isPreviousText = true;\r\n            } else {\r\n                isPreviousText = false;\r\n            }\r\n\r\n            offset++;\r\n        }\r\n\r\n        result.unshift(offset);\r\n        node = parent;\r\n        parent = parent.parentNode;\r\n    } while (node && node != rootNode);\r\n\r\n    return result;\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear all snapshots after the current one\r\n * @param snapshots The snapshots data structure to clear\r\n */\r\nexport default function clearProceedingSnapshots(snapshots: Snapshots) {\r\n    if (canMoveCurrentSnapshot(snapshots, 1)) {\r\n        let removedSize = 0;\r\n        for (let i = snapshots.currentIndex + 1; i < snapshots.snapshots.length; i++) {\r\n            removedSize += snapshots.snapshots[i].length;\r\n        }\r\n        snapshots.snapshots.splice(snapshots.currentIndex + 1);\r\n        snapshots.totalSize -= removedSize;\r\n    }\r\n}\r\n","import getColorNormalizedContent from '../darkMode/getColorNormalizedContent';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Copy plugin, hijacks copy events to normalize the content to the clipboard.\r\n */\r\nexport default class CopyPlugin implements EditorPlugin {\r\n    private editor: Editor;\r\n    private eventDisposer: () => void;\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Copy';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.eventDisposer = editor.addDomEventHandler({\r\n            copy: this.onExtract(false),\r\n            cut: this.onExtract(true),\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.eventDisposer();\r\n        this.eventDisposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    private onExtract = (isCut: boolean) => (event: Event) => {\r\n        // if it's dark mode...\r\n        if (this.editor && this.editor.isDarkMode()) {\r\n            // get whatever the current selection range is\r\n            const selectionRange = this.editor.getSelectionRange();\r\n            if (selectionRange && !selectionRange.collapsed) {\r\n                const clipboardEvent = event as ClipboardEvent;\r\n                const copyFragment = this.editor.getSelectionRange().cloneContents();\r\n\r\n                // revert just this selected range to light mode colors\r\n                const normalizedContent = getColorNormalizedContent(copyFragment);\r\n                const containerDiv = this.editor.getDocument().createElement('div');\r\n\r\n                // Leverage script execution policy on CEDs to try and prevent XSS\r\n                containerDiv.setAttribute('contenteditable', 'true');\r\n                containerDiv.innerHTML = normalizedContent;\r\n\r\n                // put it on the clipboard\r\n                clipboardEvent.clipboardData.setData('text/html', normalizedContent);\r\n                clipboardEvent.clipboardData.setData('text/plain', containerDiv.innerText);\r\n\r\n                // if it's cut, delete the contents\r\n                if (isCut) {\r\n                    this.editor.getSelectionRange().deleteContents();\r\n                }\r\n\r\n                event.preventDefault();\r\n            }\r\n        }\r\n    };\r\n}\r\n","import { isDocumentFragment } from 'roosterjs-cross-window';\r\nimport { toArray } from 'roosterjs-editor-dom';\r\n\r\nexport default function getColorNormalizedContent(content: string | DocumentFragment): string {\r\n    let el = document.createElement('div');\r\n    // Leverage script execution policy on CEDs to try and prevent XSS\r\n    el.setAttribute('contenteditable', 'true');\r\n    if (isDocumentFragment(content)) {\r\n        el.appendChild(content);\r\n    } else {\r\n        el.innerHTML = content;\r\n    }\r\n    const allChildElements = el.getElementsByTagName('*') as HTMLCollectionOf<HTMLElement>;\r\n    toArray(allChildElements).forEach((element: HTMLElement) => {\r\n        if (element.dataset) {\r\n            // Reset color styles based on the content of the ogsc/ogsb data element.\r\n            // If those data properties are empty or do not exist, set them anyway to clear the content.\r\n            element.style.color = isDataAttributeSettable(element.dataset.ogsc)\r\n                ? element.dataset.ogsc\r\n                : '';\r\n            element.style.backgroundColor = isDataAttributeSettable(element.dataset.ogsb)\r\n                ? element.dataset.ogsb\r\n                : '';\r\n\r\n            // Some elements might have set attribute colors. We need to reset these as well.\r\n            if (isDataAttributeSettable(element.dataset.ogac)) {\r\n                element.setAttribute('color', element.dataset.ogac);\r\n            } else {\r\n                element.removeAttribute('color');\r\n            }\r\n\r\n            if (isDataAttributeSettable(element.dataset.ogab)) {\r\n                element.setAttribute('bgcolor', element.dataset.ogab);\r\n            } else {\r\n                element.removeAttribute('bgcolor');\r\n            }\r\n\r\n            // Clean up any remaining data attributes.\r\n            if (element.dataset.ogsc) {\r\n                delete element.dataset.ogsc;\r\n            }\r\n\r\n            if (element.dataset.ogsb) {\r\n                delete element.dataset.ogsb;\r\n            }\r\n\r\n            if (element.dataset.ogac) {\r\n                delete element.dataset.ogac;\r\n            }\r\n\r\n            if (element.dataset.ogab) {\r\n                delete element.dataset.ogab;\r\n            }\r\n        }\r\n    });\r\n    const newContent = el.innerHTML;\r\n    return newContent;\r\n}\r\n\r\nfunction isDataAttributeSettable(newStyle: string) {\r\n    return newStyle && newStyle != 'undefined' && newStyle != 'null';\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport {\r\n    Browser,\r\n    getPendableFormatState,\r\n    Position,\r\n    PendableFormatNames,\r\n    PendableFormatCommandMap,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    PluginEventType,\r\n    NodePosition,\r\n    PendableFormatState,\r\n    PluginEvent,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * DOMEventPlugin handles customized DOM events, including:\r\n * 1. IME state management\r\n * 2. Selection management\r\n * 3. Cut and Drop management\r\n * 4. Pending format state management\r\n * 5. Scroll container and scroll event management\r\n */\r\nexport default class DOMEventPlugin implements EditorPlugin {\r\n    private editor: Editor;\r\n    private inIme = false;\r\n    private disposer: () => void;\r\n    private cachedPosition: NodePosition;\r\n    private cachedFormatState: PendableFormatState;\r\n\r\n    constructor(private disableRestoreSelectionOnFocus: boolean) {}\r\n\r\n    getName() {\r\n        return 'DOMEvent';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n\r\n        this.disposer = editor.addDomEventHandler({\r\n            // 1. IME state management\r\n            compositionstart: () => (this.inIme = true),\r\n            compositionend: (rawEvent: CompositionEvent) => {\r\n                this.inIme = false;\r\n                editor.triggerPluginEvent(PluginEventType.CompositionEnd, {\r\n                    rawEvent,\r\n                });\r\n            },\r\n\r\n            // 2. Cut and drop management\r\n            drop: this.onNativeEvent,\r\n            cut: this.onNativeEvent,\r\n\r\n            // 3. Selection mangement\r\n            focus: this.onFocus,\r\n            [Browser.isIEOrEdge ? 'beforedeactivate' : 'blur']: this.onBlur,\r\n        });\r\n\r\n        this.editor.getScrollContainer().addEventListener('scroll', this.onScroll);\r\n    }\r\n\r\n    dispose() {\r\n        this.editor.getScrollContainer().removeEventListener('scroll', this.onScroll);\r\n\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n        this.clear();\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        switch (event.eventType) {\r\n            case PluginEventType.PendingFormatStateChanged:\r\n                // Got PendingFormatStateChagned event, cache current position and pending format\r\n                this.cachedPosition = this.getCurrentPosition();\r\n                this.cachedFormatState = event.formatState;\r\n                break;\r\n            case PluginEventType.KeyDown:\r\n            case PluginEventType.MouseDown:\r\n            case PluginEventType.ContentChanged:\r\n                // If content or position is changed (by keyboard, mouse, or code),\r\n                // check if current position is still the same with the cached one (if exist),\r\n                // and clear cached format if position is changed since it is out-of-date now\r\n                if (\r\n                    this.cachedPosition &&\r\n                    !this.cachedPosition.equalTo(this.getCurrentPosition())\r\n                ) {\r\n                    this.clear();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore cached pending format state (if exist) to current selection\r\n     */\r\n    public restorePendingFormatState() {\r\n        if (this.cachedFormatState) {\r\n            let formatState = getPendableFormatState(this.editor.getDocument());\r\n            (<PendableFormatNames[]>Object.keys(PendableFormatCommandMap)).forEach(key => {\r\n                if (this.cachedFormatState[key] != formatState[key]) {\r\n                    this.editor\r\n                        .getDocument()\r\n                        .execCommand(PendableFormatCommandMap[key], false, null);\r\n                }\r\n            });\r\n            this.cachedPosition = this.getCurrentPosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME() {\r\n        return this.inIme;\r\n    }\r\n\r\n    private onNativeEvent = (e: UIEvent) => {\r\n        this.editor.runAsync(() => {\r\n            this.editor.addUndoSnapshot(\r\n                () => {},\r\n                e.type == 'cut' ? ChangeSource.Cut : ChangeSource.Drop\r\n            );\r\n        });\r\n    };\r\n\r\n    private onFocus = () => {\r\n        if (this.disableRestoreSelectionOnFocus) {\r\n            if (this.cachedPosition && this.cachedFormatState) {\r\n                let range = this.editor.getSelectionRange();\r\n                if (\r\n                    range.collapsed &&\r\n                    Position.getStart(range)\r\n                        .normalize()\r\n                        .equalTo(this.cachedPosition)\r\n                ) {\r\n                    this.restorePendingFormatState();\r\n                } else {\r\n                    this.clear();\r\n                }\r\n            }\r\n        } else {\r\n            this.editor.restoreSavedRange();\r\n        }\r\n    };\r\n\r\n    private onBlur = () => {\r\n        this.editor.saveSelectionRange();\r\n    };\r\n\r\n    private onScroll = (e: UIEvent) => {\r\n        this.editor.triggerPluginEvent(PluginEventType.Scroll, {\r\n            rawEvent: e,\r\n            scrollContainer: this.editor.getScrollContainer(),\r\n        });\r\n    };\r\n\r\n    private clear() {\r\n        this.cachedPosition = null;\r\n        this.cachedFormatState = null;\r\n    }\r\n\r\n    private getCurrentPosition() {\r\n        let range = this.editor.getSelectionRange();\r\n        return range && Position.getStart(range).normalize();\r\n    }\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport isCtrlOrMetaPressed from '../eventApi/isCtrlOrMetaPressed';\r\nimport { GenericContentEditFeature, Keys } from '../interfaces/ContentEditFeature';\r\nimport {\r\n    ChangeSource,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginKeyboardEvent,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Edit Component helps handle Content edit features\r\n */\r\nexport default class EditPlugin implements EditorPlugin {\r\n    private editor: Editor;\r\n    private featureMap: { [key: number]: GenericContentEditFeature<PluginEvent>[] } = {};\r\n\r\n    private autoCompleteSnapshot: string = null;\r\n    private autoCompleteChangeSource: string = null;\r\n\r\n    getName() {\r\n        return 'Edit';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.addFeature({\r\n            keys: [Keys.BACKSPACE],\r\n            shouldHandleEvent: () => this.autoCompleteSnapshot !== null,\r\n            handleEvent: (event: PluginKeyboardEvent, editor: Editor) => {\r\n                event.rawEvent.preventDefault();\r\n                editor.setContent(this.autoCompleteSnapshot, false /*triggerContentChangedEvent*/);\r\n            },\r\n        });\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        let contentChanged = false;\r\n        let currentFeature = this.findFeature(event);\r\n\r\n        switch (event.eventType) {\r\n            case PluginEventType.ContentChanged:\r\n                contentChanged = this.autoCompleteChangeSource != event.source;\r\n                break;\r\n            case PluginEventType.MouseDown:\r\n            case PluginEventType.KeyDown:\r\n                contentChanged = true;\r\n                break;\r\n        }\r\n\r\n        if (currentFeature) {\r\n            currentFeature.handleEvent(event, this.editor);\r\n        }\r\n\r\n        if (contentChanged) {\r\n            this.autoCompleteSnapshot = null;\r\n            this.autoCompleteChangeSource = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature\r\n     * @param feature The feature to add\r\n     */\r\n    addFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        feature.keys.forEach(key => {\r\n            let array = this.featureMap[key] || [];\r\n            array.push(feature);\r\n            this.featureMap[key] = array;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Perform an auto complete action in the callback, save a snapsnot of content before the action,\r\n     * and trigger ContentChangedEvent with the change source if specified\r\n     * @param callback The auto complete callback, return value will be used as data field of ContentChangedEvent\r\n     * @param changeSource Chagne source of ContentChangedEvent. If not passed, no ContentChangedEvent will be  triggered\r\n     */\r\n    performAutoComplete(callback: () => any, changeSource?: ChangeSource | string) {\r\n        this.editor.addUndoSnapshot((start, end, snapshot) => {\r\n            let data = callback();\r\n            this.autoCompleteSnapshot = snapshot;\r\n            this.autoCompleteChangeSource = changeSource;\r\n            return data;\r\n        }, changeSource);\r\n    }\r\n\r\n    private findFeature(event: PluginEvent) {\r\n        let hasFunctionKey = false;\r\n        let features: GenericContentEditFeature<PluginEvent>[];\r\n        let ctrlOrMeta = false;\r\n\r\n        if (event.eventType == PluginEventType.KeyDown) {\r\n            let rawEvent = event.rawEvent;\r\n            ctrlOrMeta = isCtrlOrMetaPressed(rawEvent);\r\n            hasFunctionKey = ctrlOrMeta || rawEvent.altKey;\r\n            features = this.featureMap[rawEvent.which];\r\n        } else if (event.eventType == PluginEventType.ContentChanged) {\r\n            features = this.featureMap[Keys.CONTENTCHANGED];\r\n        }\r\n        return (\r\n            features &&\r\n            features.filter(\r\n                feature =>\r\n                    (feature.allowFunctionKeys || !hasFunctionKey) &&\r\n                    feature.shouldHandleEvent(event, this.editor, ctrlOrMeta)\r\n            )[0]\r\n        );\r\n    }\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport { Browser, LinkInlineElement, Position } from 'roosterjs-editor-dom';\r\nimport { cacheGetContentSearcher } from '../eventApi/cacheGetContentSearcher';\r\nimport { PluginEvent, PluginEventType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * FirefoxTypeAfterLink Component helps handle typing event when cursor is right after a link.\r\n * When typing/pasting after a link, browser may put the new charactor inside link.\r\n * This plugin overrides this behavior to always insert outside of link.\r\n *\r\n * TODO: Rename this file in next major release since it is not only applied to Firefox now\r\n */\r\nexport default class FirefoxTypeAfterLink implements EditorPlugin {\r\n    private editor: Editor;\r\n\r\n    getName() {\r\n        return 'FirefoxTypeAfterLink';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (\r\n            (Browser.isFirefox && event.eventType == PluginEventType.KeyPress) ||\r\n            event.eventType == PluginEventType.BeforePaste\r\n        ) {\r\n            let range = this.editor.getSelectionRange();\r\n            if (range && range.collapsed && this.editor.getElementAtCursor('A[href]')) {\r\n                let searcher = cacheGetContentSearcher(event, this.editor);\r\n                let inlineElement = searcher.getInlineElementBefore();\r\n                if (inlineElement instanceof LinkInlineElement) {\r\n                    this.editor.select(\r\n                        new Position(inlineElement.getContainerNode(), PositionType.After)\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import cacheGetEventData from './cacheGetEventData';\r\nimport clearEventDataCache from './clearEventDataCache';\r\nimport Editor from '../editor/Editor';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\nimport { PositionContentSearcher } from 'roosterjs-editor-dom';\r\n\r\nconst CONTENTSEARCHER_KEY = 'CONTENTSEARCHER';\r\n\r\n/**\r\n * Try get existing PositionContentSearcher from an event. If there isn't one, create a new one from editor.\r\n * @param event The plugin event, it stores the event cached data for looking up.\r\n * If passed as null, we will create a new PositionContentSearcher\r\n * @param editor The editor instance\r\n * @returns The PositionContentSearcher object\r\n */\r\nexport function cacheGetContentSearcher(\r\n    event: PluginEvent,\r\n    editor: Editor\r\n): PositionContentSearcher {\r\n    return cacheGetEventData(event, CONTENTSEARCHER_KEY, () => editor.getContentSearcherOfCursor());\r\n}\r\n\r\n/**\r\n * Clear the PositionContentSearcher in a plugin event.\r\n * This is called when the content is changed\r\n * @param event The plugin event\r\n */\r\nexport function clearContentSearcherCache(event: PluginEvent) {\r\n    clearEventDataCache(event, CONTENTSEARCHER_KEY);\r\n}\r\n","import { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear a cached object by its key from an event object\r\n * @param event The event object\r\n * @param key The cache key\r\n */\r\nexport default function clearEventDataCache(event: PluginEvent, key: string): void {\r\n    if (event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)) {\r\n        delete event.eventDataCache[key];\r\n    }\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * MouseUp Component helps handle mouse up event\r\n * this can trigger mouse up event after mousedown happens in editor\r\n * even mouse up is happening outside editor\r\n */\r\nexport default class MouseUpPlugin implements EditorPlugin {\r\n    private mouseUpEventListerAdded: boolean;\r\n    private editor: Editor;\r\n\r\n    getName() {\r\n        return 'MouseUp';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    dispose() {\r\n        this.removeMouseUpEventListener();\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.MouseDown && !this.mouseUpEventListerAdded) {\r\n            this.editor\r\n                .getDocument()\r\n                .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);\r\n            this.mouseUpEventListerAdded = true;\r\n        }\r\n    }\r\n\r\n    private removeMouseUpEventListener() {\r\n        if (this.mouseUpEventListerAdded) {\r\n            this.mouseUpEventListerAdded = false;\r\n            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);\r\n        }\r\n    }\r\n\r\n    private onMouseUp = (rawEvent: MouseEvent) => {\r\n        if (this.editor) {\r\n            this.removeMouseUpEventListener();\r\n            this.editor.triggerPluginEvent(PluginEventType.MouseUp, {\r\n                rawEvent,\r\n            });\r\n        }\r\n    };\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport { isNode } from 'roosterjs-cross-window';\r\nimport {\r\n    applyFormat,\r\n    Browser,\r\n    findClosestElementAncestor,\r\n    fromHtml,\r\n    isNodeEmpty,\r\n    Position,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    ContentPosition,\r\n    NodePosition,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n    PluginEvent,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Typing Component helps to ensure typing is always happening under a DOM container\r\n */\r\nexport default class TypeInContainerPlugin implements EditorPlugin {\r\n    private editor: Editor;\r\n\r\n    getName() {\r\n        return 'TypeInContainer';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.KeyPress) {\r\n            this.onKeyPress(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ensure we are typing in an HTML Element inside editor, and apply default format if current block is empty\r\n     * @param node Current node\r\n     * @param event (optional) The keyboard event that we are ensuring is typing in an element.\r\n     * @returns A new position to select\r\n     */\r\n    ensureTypeInElement(position: NodePosition, event?: PluginKeyboardEvent): NodePosition {\r\n        let result = position.normalize();\r\n        let block = this.editor.getBlockElementAtNode(result.node);\r\n        let formatNode: HTMLElement;\r\n\r\n        if (block) {\r\n            formatNode = block.collapseToSingleElement();\r\n\r\n            // if the block is empty, apply default format\r\n            // Otherwise, leave it as it is as we don't want to change the style for existing data\r\n            // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)\r\n            const shouldSetNodeStyles =\r\n                isNodeEmpty(formatNode) ||\r\n                (event && this.wasNodeJustCreatedByKeyboardEvent(event, formatNode));\r\n            formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;\r\n        } else {\r\n            // Only reason we don't get the selection block is that we have an empty content div\r\n            // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)\r\n            // The fix is to add a DIV wrapping, apply default format and move cursor over\r\n            formatNode = fromHtml(\r\n                Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>',\r\n                this.editor.getDocument()\r\n            )[0] as HTMLElement;\r\n            this.editor.insertNode(formatNode, {\r\n                position: ContentPosition.End,\r\n                updateCursor: false,\r\n                replaceSelection: false,\r\n                insertOnNewLine: false,\r\n            });\r\n\r\n            // element points to a wrapping node we added \"<div><br></div>\". We should move the selection left to <br>\r\n            result = new Position(formatNode.firstChild, PositionType.Begin);\r\n        }\r\n\r\n        if (formatNode) {\r\n            applyFormat(formatNode, this.editor.getDefaultFormat(), this.editor.isDarkMode());\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private onKeyPress(event: PluginKeyboardEvent) {\r\n        // If normalization was not possible before the keypress,\r\n        // check again after the keyboard event has been processed by browser native behaviour.\r\n        //\r\n        // This handles the case where the keyboard event that first inserts content happens when\r\n        // there is already content under the selection (e.g. Ctrl+a -> type new content).\r\n        //\r\n        // Only scheudle when the range is not collapsed to catch this edge case.\r\n        let range = this.editor.getSelectionRange();\r\n\r\n        if (!range || this.editor.contains(findClosestElementAncestor(range.startContainer))) {\r\n            return;\r\n        }\r\n\r\n        if (range.collapsed) {\r\n            this.tryNormalizeTyping(event, range);\r\n        } else if (!range.collapsed) {\r\n            this.editor.runAsync(() => {\r\n                this.tryNormalizeTyping(event);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * When typing goes directly under content div, many things can go wrong\r\n     * We fix it by wrapping it with a div and reposition cursor within the div\r\n     */\r\n    private tryNormalizeTyping(event: PluginKeyboardEvent, range?: Range) {\r\n        let position = this.ensureTypeInElement(\r\n            Position.getStart(range || this.editor.getSelectionRange()),\r\n            event\r\n        );\r\n        this.editor.select(position);\r\n    }\r\n\r\n    private wasNodeJustCreatedByKeyboardEvent(event: PluginKeyboardEvent, formatNode: HTMLElement) {\r\n        return (\r\n            isNode(event.rawEvent.target) &&\r\n            event.rawEvent.target.contains(formatNode) &&\r\n            event.rawEvent.key === formatNode.innerText\r\n        );\r\n    }\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport isCtrlOrMetaPressed from '../eventApi/isCtrlOrMetaPressed';\r\nimport UndoService from '../interfaces/UndoService';\r\nimport UndoSnapshots from './UndoSnapshots';\r\nimport UndoSnapshotsService from '../interfaces/UndoSnapshotsService';\r\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\nconst KEY_BACKSPACE = 8;\r\nconst KEY_DELETE = 46;\r\nconst KEY_SPACE = 32;\r\nconst KEY_ENTER = 13;\r\nconst KEY_PAGEUP = 33;\r\nconst KEY_DOWN = 40;\r\n\r\n/**\r\n * Provides snapshot based undo service for Editor\r\n */\r\nexport default class Undo implements UndoService {\r\n    private editor: Editor;\r\n    private isRestoring: boolean;\r\n    private hasNewContent: boolean;\r\n    private lastKeyPress: number;\r\n\r\n    protected undoSnapshots: UndoSnapshotsService;\r\n\r\n    /**\r\n     * Create an instance of Undo\r\n     * @param preserveSnapshots True to preserve the snapshots after dispose, this allows\r\n     * this object to be reused when editor is disposed and created again\r\n     * @param maxBufferSize The max buffer size for snapshots. Default value is 10MB\r\n     */\r\n    constructor(private preserveSnapshots?: boolean, private maxBufferSize: number = 1e7) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Undo';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: Editor): void {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.editor = null;\r\n\r\n        if (!this.preserveSnapshots) {\r\n            this.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    public onPluginEvent(event: PluginEvent): void {\r\n        // if editor is in IME, don't do anything\r\n        if (this.editor.isInIME()) {\r\n            return;\r\n        }\r\n\r\n        switch (event.eventType) {\r\n            case PluginEventType.EditorReady:\r\n                if (!this.preserveSnapshots || (!this.canUndo() && !this.canRedo())) {\r\n                    // Only add initial snapshot when we don't need to preserve snapshots or there is no existing snapshot\r\n                    // Otherwise preserved undo/redo state may be ruined\r\n                    this.addUndoSnapshot();\r\n                }\r\n                break;\r\n            case PluginEventType.KeyDown:\r\n                this.onKeyDown(event.rawEvent);\r\n                break;\r\n            case PluginEventType.KeyPress:\r\n                this.onKeyPress(event.rawEvent);\r\n                break;\r\n            case PluginEventType.CompositionEnd:\r\n                this.clearRedoForInput();\r\n                this.addUndoSnapshot();\r\n                break;\r\n            case PluginEventType.ContentChanged:\r\n                if (!this.isRestoring) {\r\n                    this.clearRedoForInput();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all existing undo snapshots\r\n     */\r\n    public clear() {\r\n        this.undoSnapshots = null;\r\n        this.hasNewContent = false;\r\n    }\r\n\r\n    /**\r\n     * Restore an undo snapshot to editor\r\n     */\r\n    public undo(): void {\r\n        if (this.hasNewContent) {\r\n            this.addUndoSnapshot();\r\n        }\r\n\r\n        this.restoreSnapshot(-1 /*previousSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Restore a redo snapshot to editor\r\n     */\r\n    public redo(): void {\r\n        this.restoreSnapshot(1 /*nextSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Whether there is a snapshot for undo\r\n     */\r\n    public canUndo(): boolean {\r\n        return this.hasNewContent || this.getSnapshotsManager().canMove(-1 /*previousSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Whether there is a snapshot for redo\r\n     */\r\n    public canRedo(): boolean {\r\n        return this.getSnapshotsManager().canMove(1 /*nextSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Add an undo snapshot\r\n     */\r\n    public addUndoSnapshot(): string {\r\n        let snapshot = this.editor.getContent(\r\n            false /*triggerExtractContentEvent*/,\r\n            true /* includeSelectionMarker */\r\n        );\r\n        this.getSnapshotsManager().addSnapshot(snapshot);\r\n        this.hasNewContent = false;\r\n        return snapshot;\r\n    }\r\n\r\n    protected getSnapshotsManager(): UndoSnapshotsService {\r\n        if (!this.undoSnapshots) {\r\n            this.undoSnapshots = new UndoSnapshots(this.maxBufferSize);\r\n        }\r\n        return this.undoSnapshots;\r\n    }\r\n\r\n    private restoreSnapshot(delta: number) {\r\n        let snapshot = this.getSnapshotsManager().move(delta);\r\n\r\n        if (snapshot != null) {\r\n            try {\r\n                this.isRestoring = true;\r\n                this.editor.setContent(snapshot);\r\n            } finally {\r\n                this.isRestoring = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private onKeyDown(evt: KeyboardEvent): void {\r\n        // Handle backspace/delete when there is a selection to take a snapshot\r\n        // since we want the state prior to deletion restorable\r\n        if (evt.which == KEY_BACKSPACE || evt.which == KEY_DELETE) {\r\n            let selectionRange = this.editor.getSelectionRange();\r\n\r\n            // Add snapshot when\r\n            // 1. Something has been selected (not collapsed), or\r\n            // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\r\n            // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\r\n            if (\r\n                selectionRange &&\r\n                (!selectionRange.collapsed ||\r\n                    this.lastKeyPress != evt.which ||\r\n                    isCtrlOrMetaPressed(evt))\r\n            ) {\r\n                this.addUndoSnapshot();\r\n            }\r\n\r\n            // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\r\n            this.hasNewContent = true;\r\n            this.lastKeyPress = evt.which;\r\n        } else if (evt.which >= KEY_PAGEUP && evt.which <= KEY_DOWN) {\r\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\r\n            if (this.hasNewContent) {\r\n                this.addUndoSnapshot();\r\n            }\r\n            this.lastKeyPress = 0;\r\n        }\r\n    }\r\n\r\n    private onKeyPress(evt: KeyboardEvent): void {\r\n        if (evt.metaKey) {\r\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\r\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\r\n            return;\r\n        }\r\n\r\n        let range = this.editor.getSelectionRange();\r\n        if (\r\n            (range && !range.collapsed) ||\r\n            (evt.which == KEY_SPACE && this.lastKeyPress != KEY_SPACE) ||\r\n            evt.which == KEY_ENTER\r\n        ) {\r\n            this.addUndoSnapshot();\r\n            if (evt.which == KEY_ENTER) {\r\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\r\n                // we restore the snapshot before ENTER\r\n                this.hasNewContent = true;\r\n            }\r\n        } else {\r\n            this.clearRedoForInput();\r\n        }\r\n\r\n        this.lastKeyPress = evt.which;\r\n    }\r\n\r\n    private clearRedoForInput() {\r\n        this.getSnapshotsManager().clearRedo();\r\n        this.lastKeyPress = 0;\r\n        this.hasNewContent = true;\r\n    }\r\n}\r\n","import isModifierKey from './isModifierKey';\r\n\r\n/**\r\n * Returns true when the event was fired from a key that produces a character value, otherwise false\r\n * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\r\n * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\r\n * So if we missed some case here it is still acceptable.\r\n * @param event The keyboard event object\r\n */\r\nexport default function isCharacterValue(event: KeyboardEvent): boolean {\r\n    return !isModifierKey(event) && event.key && event.key.length == 1;\r\n}\r\n","const CTRL_CHARCODE = 'Control';\r\nconst ALT_CHARCODE = 'Alt';\r\nconst META_CHARCODE = 'Meta';\r\n\r\n/**\r\n * Returns true when the event was fired from a modifier key, otherwise false\r\n * @param event The keyboard event object\r\n */\r\nexport default function isModifierKey(event: KeyboardEvent): boolean {\r\n    const isCtrlKey = event.ctrlKey || event.key === CTRL_CHARCODE;\r\n    const isAltKey = event.altKey || event.key === ALT_CHARCODE;\r\n    const isMetaKey = event.metaKey || event.key === META_CHARCODE;\r\n\r\n    return isCtrlKey || isAltKey || isMetaKey;\r\n}\r\n","import { DefaultFormat } from 'roosterjs-editor-types';\r\nimport { getComputedStyles } from 'roosterjs-editor-dom';\r\n\r\nconst DARK_MODE_DEFAULT_FORMAT = {\r\n    backgroundColors: {\r\n        darkModeColor: 'rgb(51,51,51)',\r\n        lightModeColor: 'rgb(255,255,255)',\r\n    },\r\n    textColors: {\r\n        darkModeColor: 'rgb(255,255,255)',\r\n        lightModeColor: 'rgb(0,0,0)',\r\n    },\r\n};\r\n\r\nexport function calculateDefaultFormat(\r\n    node: Node,\r\n    baseFormat: DefaultFormat,\r\n    inDarkMode: boolean\r\n): DefaultFormat {\r\n    if (inDarkMode) {\r\n        if (!baseFormat.backgroundColors) {\r\n            baseFormat.backgroundColors = DARK_MODE_DEFAULT_FORMAT.backgroundColors;\r\n        }\r\n        if (!baseFormat.textColors) {\r\n            baseFormat.textColors = DARK_MODE_DEFAULT_FORMAT.textColors;\r\n        }\r\n    }\r\n\r\n    if (baseFormat && Object.keys(baseFormat).length === 0) {\r\n        return {};\r\n    }\r\n\r\n    baseFormat = baseFormat || <DefaultFormat>{};\r\n    let {\r\n        fontFamily,\r\n        fontSize,\r\n        textColor,\r\n        textColors,\r\n        backgroundColor,\r\n        backgroundColors,\r\n        bold,\r\n        italic,\r\n        underline,\r\n    } = baseFormat;\r\n    let currentStyles =\r\n        fontFamily && fontSize && (textColor || textColors) ? null : getComputedStyles(node);\r\n    return {\r\n        fontFamily: fontFamily || currentStyles[0],\r\n        fontSize: fontSize || currentStyles[1],\r\n        get textColor() {\r\n            return textColors\r\n                ? inDarkMode\r\n                    ? textColors.darkModeColor\r\n                    : textColors.lightModeColor\r\n                : textColor || currentStyles[2];\r\n        },\r\n        textColors: textColors,\r\n        get backgroundColor() {\r\n            return backgroundColors\r\n                ? inDarkMode\r\n                    ? backgroundColors.darkModeColor\r\n                    : backgroundColors.lightModeColor\r\n                : backgroundColor || '';\r\n        },\r\n        backgroundColors: backgroundColors,\r\n        bold: bold,\r\n        italic: italic,\r\n        underline: underline,\r\n    };\r\n}\r\n","import EditorCore, { HasFocus } from '../interfaces/EditorCore';\r\nimport { contains } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Check if the editor has focus now\r\n * @param core The EditorCore object\r\n * @returns True if the editor has focus, otherwise false\r\n */\r\nexport const hasFocus: HasFocus = (core: EditorCore) => {\r\n    let activeElement = core.document.activeElement;\r\n    return (\r\n        activeElement && contains(core.contentDiv, activeElement, true /*treatSameNodeAsContain*/)\r\n    );\r\n};\r\n","import { Browser } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Feature set for ContentEdit plugin.\r\n * Call getDefaultContentEditFeatures() to get default feature set.\r\n */\r\nexport default interface ContentEditFeatures {\r\n    /**\r\n     * When press Tab in a list, indent current list item\r\n     * @default true\r\n     */\r\n    indentWhenTab: boolean;\r\n\r\n    /**\r\n     * When press Shift+Tab in a list, outdent current list item\r\n     * @default true\r\n     */\r\n    outdentWhenShiftTab: boolean;\r\n\r\n    /**\r\n     * When press BaskSpace on empty line which is the first item of a list, outdent current list item\r\n     * @default true\r\n     */\r\n    outdentWhenBackspaceOnEmptyFirstLine: boolean;\r\n\r\n    /**\r\n     * When press Enter on empty line in a list, outdent current list item\r\n     * @default true for IE, false for other browsers since they have already had the behavior\r\n     */\r\n    outdentWhenEnterOnEmptyLine: boolean;\r\n\r\n    /**\r\n     * When press Backspace on first char in a list, make current item a new line of previous list item\r\n     * @default false\r\n     */\r\n    mergeInNewLineWhenBackspaceOnFirstChar: boolean;\r\n\r\n    /**\r\n     * When press BAckspace on empty line which is the first line of a blockquote, unquote current line\r\n     * @default true\r\n     */\r\n    unquoteWhenBackspaceOnEmptyFirstLine: boolean;\r\n\r\n    /**\r\n     * When press Enter on empty line in a blockquote, unquote current line\r\n     * @default true\r\n     */\r\n    unquoteWhenEnterOnEmptyLine: boolean;\r\n\r\n    /**\r\n     * When press space after an asterik or number in an empty line, toggle bullet/numbering\r\n     * @default true\r\n     */\r\n    autoBullet: boolean;\r\n\r\n    /**\r\n     * When press TAB or SHIFT+TAB key in table cell, jump to next/previous table cell\r\n     * @default true\r\n     */\r\n    tabInTable: boolean;\r\n\r\n    /**\r\n     * When press Up or Down in table cell, jump to the table cell above/below\r\n     * @default true for Chrome and safari, false for other browsers since they arleady have correct behavior\r\n     */\r\n    upDownInTable: boolean;\r\n\r\n    /**\r\n     * When press Enter at the beginning of first structured element (table, list) and there isn't line before the position\r\n     * we create a new line before so that user got a chance to enter content before the table or list\r\n     * @default false\r\n     */\r\n    insertLineBeforeStructuredNodeFeature: boolean;\r\n\r\n    /**\r\n     * When press Space or Enter after a hyperlink-like string, convert the string to a hyperlink\r\n     * @default true\r\n     */\r\n    autoLink: boolean;\r\n\r\n    /**\r\n     * Respond to default common keyboard short, i.e. Ctrl+B, Ctrl+I, Ctrl+U, Ctrl+Z, Ctrl+Y\r\n     * @default true\r\n     */\r\n    defaultShortcut: boolean;\r\n\r\n    /**\r\n     * Unlink when backspace right after a hyperlink\r\n     * @default false\r\n     */\r\n    unlinkWhenBackspaceAfterLink: boolean;\r\n\r\n    /**\r\n     * Chrome may make the cursor move the then end of document if press Ctrl+Left at the beginning of document\r\n     * Let's disable this behaivor\r\n     */\r\n    noCycleCursorMove: boolean;\r\n\r\n    /**\r\n     * When generate ordered list, the list bullet will variare according its nesting level, in a loop of '1', 'a', 'i'\r\n     * @default false\r\n     */\r\n    smartOrderedList: boolean;\r\n\r\n    /**\r\n     * A style list for smart ordered list. This value is only effective when smartOrderedList is true\r\n     * @default ['lower-alpha', 'lower-roman', 'decimal']\r\n     */\r\n    smartOrderedListStyles: string[];\r\n}\r\n\r\n/**\r\n * Get default feature set of ContentEdit plugin\r\n */\r\nexport function getDefaultContentEditFeatures(): ContentEditFeatures {\r\n    return {\r\n        autoLink: true,\r\n        indentWhenTab: true,\r\n        outdentWhenShiftTab: true,\r\n        outdentWhenBackspaceOnEmptyFirstLine: true,\r\n        outdentWhenEnterOnEmptyLine: Browser.isIE || Browser.isChrome,\r\n        mergeInNewLineWhenBackspaceOnFirstChar: false,\r\n        unquoteWhenBackspaceOnEmptyFirstLine: true,\r\n        unquoteWhenEnterOnEmptyLine: true,\r\n        autoBullet: true,\r\n        tabInTable: true,\r\n        upDownInTable: Browser.isChrome || Browser.isSafari,\r\n        insertLineBeforeStructuredNodeFeature: false,\r\n        defaultShortcut: true,\r\n        unlinkWhenBackspaceAfterLink: false,\r\n        noCycleCursorMove: Browser.isChrome,\r\n        smartOrderedList: false,\r\n        smartOrderedListStyles: ['lower-alpha', 'lower-roman', 'decimal'],\r\n    };\r\n}\r\n","import { BlockElement, NodeType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getTagOfNode, StartEndBlockElement } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Collapse all selected blocks, return single HTML elements for each block\r\n * @param editor The editor instance\r\n * @param forEachCallback A callback function to invoke for each of the collapsed element\r\n */\r\nexport default function collapseSelectedBlocked(\r\n    editor: Editor,\r\n    forEachCallback: (element: HTMLElement) => any\r\n) {\r\n    let traverser = editor.getSelectionTraverser();\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let blocks: BlockElement[] = [];\r\n    while (block) {\r\n        if (!isEmptyBlockUnderTR(block)) {\r\n            blocks.push(block);\r\n        }\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    blocks.forEach(block => {\r\n        let element = block.collapseToSingleElement();\r\n        forEachCallback(element);\r\n    });\r\n}\r\n\r\nfunction isEmptyBlockUnderTR(block: BlockElement): boolean {\r\n    let startNode = block.getStartNode();\r\n\r\n    return (\r\n        block instanceof StartEndBlockElement &&\r\n        startNode == block.getEndNode() &&\r\n        startNode.nodeType == NodeType.Text &&\r\n        ['TR', 'TABLE'].indexOf(getTagOfNode(startNode.parentNode)) >= 0\r\n    );\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set background color at current selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n **/\r\nexport default function setBackgroundColor(editor: Editor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset.ogsb = color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set font name at selection\r\n * @param editor The editor instance\r\n * @param fontName The fontName string, should be a valid CSS font-family style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontName(editor: Editor, fontName: string) {\r\n    fontName = fontName.trim();\r\n    // The browser provided execCommand creates a HTML <font> tag with face attribute. <font> is not HTML5 standard\r\n    // (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-family style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontFamily = isInnerNode ? '' : fontName;\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Set font size at selection\r\n * @param editor The editor instance\r\n * @param fontSize The fontSize string, should be a valid CSS font-size style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontSize(editor: Editor, fontSize: string) {\r\n    fontSize = fontSize.trim();\r\n    // The browser provided execCommand only accepts 1-7 point value. In addition, it uses HTML <font> tag with size attribute.\r\n    // <font> is not HTML5 standard (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-size style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontSize = isInnerNode ? '' : fontSize;\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set text color at selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n */\r\nexport default function setTextColor(editor: Editor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset.ogsc = color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle bold at selection\r\n * If selection is collapsed, it will only affect the following input after caret\r\n * If selection contains only bold text, the bold style will be removed\r\n * If selection contains only normal text, bold style will be added to the whole selected text\r\n * If selection contains both bold and normal text, bold stle will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBold(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Bold);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle italic at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only italic text, the italic style will be removed\r\n * If selection contains only normal text, italic style will be added to the whole selected text\r\n * If selection contains both italic and normal text, italic stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleItalic(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Italic);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle underline at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only underlined text, the underline style will be removed\r\n * If selection contains only normal text, underline style will be added to the whole selected text\r\n * If selection contains both underlined and normal text, the underline style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleUnderline(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Underline);\r\n}\r\n","import { StringMap } from '../types/maps';\r\n\r\n// Inheritable CSS properties\r\n// Ref: https://www.w3.org/TR/CSS21/propidx.html\r\nconst INHERITABLE_PROPERTIES = (\r\n    'border-spacing,caption-side,color,' +\r\n    'cursor,direction,empty-cells,font-family,font-size,font-style,font-variant,font-weight,' +\r\n    'font,letter-spacing,line-height,list-style-image,list-style-position,list-style-type,' +\r\n    'list-style,orphans,quotes,text-align,text-indent,text-transform,visibility,white-space,' +\r\n    'widows,word-spacing'\r\n).split(',');\r\n\r\n/**\r\n * Get inheritable CSS style values from the given element\r\n * @param element The element to get style from\r\n */\r\nexport default function getInheritableStyles(element: HTMLElement): StringMap {\r\n    let win = element && element.ownerDocument && element.ownerDocument.defaultView;\r\n    let styles = win && win.getComputedStyle(element);\r\n    let result: StringMap = {};\r\n    INHERITABLE_PROPERTIES.forEach(\r\n        name => (result[name] = (styles && styles.getPropertyValue(name)) || '')\r\n    );\r\n    return result;\r\n}\r\n","const START_FRAGMENT = '<!--StartFragment-->';\r\nconst END_FRAGMENT = '<!--EndFragment-->';\r\n\r\n/**\r\n * Build DOM tree from the given HTML string\r\n * @param html Source HTML string\r\n * @param preserveFragmentOnly If there is fragment markup (&lt;!--StartFragment--&gt; and &lt;!--EndFragment--&gt;),\r\n * only preserve content between these markups\r\n * @param fragmentHandler An optional callback to do customized fragment handling\r\n */\r\nexport default function htmlToDom(\r\n    html: string,\r\n    preserveFragmentOnly: boolean,\r\n    fragmentHandler?: (doc: HTMLDocument, sourceHtml: string) => void\r\n): HTMLDocument {\r\n    let parser = new DOMParser();\r\n    let doc = parser.parseFromString(html || '', 'text/html');\r\n\r\n    if (doc && doc.body && doc.body.firstChild) {\r\n        // 1. Filter out html code outside of Fragment tags if need\r\n        if (preserveFragmentOnly) {\r\n            (fragmentHandler || defaultFragmentTrimmer)(doc, html);\r\n        }\r\n\r\n        return doc;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction defaultFragmentTrimmer(doc: HTMLDocument, sourceHtml: string) {\r\n    let [html] = splitWithFragment(sourceHtml);\r\n    doc.body.innerHTML = html;\r\n}\r\n\r\n/**\r\n * Split the HTML string using its fragment info\r\n * @param html Source html string\r\n * @returns [String within fragment, String before fragment, String after fragment]\r\n */\r\nexport function splitWithFragment(html: string): [string, string, string] {\r\n    let startIndex = html.indexOf(START_FRAGMENT);\r\n    let endIndex = html.lastIndexOf(END_FRAGMENT);\r\n    if (startIndex >= 0 && endIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {\r\n        let before = html.substr(0, startIndex);\r\n        let after = html.substr(endIndex + END_FRAGMENT.length);\r\n        html = html.substring(startIndex + START_FRAGMENT.length, endIndex);\r\n        return [html, before, after];\r\n    } else {\r\n        return [html, null, null];\r\n    }\r\n}\r\n","import { Map } from '../types/maps';\r\n\r\nfunction nativeClone<T>(source: Map<T>, existingObj?: Map<T>): Map<T> {\r\n    return Object.assign(existingObj || {}, source);\r\n}\r\n\r\nfunction customClone<T>(source: Map<T>, existingObj?: Map<T>): Map<T> {\r\n    let result: Map<T> = existingObj || {};\r\n    if (source) {\r\n        for (let key of Object.keys(source)) {\r\n            result[key] = source[key];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nexport const cloneObject = Object.assign ? nativeClone : customClone;\r\n","import { ChangeSource, PositionType, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    Browser,\r\n    fromHtml,\r\n    getTagOfNode,\r\n    Position,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst ZERO_WIDTH_SPACE = '&#8203;';\r\nconst UNWRAPPABLE_NODES = 'LI,THEAD,TBODY,TR,TD,TH'.split(',');\r\nconst DEFAULT_STYLER = (_: HTMLElement) => {};\r\n\r\n/**\r\n * Toggle a tag at selection, if selection already contains elements of such tag,\r\n * the elements will be untagge and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param tag The tag name\r\n * @param styler (Optional) The styler for setting the style for the blockquote element\r\n * @param wrapFunction (Optional) The wrap function\r\n * @param unwrapFunction (Optional) The unwrap function\r\n */\r\nexport default function toggleTagCore<T extends keyof HTMLElementTagNameMap>(\r\n    editor: Editor,\r\n    tag: T,\r\n    styler?: (element: HTMLElement) => void,\r\n    wrapFunction: (nodes: Node[]) => HTMLElement = nodes => wrap(nodes, tag),\r\n    unwrapFunction: (node: Node) => Node = unwrap\r\n): void {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        let result: HTMLElement;\r\n        let range = editor.getSelectionRange();\r\n        if (\r\n            range &&\r\n            editor.queryElements(tag, QueryScope.OnSelection, unwrapFunction).length == 0\r\n        ) {\r\n            let startNode = Position.getStart(range).normalize().node;\r\n            let startBlock = editor.getBlockElementAtNode(startNode);\r\n            let endNode = Position.getEnd(range).normalize().node;\r\n            let endBlock = editor.getBlockElementAtNode(endNode);\r\n            let nodes =\r\n                startBlock && endBlock\r\n                    ? editor.collapseNodes(\r\n                          startBlock.getStartNode(),\r\n                          endBlock.getEndNode(),\r\n                          true /*canSplitParent*/\r\n                      )\r\n                    : [];\r\n\r\n            if (nodes.length == 0) {\r\n                // Selection is collapsed and blockElement is null, we need to create an empty div.\r\n                // In case of IE and Edge, we insert ZWS to put cursor in the div, otherwise insert BR node.\r\n                nodes = fromHtml(\r\n                    `<DIV>${Browser.isIEOrEdge ? ZERO_WIDTH_SPACE : '<BR>'}</DIV>`,\r\n                    editor.getDocument()\r\n                );\r\n                editor.insertNode(nodes[0]);\r\n                editor.select(nodes[0], PositionType.Begin);\r\n            } else if (nodes.length == 1) {\r\n                let tag = getTagOfNode(nodes[0]);\r\n                if (tag == 'BR') {\r\n                    nodes = [wrap(nodes[0])];\r\n                } else if (tag == 'LI' || tag == 'TD') {\r\n                    nodes = toArray(nodes[0].childNodes);\r\n                }\r\n            } else {\r\n                while (\r\n                    nodes[0] &&\r\n                    editor.contains(nodes[0].parentNode) &&\r\n                    nodes.some(node => UNWRAPPABLE_NODES.indexOf(getTagOfNode(node)) >= 0)\r\n                ) {\r\n                    nodes = [splitBalancedNodeRange(nodes)];\r\n                }\r\n            }\r\n\r\n            result = wrapFunction(nodes);\r\n            (styler || DEFAULT_STYLER)(result);\r\n        }\r\n\r\n        if (!editor.select(start, end) && result) {\r\n            editor.select(result);\r\n        }\r\n\r\n        return result;\r\n    }, ChangeSource.Format);\r\n}\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/** NodeId attribute */\r\nconst NODE_ID_ATTRIBUTE_NAME = 'NodeId';\r\n\r\n/** Custom data for dom elements */\r\nexport default interface CustomData {\r\n    /** The dict storing custom data, key is element Id, value is dictionary */\r\n    dict: { [key: string]: { [key: string]: number } };\r\n\r\n    /** Next node Id to use */\r\n    nextNodeId: number;\r\n}\r\n\r\n/** create an empty CustomData */\r\nexport function createCustomData(): CustomData {\r\n    return {\r\n        dict: {},\r\n        nextNodeId: 1,\r\n    };\r\n}\r\n\r\n/**\r\n * Sets the specified object data\r\n */\r\nexport function setObject(customData: CustomData, element: Node, key: string, value: any) {\r\n    // Get the id for the element\r\n    if (element.nodeType == NodeType.Element) {\r\n        let id = getAndSetNodeId(customData, element as HTMLElement);\r\n        if (id != '') {\r\n            // Get the values for the element\r\n            if (!customData.dict[id]) {\r\n                // First time dictionary creation\r\n                customData.dict[id] = {};\r\n            }\r\n            customData.dict[id][key] = value;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Reads the specified object data\r\n */\r\nexport function getObject(customData: CustomData, element: Node, key: string): any {\r\n    if (element.nodeType == NodeType.Element) {\r\n        let id = getAndSetNodeId(customData, element as HTMLElement);\r\n        if (id != '') {\r\n            return customData.dict[id] && customData.dict[id][key];\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/** Get the unique id for the specified node... */\r\nfunction getAndSetNodeId(customData: CustomData, element: HTMLElement): string {\r\n    let id = element.getAttribute(NODE_ID_ATTRIBUTE_NAME);\r\n    if (!id) {\r\n        id = customData.nextNodeId.toString();\r\n        customData.nextNodeId++;\r\n        element.setAttribute(NODE_ID_ATTRIBUTE_NAME, id);\r\n    }\r\n    return id;\r\n}\r\n","import ListMetadata from './ListMetadata';\r\n\r\n/** Holds the ids for the lists already seen for a specified level */\r\nexport default interface LevelLists {\r\n    /**\r\n     * The metadata for the lists seen at  this level\r\n     * key: word list id, value: list metadata\r\n     */\r\n    listsMetadata: { [key: string]: ListMetadata };\r\n\r\n    /** Unique id of the list currently at this level */\r\n    currentUniqueListId: number;\r\n}\r\n\r\n/** create an empty LevelLists */\r\nexport function createLevelLists(): LevelLists {\r\n    return {\r\n        listsMetadata: {},\r\n        currentUniqueListId: -1,\r\n    };\r\n}\r\n","export const WORD_ORDERED_LIST_SELECTOR = 'div.ListContainerWrapper > ul[class^=\"BulletListStyle\"]';\n\nexport const WORD_UNORDERED_LIST_SELECTOR = 'div.ListContainerWrapper > ol[class^=\"NumberListStyle\"]';\n\nexport const WORD_ONLINE_IDENTIFYING_SELECTOR = `${WORD_ORDERED_LIST_SELECTOR},${WORD_UNORDERED_LIST_SELECTOR}`;\n\nexport const LIST_CONTAINER_ELEMENT_CLASS_NAME = \"ListContainerWrapper\";\n\nexport const UNORDERED_LIST_TAG_NAME = \"UL\";\n\nexport const ORDERED_LIST_TAG_NAME = \"OL\";\n\nconst TEXT_CONTAINER_ELEMENT_CLASS_NAME = \"OutlineElement\";\n\nexport const WAC_IDENTIFING_SELECTOR = `ul[class^=\"BulletListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME},ol[class^=\"NumberListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME}`;","export { default as createEditor } from './createEditor';\r\nexport * from 'roosterjs-editor-types';\r\nexport * from 'roosterjs-editor-dom';\r\nexport * from 'roosterjs-editor-core';\r\nexport * from 'roosterjs-editor-api';\r\nexport * from 'roosterjs-editor-plugins';\r\nexport * from 'roosterjs-plugin-image-resize';\r\nexport * from 'roosterjs-html-sanitizer';\r\nexport * from 'roosterjs-plugin-picker';\r\n","import { ContentEdit, HyperLink, Paste } from 'roosterjs-editor-plugins';\r\nimport { Editor, EditorOptions, EditorPlugin } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Create an editor instance with most common options\r\n * @param contentDiv The html div element needed for creating the editor\r\n * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are\r\n * DefalutShortcut, HyperLink, Paste, and ContentEdit, user don't need to add those.\r\n * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.\r\n * @returns The editor instance\r\n */\r\nexport default function createEditor(\r\n    contentDiv: HTMLDivElement,\r\n    additionalPlugins?: EditorPlugin[],\r\n    initialContent?: string\r\n): Editor {\r\n    let plugins: EditorPlugin[] = [new HyperLink(), new Paste(), new ContentEdit()];\r\n\r\n    if (additionalPlugins) {\r\n        plugins = plugins.concat(additionalPlugins);\r\n    }\r\n\r\n    let options: EditorOptions = {\r\n        plugins: plugins,\r\n        initialContent: initialContent,\r\n        defaultFormat: {\r\n            fontFamily: 'Calibri,Arial,Helvetica,sans-serif',\r\n            fontSize: '11pt',\r\n            textColor: '#000000',\r\n        },\r\n    };\r\n    return new Editor(contentDiv, options);\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\nimport { Editor, EditorPlugin, isCtrlOrMetaPressed } from 'roosterjs-editor-core';\r\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * An editor plugin that show a tooltip for existing link\r\n */\r\nexport default class HyperLink implements EditorPlugin {\r\n    private editor: Editor;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Create a new instance of HyperLink class\r\n     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.\r\n     * Default value is to return the href itself. If null, there will be no tooltip text.\r\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\r\n     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)\r\n     */\r\n    constructor(\r\n        private getTooltipCallback: (href: string, a: HTMLAnchorElement) => string = href => href,\r\n        private target?: string,\r\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => boolean | void\r\n    ) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Hyperlink';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    public initialize(editor: Editor): void {\r\n        this.editor = editor;\r\n        this.disposer =\r\n            this.getTooltipCallback &&\r\n            editor.addDomEventHandler({ mouseover: this.onMouse, mouseout: this.onMouse });\r\n    }\r\n\r\n    protected onMouse = (e: MouseEvent) => {\r\n        const a = this.editor.getElementAtCursor('a[href]', <Node>e.target) as HTMLAnchorElement;\r\n        const href = this.tryGetHref(a);\r\n\r\n        if (href) {\r\n            this.editor.setEditorDomAttribute(\r\n                'title',\r\n                e.type == 'mouseover' ? this.getTooltipCallback(href, a) : null\r\n            );\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose(): void {\r\n        if (this.disposer) {\r\n            this.disposer();\r\n            this.disposer = null;\r\n        }\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    public onPluginEvent(event: PluginEvent): void {\r\n        if (event.eventType == PluginEventType.MouseUp) {\r\n            const anchor = this.editor.getElementAtCursor('A', <Node>(\r\n                event.rawEvent.srcElement\r\n            )) as HTMLAnchorElement;\r\n\r\n            if (anchor) {\r\n                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {\r\n                    return;\r\n                }\r\n\r\n                let href: string;\r\n                if (\r\n                    !Browser.isFirefox &&\r\n                    (href = this.tryGetHref(anchor)) &&\r\n                    isCtrlOrMetaPressed(event.rawEvent) &&\r\n                    event.rawEvent.button === 0\r\n                ) {\r\n                    try {\r\n                        const target = this.target || '_blank';\r\n                        const window = this.editor.getDocument().defaultView;\r\n                        window.open(href, target);\r\n                    } catch {}\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Try get href from an anchor element\r\n     * The reason this is put in a try-catch is that\r\n     * it has been seen that accessing href may throw an exception, in particular on IE/Edge\r\n     */\r\n    private tryGetHref(anchor: HTMLAnchorElement): string {\r\n        try {\r\n            return anchor ? anchor.href : null;\r\n        } catch {}\r\n    }\r\n}\r\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is DocumentFragment\n * @param obj The object to check\n */\nexport default function isDocumentFragment(obj: any): obj is DocumentFragment {\n    return safeInstanceOf(obj as Node, 'DocumentFragment');\n}\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is HTMLElement\n * @param obj The object to check\n */\nexport default function isHTMLElement(obj: any): obj is HTMLElement {\n    return safeInstanceOf(obj as Node, 'HTMLElement');\n}\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is HTMLOListElement\n * @param obj The object to check\n */\nexport default function isHTMLOListElement(obj: any): obj is HTMLOListElement {\n    return safeInstanceOf(obj as Node, 'HTMLOListElement');\n}\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is HTMLTableCellElement\n * @param obj The object to check\n */\nexport default function isHTMLTableCellElement(obj: any): obj is HTMLTableCellElement {\n    return safeInstanceOf(obj as Node, 'HTMLTableCellElement');\n}\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is HTMLTableElement\n * @param obj The object to check\n */\nexport default function isHTMLTableElement(obj: any): obj is HTMLTableElement {\n    return safeInstanceOf(obj as Node, 'HTMLTableElement');\n}\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is Node\n * @param obj The object to check\n */\nexport default function isNode(obj: any): obj is Node {\n    return safeInstanceOf(obj as Node, 'Node');\n}\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is Range\n * @param obj The object to check\n */\nexport default function isRange(obj: any): obj is Range {\n    return safeInstanceOf(obj as Node, 'Range');\n}\n","import contains from '../utils/contains';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\nimport { getFirstBlockElement } from '../blockElements/getFirstLastBlockElement';\r\nimport { getFirstInlineElement } from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * provides scoper for traversing the entire editor body starting from the beginning\r\n */\r\nexport default class BodyScoper implements TraversingScoper {\r\n    private startNode: Node;\r\n\r\n    /**\r\n     * Construct a new instance of BodyScoper class\r\n     * @param rootNode Root node of the body\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    constructor(public rootNode: Node, startNode?: Node) {\r\n        this.startNode = contains(rootNode, startNode) ? startNode : null;\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.startNode\r\n            ? getBlockElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstBlockElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        return this.startNode\r\n            ? getInlineElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstInlineElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Since the scope is global, all blocks under the root node are in scope\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return contains(this.rootNode, blockElement.getStartNode());\r\n    }\r\n\r\n    /**\r\n     * Since we're at body scope, inline elements never need to be trimmed\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return inlineElement;\r\n    }\r\n}\r\n","import EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport NodeBlockElement from '../blockElements/NodeBlockElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { isRange } from 'roosterjs-cross-window';\r\nimport {\r\n    getFirstInlineElement,\r\n    getLastInlineElement,\r\n} from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * This provides traversing content in a selection start block\r\n * This is commonly used for those cursor context sensitive plugin,\r\n * they want to know text being typed at cursor\r\n * This provides a scope for parsing from cursor position up to begin of the selection block\r\n */\r\nexport default class SelectionBlockScoper implements TraversingScoper {\r\n    private block: BlockElement;\r\n    private position: NodePosition;\r\n\r\n    /**\r\n     * Create a new instance of SelectionBlockScoper class\r\n     * @param rootNode The root node of the whole scope\r\n     * @param position Position of the selection start\r\n     * @param startFrom Where to start, can be Begin, End, SelectionStart\r\n     */\r\n    constructor(\r\n        public rootNode: Node,\r\n        position: NodePosition | Range,\r\n        private startFrom: ContentPosition\r\n    ) {\r\n        position = isRange(position) ? Position.getStart(position) : position;\r\n        this.position = position.normalize();\r\n        this.block = getBlockElementAtNode(this.rootNode, this.position.node);\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.block;\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     * The start inline refers to inline before the selection start\r\n     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragragh,\r\n     * the one after likely will point to inline in next paragragh which may be null if the cursor is at bottom of editor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (this.block) {\r\n            switch (this.startFrom) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End:\r\n                case ContentPosition.DomEnd:\r\n                    return getFirstLastInlineElementFromBlockElement(\r\n                        this.block,\r\n                        this.startFrom == ContentPosition.Begin\r\n                    );\r\n                case ContentPosition.SelectionStart:\r\n                    // Get the inline before selection start point, and ensure it falls in the selection block\r\n                    let startInline = getInlineElementAfter(this.rootNode, this.position);\r\n                    return startInline && this.block.contains(startInline.getContainerNode())\r\n                        ? startInline\r\n                        : new EmptyInlineElement(this.position, this.block);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if the given block element is in current scope\r\n     * @param blockElement The block element to check\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return this.block && blockElement ? this.block.equals(blockElement) : false;\r\n    }\r\n\r\n    /**\r\n     * Trim the incoming inline element, and return an inline element\r\n     * This just tests and return the inline element if it is in block\r\n     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half\r\n     * A block scoper does not cut an inline in half\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())\r\n            ? inlineElement\r\n            : null;\r\n    }\r\n}\r\n\r\n/**\r\n * Get first/last InlineElement of the given BlockElement\r\n * @param block The BlockElement to get InlineElement from\r\n * @param isFirst True to get first InlineElement, false to get last InlineElement\r\n */\r\nfunction getFirstLastInlineElementFromBlockElement(\r\n    block: BlockElement,\r\n    isFirst: boolean\r\n): InlineElement {\r\n    if (block instanceof NodeBlockElement) {\r\n        let blockNode = block.getStartNode();\r\n        return isFirst ? getFirstInlineElement(blockNode) : getLastInlineElement(blockNode);\r\n    } else {\r\n        return getInlineElementAtNode(block, isFirst ? block.getStartNode() : block.getEndNode());\r\n    }\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\n\r\n/**\r\n * This is selection scoper that provide a start inline as the start of the selection\r\n * and checks if a block falls in the selection (isBlockInScope)\r\n * last trimInlineElement to trim any inline element to return a partial that falls in the selection\r\n */\r\nexport default class SelectionScoper implements TraversingScoper {\r\n    private start: NodePosition;\r\n    private end: NodePosition;\r\n    private startBlock: BlockElement;\r\n    private startInline: InlineElement;\r\n\r\n    /**\r\n     * Create a new instance of SelectionScoper class\r\n     * @param rootNode The root node of the content\r\n     * @param range The selection range to scope to\r\n     */\r\n    constructor(public rootNode: Node, range: Range) {\r\n        this.start = Position.getStart(range).normalize();\r\n        this.end = Position.getEnd(range).normalize();\r\n    }\r\n\r\n    /**\r\n     * Provide a start block as the first block after the cursor\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        if (!this.startBlock) {\r\n            this.startBlock = getBlockElementAtNode(this.rootNode, this.start.node);\r\n        }\r\n\r\n        return this.startBlock;\r\n    }\r\n\r\n    /**\r\n     * Provide a start inline as the first inline after the cursor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (!this.startInline) {\r\n            this.startInline = this.trimInlineElement(\r\n                getInlineElementAfter(this.rootNode, this.start)\r\n            );\r\n        }\r\n\r\n        return this.startInline;\r\n    }\r\n\r\n    /**\r\n     * Checks if a block completely falls in the selection\r\n     * @param block The BlockElement to check\r\n     */\r\n    public isBlockInScope(block: BlockElement): boolean {\r\n        if (!block) {\r\n            return false;\r\n        }\r\n        let inScope = false;\r\n        let selStartBlock = this.getStartBlockElement();\r\n        if (this.start.equalTo(this.end)) {\r\n            inScope = selStartBlock && selStartBlock.equals(block);\r\n        } else {\r\n            let selEndBlock = getBlockElementAtNode(this.rootNode, this.end.node);\r\n\r\n            // There are three cases that are considered as \"block in scope\"\r\n            // 1) The start of selection falls on the block\r\n            // 2) The end of selection falls on the block\r\n            // 3) the block falls in-between selection start and end\r\n            inScope =\r\n                selStartBlock &&\r\n                selEndBlock &&\r\n                (block.equals(selStartBlock) ||\r\n                    block.equals(selEndBlock) ||\r\n                    (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));\r\n        }\r\n\r\n        return inScope;\r\n    }\r\n\r\n    /**\r\n     * Trim an incoming inline. If it falls completely outside selection, return null\r\n     * otherwise return a partial that represents the portion that falls in the selection\r\n     * @param inline The InlineElement to check\r\n     */\r\n    public trimInlineElement(inline: InlineElement): InlineElement {\r\n        if (!inline || this.start.equalTo(this.end)) {\r\n            return null;\r\n        }\r\n\r\n        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon\r\n        let start = inline.getStartPosition();\r\n        let end = inline.getEndPosition();\r\n\r\n        if (start.isAfter(this.end) || this.start.isAfter(end)) {\r\n            return null;\r\n        }\r\n\r\n        let startPartial = false;\r\n        let endPartial = false;\r\n\r\n        if (this.start.isAfter(start)) {\r\n            start = this.start;\r\n            startPartial = true;\r\n        }\r\n\r\n        if (end.isAfter(this.end)) {\r\n            end = this.end;\r\n            endPartial = true;\r\n        }\r\n\r\n        return start.isAfter(end) || start.equalTo(end)\r\n            ? null\r\n            : startPartial || endPartial\r\n            ? new PartialInlineElement(inline, startPartial && start, endPartial && end)\r\n            : inline;\r\n    }\r\n}\r\n","import ContentTraverser from './ContentTraverser';\r\nimport createRange from '../selection/createRange';\r\nimport { InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n// White space matching regex. It matches following chars:\r\n// \\s: white space\r\n// \\u00A0: no-breaking white space\r\n// \\u200B: zero width space\r\n// \\u3000: full width space (which can come from JPN IME)\r\nconst WHITESPACE_REGEX = /[\\s\\u00A0\\u200B\\u3000]+([^\\s\\u00A0\\u200B\\u3000]*)$/i;\r\n\r\n/**\r\n * The class that helps search content around a position\r\n */\r\nexport default class PositionContentSearcher {\r\n    // The cached text before position that has been read so far\r\n    private text = '';\r\n\r\n    // The cached word before position\r\n    private word: string;\r\n\r\n    // The inline element before position\r\n    private inlineBefore: InlineElement;\r\n\r\n    // The inline element after position\r\n    private inlineAfter: InlineElement;\r\n\r\n    // The content traverser used to traverse backwards\r\n    private traverser: ContentTraverser;\r\n\r\n    // Backward parsing has completed\r\n    private traversingComplete: boolean;\r\n\r\n    // All inline elements before position that have been read so far\r\n    private inlineElements: InlineElement[] = [];\r\n\r\n    // First non-text inline before position\r\n    private nearestNonTextInlineElement: InlineElement;\r\n\r\n    /**\r\n     * Create a new CursorData instance\r\n     * @param rootNode Root node of the whole scope\r\n     * @param position Start position\r\n     */\r\n    constructor(private rootNode: Node, private position: NodePosition) {}\r\n\r\n    /**\r\n     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion\r\n     * between position and the white space is the word before position\r\n     * @returns The word before position\r\n     */\r\n    public getWordBefore(): string {\r\n        if (!this.word) {\r\n            this.traverse(() => this.word);\r\n        }\r\n\r\n        return this.word;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element before position\r\n     * @returns The inlineElement before position\r\n     */\r\n    public getInlineElementBefore(): InlineElement {\r\n        if (!this.inlineBefore) {\r\n            this.traverse(null);\r\n        }\r\n\r\n        return this.inlineBefore;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element after position\r\n     * @returns The inline element after position\r\n     */\r\n    public getInlineElementAfter(): InlineElement {\r\n        if (!this.inlineAfter) {\r\n            this.inlineAfter = ContentTraverser.createBlockTraverser(\r\n                this.rootNode,\r\n                this.position\r\n            ).currentInlineElement;\r\n        }\r\n\r\n        return this.inlineAfter;\r\n    }\r\n\r\n    /**\r\n     * Get X number of chars before position\r\n     * The actual returned chars may be less than what is requested.\r\n     * @param length The length of string user want to get, the string always ends at the position,\r\n     * so this length determins the start position of the string\r\n     * @returns The actual string we get as a sub string, or the whole string before position when\r\n     * there is not enough chars in the string\r\n     */\r\n    public getSubStringBefore(length: number): string {\r\n        if (this.text.length < length) {\r\n            this.traverse(() => this.text.length >= length);\r\n        }\r\n\r\n        return this.text.substr(Math.max(0, this.text.length - length));\r\n    }\r\n\r\n    /**\r\n     * Try to get a range matches the given text before the position\r\n     * @param text The text to match against\r\n     * @param exactMatch Whether it is an exact match\r\n     * @returns The range for the matched text, null if unable to find a match\r\n     */\r\n    public getRangeFromText(text: string, exactMatch: boolean): Range {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        let startPosition: NodePosition;\r\n        let endPosition: NodePosition;\r\n        let textIndex = text.length - 1;\r\n\r\n        this.forEachTextInlineElement(textInline => {\r\n            let nodeContent = textInline.getTextContent() || '';\r\n            let nodeIndex = nodeContent.length - 1;\r\n            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {\r\n                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {\r\n                    textIndex--;\r\n\r\n                    // on first time when end is matched, set the end of range\r\n                    if (!endPosition) {\r\n                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                    }\r\n                } else if (exactMatch || endPosition) {\r\n                    // Mismatch found when exact match or end already match, so return since matching failed\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // when textIndex == -1, we have a successful complete match\r\n            if (textIndex == -1) {\r\n                startPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return startPosition && endPosition && createRange(startPosition, endPosition);\r\n    }\r\n\r\n    /**\r\n     * Get text section before position till stop condition is met.\r\n     * This offers consumers to retrieve text section by section\r\n     * The section essentially is just an inline element which has Container element\r\n     * so that the consumer can remember it for anchoring popup or verification purpose\r\n     * when position moves out of context etc.\r\n     * @param stopFunc The callback stop function\r\n     */\r\n    public forEachTextInlineElement(callback: (textInlineElement: InlineElement) => any) {\r\n        // We cache all text sections read so far\r\n        // Every time when you ask for textSection, we start with the cached first\r\n        // and resort to further reading once we exhausted with the cache\r\n        if (!this.inlineElements.some(callback)) {\r\n            this.traverse(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get first non textual inline element before position\r\n     * @returns First non textutal inline element before position or null if no such element exists\r\n     */\r\n    public getNearestNonTextInlineElement(): InlineElement {\r\n        if (!this.nearestNonTextInlineElement) {\r\n            this.traverse(() => this.nearestNonTextInlineElement);\r\n        }\r\n\r\n        return this.nearestNonTextInlineElement;\r\n    }\r\n\r\n    /**\r\n     * Continue traversing backward till stop condition is met or begin of block is reached\r\n     */\r\n    private traverse(callback: (inlineElement: InlineElement) => any) {\r\n        this.traverser =\r\n            this.traverser || ContentTraverser.createBlockTraverser(this.rootNode, this.position);\r\n\r\n        if (!this.traverser || this.traversingComplete) {\r\n            return;\r\n        }\r\n\r\n        let previousInline = this.traverser.getPreviousInlineElement();\r\n        while (!this.traversingComplete) {\r\n            this.inlineBefore = this.inlineBefore || previousInline;\r\n\r\n            if (previousInline && previousInline.isTextualInlineElement()) {\r\n                let textContent = previousInline.getTextContent();\r\n\r\n                // build the word before position if it is not built yet\r\n                if (!this.word) {\r\n                    // Match on the white space, the portion after space is on the index of 1 of the matched result\r\n                    // (index at 0 is whole match result, index at 1 is the word)\r\n                    let matches = WHITESPACE_REGEX.exec(textContent);\r\n                    if (matches && matches.length == 2) {\r\n                        this.word = matches[1] + this.text;\r\n                    }\r\n                }\r\n\r\n                this.text = textContent + this.text;\r\n                this.inlineElements.push(previousInline);\r\n\r\n                // Check if stop condition is met\r\n                if (callback && callback(previousInline)) {\r\n                    break;\r\n                }\r\n            } else {\r\n                this.nearestNonTextInlineElement = previousInline;\r\n                this.traversingComplete = true;\r\n                if (!this.word) {\r\n                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor\r\n                    this.word = this.text;\r\n                }\r\n\r\n                // When a non-textual inline element, or null is seen, we consider parsing complete\r\n                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.\r\n                // we have aaa @someone bbb<position>, and we want to read the text before @someone\r\n                break;\r\n            }\r\n\r\n            previousInline = this.traverser.getPreviousInlineElement();\r\n        }\r\n    }\r\n}\r\n","import { DefaultFormat } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Apply format to an HTML element\r\n * @param element The HTML element to apply format to\r\n * @param format The format to apply\r\n */\r\nexport default function applyFormat(element: HTMLElement, format: DefaultFormat, isDarkMode?: boolean) {\r\n    if (format) {\r\n        let elementStyle = element.style;\r\n        let { fontFamily, fontSize, textColor, textColors, backgroundColor, backgroundColors, bold, italic, underline } = format;\r\n\r\n        if (fontFamily) {\r\n            elementStyle.fontFamily = fontFamily;\r\n        }\r\n        if (fontSize) {\r\n            elementStyle.fontSize = fontSize;\r\n        }\r\n        if (textColor || textColors) {\r\n            if (textColors && isDarkMode) {\r\n                element.dataset.ogsc = textColors.lightModeColor;\r\n            }\r\n            elementStyle.color = textColor;\r\n        }\r\n        if (backgroundColor || backgroundColors) {\r\n            if (backgroundColors && isDarkMode) {\r\n                element.dataset.ogsb = backgroundColors.lightModeColor;\r\n            }\r\n            elementStyle.backgroundColor = backgroundColor;\r\n        }\r\n        if (bold) {\r\n            elementStyle.fontWeight = 'bold';\r\n        }\r\n        if (italic) {\r\n            elementStyle.fontStyle = 'italic';\r\n        }\r\n        if (underline) {\r\n            elementStyle.textDecoration = 'underline';\r\n        }\r\n    }\r\n}\r\n","import toArray from './toArray';\r\nimport { Browser } from './Browser';\r\nimport { ClipboardItems } from 'roosterjs-editor-types';\r\n\r\n// HTML header to indicate where is the HTML content started from.\r\n// Sample header:\r\n// Version:0.9\r\n// StartHTML:71\r\n// EndHTML:170\r\n// StartFragment:140\r\n// EndFragment:160\r\n// StartSelection:140\r\n// EndSelection:160\r\nconst CLIPBOARD_HTML_HEADER_REGEX = /^Version:[0-9\\.]+\\s+StartHTML:\\s*([0-9]+)\\s+EndHTML:\\s*([0-9]+)\\s+/i;\r\n\r\ninterface WindowForIE extends Window {\r\n    clipboardData: DataTransfer;\r\n}\r\n\r\n/**\r\n * Extract a Clipboard event\r\n * @param event The paste event\r\n * @param callback Callback function when data is ready\r\n * @param fallbackHtmlRetriever If direct HTML retriving is not support (e.g. Internet Explorer), as a fallback,\r\n * using this helper function to retrieve HTML content\r\n * @returns An object with the following properties:\r\n *  types: Available types from the clipboard event\r\n *  text: Plain text from the clipboard event\r\n *  image: Image file from the clipboard event\r\n *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.\r\n *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is\r\n *   not supported by browser.\r\n */\r\nexport default function extractClipboardEvent(\r\n    event: ClipboardEvent,\r\n    callback: (items: ClipboardItems) => void\r\n) {\r\n    let dataTransfer =\r\n        event.clipboardData ||\r\n        (<WindowForIE>(<Node>event.target).ownerDocument.defaultView).clipboardData;\r\n    let result: ClipboardItems = {\r\n        types: dataTransfer.types ? toArray(dataTransfer.types) : [],\r\n        text: dataTransfer.getData('text'),\r\n        image: getImage(dataTransfer),\r\n        html: undefined,\r\n    };\r\n\r\n    if (event.clipboardData && event.clipboardData.items) {\r\n        event.preventDefault();\r\n        let items = event.clipboardData.items;\r\n        for (let i = 0; i < items.length; i++) {\r\n            let item = items[i];\r\n            if (item.type && item.type.indexOf('text/html') == 0) {\r\n                item.getAsString(html => {\r\n                    result.html = Browser.isEdge ? workaroundForEdge(html) : html;\r\n                    callback(result);\r\n                });\r\n                return;\r\n            }\r\n        }\r\n\r\n        // No HTML content found, set html to null\r\n        result.html = null;\r\n    }\r\n\r\n    callback(result);\r\n}\r\n\r\nfunction getImage(dataTransfer: DataTransfer): File {\r\n    // Chrome, Firefox, Edge support dataTransfer.items\r\n    let fileCount = dataTransfer.items ? dataTransfer.items.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let item = dataTransfer.items[i];\r\n        if (item.type && item.type.indexOf('image/') == 0) {\r\n            return item.getAsFile();\r\n        }\r\n    }\r\n    // IE, Safari support dataTransfer.files\r\n    fileCount = dataTransfer.files ? dataTransfer.files.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let file = dataTransfer.files.item(i);\r\n        if (file.type && file.type.indexOf('image/') == 0) {\r\n            return file;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Edge sometimes doesn't remove the headers, which cause we paste more things then expected.\r\n * So we need to remove it in our code\r\n * @param html The HTML string got from clipboard\r\n */\r\nfunction workaroundForEdge(html: string) {\r\n    let headerValues = CLIPBOARD_HTML_HEADER_REGEX.exec(html);\r\n\r\n    if (headerValues && headerValues.length == 3) {\r\n        let start = parseInt(headerValues[1]);\r\n        let end = parseInt(headerValues[2]);\r\n        if (start > 0 && end > start) {\r\n            html = html.substring(start, end);\r\n        }\r\n    }\r\n\r\n    return html;\r\n}\r\n","import { DocumentCommand, PendableFormatState } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Names of Pendable formats\r\n */\r\nexport type PendableFormatNames = keyof PendableFormatState;\r\n\r\n/**\r\n * A map from pendable format name to document command\r\n */\r\nexport const PendableFormatCommandMap: { [key in PendableFormatNames]: DocumentCommand } = {\r\n    /**\r\n     * Bold\r\n     */\r\n    isBold: DocumentCommand.Bold,\r\n\r\n    /**\r\n     * Italic\r\n     */\r\n    isItalic: DocumentCommand.Italic,\r\n\r\n    /**\r\n     * Underline\r\n     */\r\n    isUnderline: DocumentCommand.Underline,\r\n\r\n    /**\r\n     * StrikeThrough\r\n     */\r\n    isStrikeThrough: DocumentCommand.StrikeThrough,\r\n\r\n    /**\r\n     * Subscript\r\n     */\r\n    isSubscript: DocumentCommand.Subscript,\r\n\r\n    /**\r\n     * Superscript\r\n     */\r\n    isSuperscript: DocumentCommand.Superscript,\r\n};\r\n\r\n/**\r\n * Get Pendable Format State at cursor.\r\n * @param document The HTML Document to get format state from\r\n * @returns A PendableFormatState object which contains the values of pendable format states\r\n */\r\nexport default function getPendableFormatState(document: Document): PendableFormatState {\r\n    let keys = Object.keys(PendableFormatCommandMap) as PendableFormatNames[];\r\n\r\n    return keys.reduce(\r\n        (state, key) => {\r\n            state[key] = document.queryCommandState(PendableFormatCommandMap[key]);\r\n            return state;\r\n        },\r\n        <PendableFormatState>{}\r\n    );\r\n}\r\n","import { getComputedStyle } from './getComputedStyles';\n\n/**\n * Check if the given element is using right-to-left layout\n * @param element An HTML element to check\n * @returns True if the given element is using right-to-left layout, otherwise false\n */\nexport default function isRtl(element: HTMLElement): boolean {\n    return getComputedStyle(element, 'direction') == 'rtl';\n}\n","import { LinkData } from 'roosterjs-editor-types';\r\n\r\ninterface LinkMatchRule {\r\n    match: RegExp;\r\n    except?: RegExp;\r\n    normalizeUrl?: (url: string) => string;\r\n}\r\n\r\n// http exclude matching regex\r\n// invalid URL example (in paricular on IE and Edge):\r\n// - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception\r\n// - http://www.bing.com%1, %1 is invalid\r\n// - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)\r\n// - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)\r\n// All above % cases if they're after ? (question mark) is then considered valid again\r\n// Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception\r\n// - http://www.bing.com@name, @name before ? (question mark) is considered invalid\r\n// - http://www.bing.com/@name, is valid sine it is after / (forward slash)\r\n// - http://www.bing.com?@name, is also valid sinve it is after ? (question mark)\r\n// The regex below is essentially a break down of:\r\n// ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%\r\n// ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1\r\n// ^[^?]+%00 => to exclude URL like www.bing.com%00\r\n// ^[^?]+%$ => to exclude URL like www.bing.com%\r\n// ^https?:\\/\\/[^?\\/]+@ => to exclude URL like http://www.bing.com@name\r\n// ^www\\.[^?\\/]+@ => to exclude URL like www.bing.com@name\r\n// , => to exclude url like www.bing,,com\r\nconst httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\\/\\/[^?\\/]+@|^www\\.[^?\\/]+@/i;\r\n\r\n// via https://tools.ietf.org/html/rfc1035 Page 7\r\nconst labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexes below so don't bother including A-Z\r\nconst domainNameRegEx = `(?:${labelRegEx}\\\\.)*${labelRegEx}`;\r\nconst domainPortRegEx = `${domainNameRegEx}(?:\\\\:[0-9]+)?`;\r\nconst domainPortWithUrlRegEx = `${domainPortRegEx}(?:[\\\\/\\\\?]\\\\S*)?`;\r\n\r\nconst linkMatchRules: { [schema: string]: LinkMatchRule } = {\r\n    http: {\r\n        match: new RegExp(\r\n            `^(?:microsoft-edge:)?http:\\\\/\\\\/${domainPortWithUrlRegEx}|www\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        except: httpExcludeRegEx,\r\n        normalizeUrl: url =>\r\n            new RegExp('^(?:microsoft-edge:)?http:\\\\/\\\\/', 'i').test(url) ? url : 'http://' + url,\r\n    },\r\n    https: {\r\n        match: new RegExp(`^(?:microsoft-edge:)?https:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i'),\r\n        except: httpExcludeRegEx,\r\n    },\r\n    mailto: { match: new RegExp('^mailto:\\\\S+@\\\\S+\\\\.\\\\S+', 'i') },\r\n    notes: { match: new RegExp('^notes:\\\\/\\\\/\\\\S+', 'i') },\r\n    file: { match: new RegExp('^file:\\\\/\\\\/\\\\/?\\\\S+', 'i') },\r\n    unc: { match: new RegExp('^\\\\\\\\\\\\\\\\\\\\S+', 'i') },\r\n    ftp: {\r\n        match: new RegExp(\r\n            `^ftp:\\\\/\\\\/${domainPortWithUrlRegEx}|ftp\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        normalizeUrl: url => (new RegExp('^ftp:\\\\/\\\\/', 'i').test(url) ? url : 'ftp://' + url),\r\n    },\r\n    news: { match: new RegExp(`^news:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    telnet: { match: new RegExp(`^telnet:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    gopher: { match: new RegExp(`^gopher:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i') },\r\n    wais: { match: new RegExp(`^wais:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n};\r\n\r\n/**\r\n * Try to match a given string with link match rules, return matched link\r\n * @param url Input url to match\r\n * @param option Link match option, exact or partial. If it is exact match, we need\r\n * to check the length of matched link and url\r\n * @param rules Optional link match rules, if not passed, only the default link match\r\n * rules will be applied\r\n * @returns The matched link data, or null if no match found.\r\n * The link data includes an original url and a normalized url\r\n */\r\nexport default function matchLink(url: string): LinkData {\r\n    if (url) {\r\n        for (let schema of Object.keys(linkMatchRules)) {\r\n            let rule = linkMatchRules[schema];\r\n            let matches = url.match(rule.match);\r\n            if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {\r\n                return {\r\n                    scheme: schema,\r\n                    originalUrl: url,\r\n                    normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import changeElementTag from './changeElementTag';\r\nimport contains from './contains';\r\nimport createRange from '../selection/createRange';\r\nimport findClosestElementAncestor from './findClosestElementAncestor';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport isNodeEmpty from './isNodeEmpty';\r\nimport isPositionAtBeginningOf from '../selection/isPositionAtBeginningOf';\r\nimport isVoidHtmlElement from './isVoidHtmlElement';\r\nimport Position from '../selection/Position';\r\nimport queryElements from './queryElements';\r\nimport splitTextNode from './splitTextNode';\r\nimport toArray from './toArray';\r\nimport unwrap from './unwrap';\r\nimport VTable from '../table/VTable';\r\nimport wrap from './wrap';\r\nimport { NodePosition, NodeType, PositionType, QueryScope } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst adjustSteps: ((\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n) => NodePosition)[] = [handleHyperLink, handleStructuredNode, handleParagraph, handleVoidElement];\r\n\r\n/**\r\n * Adjust the given position and return a better position (if any) or the given position\r\n * which will be the best one for inserting the given node.\r\n * @param root Root node of the scope\r\n * @param nodeToInsert The node about to be inserted\r\n * @param position The original position to insert the node\r\n */\r\nexport default function adjustNodeInsertPosition(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    adjustSteps.forEach(handler => {\r\n        position = handler(root, nodeToInsert, position);\r\n    });\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleHyperLink(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    let blockElement = getBlockElementAtNode(root, position.node);\r\n\r\n    if (blockElement) {\r\n        // Find the first <A> tag within current block which covers current selection\r\n        // If there are more than one nested, let's handle the first one only since that is not a common scenario.\r\n        let anchor = queryElements(\r\n            root,\r\n            'a[href]',\r\n            null /*forEachCallback*/,\r\n            QueryScope.OnSelection,\r\n            createRange(position)\r\n        ).filter(a => blockElement.contains(a))[0];\r\n\r\n        // If this is about to insert node to an empty A tag, clear the A tag and reset position\r\n        if (anchor && isNodeEmpty(anchor)) {\r\n            position = new Position(anchor, PositionType.Before);\r\n            safeRemove(anchor);\r\n            anchor = null;\r\n        }\r\n\r\n        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag\r\n        // otherwise we will have nested A tags which is a wrong HTML structure\r\n        if (\r\n            anchor &&\r\n            (<ParentNode>(<any>nodeToInsert)).querySelector &&\r\n            (<ParentNode>(<any>nodeToInsert)).querySelector('a[href]')\r\n        ) {\r\n            let normalizedPosition = position.normalize();\r\n            let parentNode = normalizedPosition.node.parentNode;\r\n            let nextNode =\r\n                normalizedPosition.node.nodeType == NodeType.Text\r\n                    ? splitTextNode(\r\n                          <Text>normalizedPosition.node,\r\n                          normalizedPosition.offset,\r\n                          false /*returnFirstPart*/\r\n                      )\r\n                    : normalizedPosition.isAtEnd\r\n                    ? normalizedPosition.node.nextSibling\r\n                    : normalizedPosition.node;\r\n            let splitter: Node = root.ownerDocument.createTextNode('');\r\n            parentNode.insertBefore(splitter, nextNode);\r\n\r\n            while (contains(anchor, splitter)) {\r\n                splitter = splitBalancedNodeRange(splitter);\r\n            }\r\n\r\n            position = new Position(splitter, PositionType.Before);\r\n            safeRemove(splitter);\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleStructuredNode(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    let rootNodeToInsert = nodeToInsert;\r\n\r\n    if (rootNodeToInsert.nodeType == NodeType.DocumentFragment) {\r\n        let rootNodes = toArray(rootNodeToInsert.childNodes).filter(n => getTagOfNode(n) != 'BR');\r\n        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;\r\n    }\r\n\r\n    let tag = getTagOfNode(rootNodeToInsert);\r\n    let hasBrNextToRoot = tag && getTagOfNode(rootNodeToInsert.nextSibling) == 'BR';\r\n    let listItem = findClosestElementAncestor(position.node, root, 'LI');\r\n    let listNode = listItem && findClosestElementAncestor(listItem, root, 'OL,UL');\r\n    let tdNode = findClosestElementAncestor(position.node, root, 'TD,TH');\r\n    let trNode = tdNode && findClosestElementAncestor(tdNode, root, 'TR');\r\n\r\n    if (tag == 'LI') {\r\n        tag = listNode ? getTagOfNode(listNode) : 'UL';\r\n        rootNodeToInsert = wrap(rootNodeToInsert, tag);\r\n    }\r\n\r\n    if ((tag == 'OL' || tag == 'UL') && getTagOfNode(rootNodeToInsert.firstChild) == 'LI') {\r\n        let shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;\r\n\r\n        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {\r\n            safeRemove(rootNodeToInsert.nextSibling);\r\n        }\r\n\r\n        if (shouldInsertListAsText) {\r\n            unwrap(rootNodeToInsert.firstChild);\r\n            unwrap(rootNodeToInsert);\r\n        } else if (getTagOfNode(listNode) == tag) {\r\n            unwrap(rootNodeToInsert);\r\n            position = new Position(\r\n                listItem,\r\n                isPositionAtBeginningOf(position, listItem)\r\n                    ? PositionType.Before\r\n                    : PositionType.After\r\n            );\r\n        }\r\n    } else if (tag == 'TABLE' && trNode) {\r\n        // When inserting a table into a table, if these tables have the same column count, and\r\n        // current position is at beginning of a row, then merge these two tables\r\n        let newTable = new VTable(<HTMLTableElement>rootNodeToInsert);\r\n        let currentTable = new VTable(<HTMLTableCellElement>tdNode);\r\n        if (\r\n            currentTable.col == 0 &&\r\n            tdNode == currentTable.getCell(currentTable.row, 0).td &&\r\n            newTable.cells[0] &&\r\n            newTable.cells[0].length == currentTable.cells[0].length &&\r\n            isPositionAtBeginningOf(position, tdNode)\r\n        ) {\r\n            if (\r\n                getTagOfNode(rootNodeToInsert.firstChild) == 'TBODY' &&\r\n                !rootNodeToInsert.firstChild.nextSibling\r\n            ) {\r\n                unwrap(rootNodeToInsert.firstChild);\r\n            }\r\n            unwrap(rootNodeToInsert);\r\n            position = new Position(trNode, PositionType.After);\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleParagraph(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    if (getTagOfNode(position.node) == 'P') {\r\n        // Insert into a P tag may cause issues when the inserted content contains any block element.\r\n        // Change P tag to DIV to make sure it works well\r\n        let pos = position.normalize();\r\n        let div = changeElementTag(<HTMLElement>position.node, 'div');\r\n        if (pos.node != div) {\r\n            position = pos;\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleVoidElement(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    if (isVoidHtmlElement(position.node)) {\r\n        position = new Position(\r\n            position.node,\r\n            position.isAtEnd ? PositionType.After : PositionType.Before\r\n        );\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction safeRemove(node: Node) {\r\n    if (node && node.parentNode) {\r\n        node.parentNode.removeChild(node);\r\n    }\r\n}\r\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\r\n\r\n/**\r\n * get block element's text content.\r\n * @param rootNode Root node that the get the textContent of.\r\n * @returns text content of given text content.\r\n */\r\nexport default function getTextContent(rootNode: Node): string {\r\n    const traverser = ContentTraverser.createBodyTraverser(rootNode);\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let textContent: string[] = [];\r\n\r\n    while (block) {\r\n        textContent.push(block.getTextContent());\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    return textContent.join('\\n');\r\n}\r\n","import createRange from './createRange';\r\nimport { NodePosition, NodeType, Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get bounding rect of this position\r\n * @param position The positioin to get rect from\r\n */\r\nexport default function getPositionRect(position: NodePosition): Rect {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n\r\n    let range = createRange(position);\r\n\r\n    // 1) try to get rect using range.getBoundingClientRect()\r\n    let rect = range.getBoundingClientRect && normalizeRect(range.getBoundingClientRect());\r\n\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 2) try to get rect using range.getClientRects\r\n    position = position.normalize();\r\n    const rects = range.getClientRects && range.getClientRects();\r\n    rect = rects && rects.length == 1 && normalizeRect(rects[0]);\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 3) if node is text node, try inserting a SPAN and get the rect of SPAN for others\r\n    if (position.node.nodeType == NodeType.Text) {\r\n        const document = position.node.ownerDocument;\r\n        let span = document.createElement('SPAN');\r\n        span.innerHTML = '\\u200b';\r\n        range = createRange(position);\r\n        range.insertNode(span);\r\n        rect = span.getBoundingClientRect && normalizeRect(span.getBoundingClientRect());\r\n        span.parentNode.removeChild(span);\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    // 4) try getBoundingClientRect on element\r\n    let element = position.element;\r\n    if (element && element.getBoundingClientRect) {\r\n        rect = normalizeRect(element.getBoundingClientRect());\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction normalizeRect(clientRect: ClientRect): Rect {\r\n    // A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p\r\n    // We validate that and only return a rect when the passed in ClientRect is valid\r\n    let { left, right, top, bottom } = clientRect || <ClientRect>{};\r\n    return left + right + top + bottom > 0\r\n        ? {\r\n              left: Math.round(left),\r\n              right: Math.round(right),\r\n              top: Math.round(top),\r\n              bottom: Math.round(bottom),\r\n          }\r\n        : null;\r\n}\r\n","import getSelectionPath from './getSelectionPath';\n\n/**\n * Get inner Html of a root node with a selection path which can be used for restore selection.\n * The result string can be used by setHtmlWithSelectionPath() to restore the HTML and selection.\n * @param rootNode Root node to get inner Html from\n * @param range The range of selection. If pass null, no selection path will be added\n * @returns Inner HTML of the root node, followed by HTML comment contains selection path if the given range is valid\n */\nexport default function getHtmlWithSelectionPath(rootNode: HTMLElement, range: Range): string {\n    if (!rootNode) {\n        return '';\n    }\n\n    const content = rootNode.innerHTML;\n    const selectionPath = range && getSelectionPath(rootNode, range);\n\n    return selectionPath ? `${content}<!--${JSON.stringify(selectionPath)}-->` : content;\n}\n","import createRange from './createRange';\r\nimport { NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Restore inner Html of a root element from given html string. If the string contains selection path,\r\n * remove the selection path and return a range represented by the path\r\n * @param root The root element\r\n * @param html The html to restore\r\n * @returns A selection range if the html contains a valid selection path, otherwise null\r\n */\r\nexport default function setHtmlWithSelectionPath(rootNode: HTMLElement, html: string): Range {\r\n    rootNode.innerHTML = html || '';\r\n    let path: SelectionPath = null;\r\n    let pathComment = rootNode.lastChild;\r\n\r\n    try {\r\n        path =\r\n            pathComment &&\r\n            pathComment.nodeType == NodeType.Comment &&\r\n            (JSON.parse(pathComment.nodeValue) as SelectionPath);\r\n        if (path && path.end && path.end.length > 0 && path.start && path.start.length > 0) {\r\n            rootNode.removeChild(pathComment);\r\n        } else {\r\n            path = null;\r\n        }\r\n    } catch {}\r\n\r\n    return path && createRange(rootNode, path.start, path.end);\r\n}\r\n","import clearProceedingSnapshots from './clearProceedingSnapshots';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Add a new snapshot to the given snapshots data structure\r\n * @param snapshots The snapshots data structure to add new snapshot into\r\n * @param snapshot The snapshot to add\r\n */\r\nexport default function addSnapshot(snapshots: Snapshots, snapshot: string) {\r\n    if (snapshots.currentIndex < 0 || snapshot != snapshots.snapshots[snapshots.currentIndex]) {\r\n        clearProceedingSnapshots(snapshots);\r\n        snapshots.snapshots.push(snapshot);\r\n        snapshots.currentIndex++;\r\n        snapshots.totalSize += snapshot.length;\r\n\r\n        let removeCount = 0;\r\n        while (\r\n            removeCount < snapshots.snapshots.length &&\r\n            snapshots.totalSize > snapshots.maxSize\r\n        ) {\r\n            snapshots.totalSize -= snapshots.snapshots[removeCount].length;\r\n            removeCount++;\r\n        }\r\n\r\n        if (removeCount > 0) {\r\n            snapshots.snapshots.splice(0, removeCount);\r\n            snapshots.currentIndex -= removeCount;\r\n        }\r\n    }\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Move current snapshot with the given step if can move this step. Otherwise no action and return null\r\n * @param snapshots The snapshots data structure to move\r\n * @param step The step to move\r\n * @returns If can move with the given step, returns the snapshot after move, otherwise null\r\n */\r\nexport default function moveCurrentSnapsnot(snapshots: Snapshots, step: number): string {\r\n    if (canMoveCurrentSnapshot(snapshots, step)) {\r\n        snapshots.currentIndex += step;\r\n        return snapshots.snapshots[snapshots.currentIndex];\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create initial snapshots\r\n * @param maxSize max size of all snapshots\r\n */\r\nexport default function createSnapshots(maxSize: number): Snapshots {\r\n    return {\r\n        snapshots: [],\r\n        totalSize: 0,\r\n        currentIndex: -1,\r\n        maxSize,\r\n    };\r\n}\r\n","import adjustBrowserBehavior from './adjustBrowserBehavior';\r\nimport createEditorCore from './createEditorCore';\r\nimport EditorCore from '../interfaces/EditorCore';\r\nimport EditorOptions from '../interfaces/EditorOptions';\r\nimport getColorNormalizedContent from '../darkMode/getColorNormalizedContent';\r\nimport mapPluginEvents from './mapPluginEvents';\r\nimport { calculateDefaultFormat } from '../coreAPI/calculateDefaultFormat';\r\nimport { convertContentToDarkMode } from '../darkMode/convertContentToDarkMode';\r\nimport { GenericContentEditFeature } from '../interfaces/ContentEditFeature';\r\nimport { isRange } from 'roosterjs-cross-window';\r\nimport {\r\n    BlockElement,\r\n    ChangeSource,\r\n    ContentPosition,\r\n    DarkModeOptions,\r\n    DefaultFormat,\r\n    InlineElement,\r\n    InsertOption,\r\n    NodePosition,\r\n    PluginEvent,\r\n    PluginEventData,\r\n    PluginEventFromType,\r\n    PluginEventType,\r\n    PositionType,\r\n    QueryScope,\r\n    Rect,\r\n    SelectionPath,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodes,\r\n    contains,\r\n    ContentTraverser,\r\n    createRange,\r\n    findClosestElementAncestor,\r\n    fromHtml,\r\n    getBlockElementAtNode,\r\n    getHtmlWithSelectionPath,\r\n    getSelectionPath,\r\n    getTextContent,\r\n    getInlineElementAtNode,\r\n    getPositionRect,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    Position,\r\n    PositionContentSearcher,\r\n    queryElements,\r\n    setHtmlWithSelectionPath,\r\n    wrap,\r\n    isPositionAtBeginningOf,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * RoosterJs core editor class\r\n */\r\nexport default class Editor {\r\n    private core: EditorCore;\r\n    private eventDisposers: (() => void)[];\r\n    private contenteditableChanged: boolean;\r\n\r\n    //#region Lifecycle\r\n\r\n    /**\r\n     * Creates an instance of Editor\r\n     * @param contentDiv The DIV HTML element which will be the container element of editor\r\n     * @param options An optional options object to customize the editor\r\n     */\r\n    constructor(contentDiv: HTMLDivElement, options: EditorOptions = {}) {\r\n        // 1. Make sure all parameters are valid\r\n        if (getTagOfNode(contentDiv) != 'DIV') {\r\n            throw new Error('contentDiv must be an HTML DIV element');\r\n        }\r\n\r\n        // 2. Store options values to local variables\r\n        this.core = createEditorCore(contentDiv, options);\r\n\r\n        // 3. Initialize plugins\r\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\r\n\r\n        // 4. Ensure initial content and its format\r\n        this.setContent(\r\n            options.initialContent || contentDiv.innerHTML || '',\r\n            false /*triggerContentChangedEvent*/\r\n        );\r\n\r\n        // 5. Create event handler to bind DOM events\r\n        this.eventDisposers = mapPluginEvents(this.core);\r\n\r\n        // 6. Add additional content edit features to the editor if specified\r\n        if (options.additionalEditFeatures) {\r\n            options.additionalEditFeatures.forEach(feature => this.addContentEditFeature(feature));\r\n        }\r\n\r\n        // 7. Make the container editable and set its selection styles\r\n        if (!options.omitContentEditableAttributeChanges && !contentDiv.isContentEditable) {\r\n            contentDiv.setAttribute('contenteditable', 'true');\r\n            let styles = contentDiv.style;\r\n            styles.userSelect = styles.msUserSelect = styles.webkitUserSelect = 'text';\r\n            this.contenteditableChanged = true;\r\n        }\r\n\r\n        // 8. Do proper change for browsers to disable some browser-specified behaviors.\r\n        adjustBrowserBehavior(this.core.document);\r\n\r\n        // 9. Let plugins know that we are ready\r\n        this.triggerPluginEvent(PluginEventType.EditorReady, {}, true /*broadcast*/);\r\n\r\n        // 10. Before give editor to user, make sure there is at least one DIV element to accept typing\r\n        this.core.corePlugins.typeInContainer.ensureTypeInElement(\r\n            this.getFocusedPosition() || new Position(contentDiv, PositionType.Begin)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Dispose this editor, dispose all plugins and custom data\r\n     */\r\n    public dispose(): void {\r\n        this.triggerPluginEvent(PluginEventType.BeforeDispose, {}, true /*broadcast*/);\r\n\r\n        this.core.plugins.forEach(plugin => plugin.dispose());\r\n        this.eventDisposers.forEach(disposer => disposer());\r\n        this.eventDisposers = null;\r\n\r\n        for (let key of Object.keys(this.core.customData)) {\r\n            let data = this.core.customData[key];\r\n            if (data && data.disposer) {\r\n                data.disposer(data.value);\r\n            }\r\n            delete this.core.customData[key];\r\n        }\r\n\r\n        if (this.contenteditableChanged) {\r\n            let styles = this.core.contentDiv.style;\r\n            styles.userSelect = styles.msUserSelect = styles.webkitUserSelect = '';\r\n            this.core.contentDiv.removeAttribute('contenteditable');\r\n        }\r\n\r\n        this.core = null;\r\n    }\r\n\r\n    /**\r\n     * Get whether this editor is disposed\r\n     * @returns True if editor is disposed, otherwise false\r\n     */\r\n    public isDisposed(): boolean {\r\n        return !this.core;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Node API\r\n\r\n    /**\r\n     * Insert node into editor\r\n     * @param node The node to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     * @returns true if node is inserted. Otherwise false\r\n     */\r\n    public insertNode(node: Node, option?: InsertOption): boolean {\r\n        // DocumentFragment type nodes become empty after they're inserted.\r\n        // Therefore, we get the list of nodes to transform prior to their insertion.\r\n        const darkModeOptions = this.getDarkModeOptions();\r\n        const darkModeTransform = this.isDarkMode()\r\n            ? convertContentToDarkMode(\r\n                  node,\r\n                  darkModeOptions && darkModeOptions.onExternalContentTransform\r\n                      ? darkModeOptions.onExternalContentTransform\r\n                      : undefined\r\n              )\r\n            : null;\r\n\r\n        const result = node ? this.core.api.insertNode(this.core, node, option) : false;\r\n\r\n        if (result && darkModeTransform) {\r\n            darkModeTransform();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Delete a node from editor content\r\n     * @param node The node to delete\r\n     * @returns true if node is deleted. Otherwise false\r\n     */\r\n    public deleteNode(node: Node): boolean {\r\n        // Only remove the node when it falls within editor\r\n        if (node && this.contains(node)) {\r\n            node.parentNode.removeChild(node);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Replace a node in editor content with another node\r\n     * @param existingNode The existing node to be replaced\r\n     * @param new node to replace to\r\n     * @returns true if node is replaced. Otherwise false\r\n     */\r\n    public replaceNode(existingNode: Node, toNode: Node): boolean {\r\n        // Only replace the node when it falls within editor\r\n        if (existingNode && toNode && this.contains(existingNode)) {\r\n            existingNode.parentNode.replaceChild(toNode, existingNode);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get InlineElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The InlineElement result\r\n     */\r\n    public getInlineElementAtNode(node: Node): InlineElement {\r\n        return getInlineElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    /**\r\n     * Get BlockElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The BlockElement result\r\n     */\r\n    public getBlockElementAtNode(node: Node): BlockElement {\r\n        return getBlockElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    /**\r\n     * Check if the node falls in the editor content\r\n     * @param node The node to check\r\n     * @returns True if the given node is in editor content, otherwise false\r\n     */\r\n    public contains(node: Node): boolean;\r\n\r\n    /**\r\n     * Check if the range falls in the editor content\r\n     * @param range The range to check\r\n     * @returns True if the given range is in editor content, otherwise false\r\n     */\r\n    public contains(range: Range): boolean;\r\n\r\n    public contains(arg: Node | Range): boolean {\r\n        return contains(this.core.contentDiv, <Node>arg);\r\n    }\r\n\r\n    /**\r\n     * Query HTML elements in editor by tag name\r\n     * @param tag Tag name of the element to query\r\n     * @param forEachCallback An optional callback to be invoked on each element in query result\r\n     * @returns HTML Element array of the query result\r\n     */\r\n    public queryElements<T extends keyof HTMLElementTagNameMap>(\r\n        tag: T,\r\n        forEachCallback?: (node: HTMLElementTagNameMap[T]) => any\r\n    ): HTMLElementTagNameMap[T][];\r\n\r\n    /**\r\n     * Query HTML elements in editor by a selector string\r\n     * @param selector Selector string to query\r\n     * @param forEachCallback An optional callback to be invoked on each node in query result\r\n     * @returns HTML Element array of the query result\r\n     */\r\n    public queryElements<T extends HTMLElement = HTMLElement>(\r\n        selector: string,\r\n        forEachCallback?: (node: T) => any\r\n    ): T[];\r\n\r\n    /**\r\n     * Query HTML elements with the given scope by tag name\r\n     * @param tag Tag name of the element to query\r\n     * @param scope The scope of the query, default value is QueryScope.Body\r\n     * @param forEachCallback An optional callback to be invoked on each element in query result\r\n     * @returns HTML Element list of the query result\r\n     */\r\n    public queryElements<T extends keyof HTMLElementTagNameMap>(\r\n        tag: T,\r\n        scope: QueryScope,\r\n        forEachCallback?: (node: HTMLElementTagNameMap[T]) => any\r\n    ): HTMLElementTagNameMap[T][];\r\n\r\n    /**\r\n     * Query HTML elements with the given scope by a selector string\r\n     * @param selector Selector string to query\r\n     * @param scope The scope of the query, default value is QueryScope.Body\r\n     * @param forEachCallback An optional callback to be invoked on each element in query result\r\n     * @returns HTML Element array of the query result\r\n     */\r\n    public queryElements<T extends HTMLElement = HTMLElement>(\r\n        selector: string,\r\n        scope: QueryScope,\r\n        forEachCallback?: (node: T) => any\r\n    ): T[];\r\n\r\n    public queryElements(\r\n        selector: string,\r\n        scopeOrCallback: QueryScope | ((node: Node) => any) = QueryScope.Body,\r\n        callback?: (node: Node) => any\r\n    ) {\r\n        let scope = scopeOrCallback instanceof Function ? QueryScope.Body : scopeOrCallback;\r\n        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;\r\n\r\n        let range = scope == QueryScope.Body ? null : this.getSelectionRange();\r\n        return queryElements(this.core.contentDiv, selector, callback, scope, range);\r\n    }\r\n\r\n    /**\r\n     * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n     * split parent nodes if necessary\r\n     * @param start The start node\r\n     * @param end The end node\r\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n     * and the returned nodes will be all nodes from start trhough end after splitting\r\n     * False to disallow split parent\r\n     * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n     * otherwise just return start and end\r\n     */\r\n    public collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[] {\r\n        return collapseNodes(this.core.contentDiv, start, end, canSplitParent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Content API\r\n\r\n    /**\r\n     * Check whether the editor contains any visible content\r\n     * @param trim Whether trime the content string before check. Default is false\r\n     * @returns True if there's no visible content, otherwise false\r\n     */\r\n    public isEmpty(trim?: boolean): boolean {\r\n        return isNodeEmpty(this.core.contentDiv, trim);\r\n    }\r\n\r\n    /**\r\n     * Get current editor content as HTML string\r\n     * @param triggerExtractContentEvent Whether trigger ExtractContent event to all plugins\r\n     * before return. Use this parameter to remove any temporary content added by plugins.\r\n     * @param includeSelectionMarker Set to true if need include selection marker inside the content.\r\n     * When restore this content, editor will set the selection to the position marked by these markers\r\n     * @returns HTML string representing current editor content\r\n     */\r\n    public getContent(\r\n        triggerExtractContentEvent: boolean = true,\r\n        includeSelectionMarker: boolean = false\r\n    ): string {\r\n        let content = getHtmlWithSelectionPath(\r\n            this.core.contentDiv,\r\n            includeSelectionMarker && this.getSelectionRange()\r\n        );\r\n\r\n        if (triggerExtractContentEvent) {\r\n            content = this.triggerPluginEvent(\r\n                PluginEventType.ExtractContent,\r\n                { content },\r\n                true /*broadcast*/\r\n            ).content;\r\n        }\r\n\r\n        if (this.core.inDarkMode) {\r\n            content = getColorNormalizedContent(content);\r\n        }\r\n\r\n        return content;\r\n    }\r\n\r\n    /**\r\n     * Get plain text content inside editor\r\n     * @returns The text content inside editor\r\n     */\r\n    public getTextContent(): string {\r\n        return getTextContent(this.core.contentDiv);\r\n    }\r\n\r\n    /**\r\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\r\n     * @param content HTML content to set in\r\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\r\n     */\r\n    public setContent(content: string, triggerContentChangedEvent: boolean = true) {\r\n        let contentDiv = this.core.contentDiv;\r\n        let contentChanged = false;\r\n        if (contentDiv.innerHTML != content) {\r\n            let range = setHtmlWithSelectionPath(contentDiv, content);\r\n            this.select(range);\r\n            contentChanged = true;\r\n        }\r\n\r\n        // Convert content even if it hasn't changed.\r\n        if (this.core.inDarkMode) {\r\n            const darkModeOptions = this.getDarkModeOptions();\r\n            const convertFunction = convertContentToDarkMode(\r\n                contentDiv,\r\n                darkModeOptions && darkModeOptions.onExternalContentTransform\r\n                    ? darkModeOptions.onExternalContentTransform\r\n                    : undefined,\r\n                true /* skipRootElement */\r\n            );\r\n            if (convertFunction) {\r\n                convertFunction();\r\n                contentChanged = true;\r\n            }\r\n        }\r\n\r\n        if (triggerContentChangedEvent && contentChanged) {\r\n            this.triggerContentChangedEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert HTML content into editor\r\n     * @param HTML content to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     */\r\n    public insertContent(content: string, option?: InsertOption) {\r\n        if (content) {\r\n            let allNodes = fromHtml(content, this.core.document);\r\n\r\n            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with\r\n            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped\r\n            // separately to show up on its own line\r\n            if (option && option.insertOnNewLine && allNodes.length > 1) {\r\n                allNodes = [wrap(allNodes)];\r\n            }\r\n\r\n            let fragment = this.core.document.createDocumentFragment();\r\n            allNodes.forEach(node => fragment.appendChild(node));\r\n\r\n            this.insertNode(fragment, option);\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Focus and Selection\r\n\r\n    /**\r\n     * Get current selection range from Editor.\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @returns current selection range, or null if editor never got focus before\r\n     */\r\n    public getSelectionRange(): Range {\r\n        return this.core.api.getSelectionRange(this.core, true /*tryGetFromCache*/);\r\n    }\r\n\r\n    /**\r\n     * Get current selection in a serializable format\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @returns current selection path, or null if editor never got focus before\r\n     */\r\n    public getSelectionPath(): SelectionPath {\r\n        const range = this.getSelectionRange();\r\n        return range && getSelectionPath(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Check if focus is in editor now\r\n     * @returns true if focus is in editor, otherwise false\r\n     */\r\n    public hasFocus(): boolean {\r\n        return this.core.api.hasFocus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\r\n     */\r\n    public focus() {\r\n        this.core.api.focus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Select content by range\r\n     * @param range The range to select\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(range: Range): boolean;\r\n\r\n    /**\r\n     * Select content by Position and collapse to this position\r\n     * @param position The position to select\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(position: NodePosition): boolean;\r\n\r\n    /**\r\n     * Select content by a start and end position\r\n     * @param start The start position to select\r\n     * @param end The end position to select, if this is the same with start, the selection will be collapsed\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(start: NodePosition, end: NodePosition): boolean;\r\n\r\n    /**\r\n     * Select content by node\r\n     * @param node The node to select\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(node: Node): boolean;\r\n\r\n    /**\r\n     * Select content by node and offset, and collapse to this position\r\n     * @param node The node to select\r\n     * @param offset The offset of node to select, can be a number or value of PositionType\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(node: Node, offset: number | PositionType): boolean;\r\n\r\n    /**\r\n     * Select content by start and end nodes and offsets\r\n     * @param startNode The node to select start from\r\n     * @param startOffset The offset to select start from\r\n     * @param endNode The node to select end to\r\n     * @param endOffset The offset to select end to\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(\r\n        startNode: Node,\r\n        startOffset: number | PositionType,\r\n        endNode: Node,\r\n        endOffset: number | PositionType\r\n    ): boolean;\r\n\r\n    /**\r\n     * Select content by selection path\r\n     * @param path A selection path object\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(path: SelectionPath): boolean;\r\n\r\n    public select(arg1: any, arg2?: any, arg3?: any, arg4?: any): boolean {\r\n        let range = !arg1\r\n            ? null\r\n            : isRange(arg1)\r\n            ? arg1\r\n            : Array.isArray(arg1.start) && Array.isArray(arg1.end)\r\n            ? createRange(\r\n                  this.core.contentDiv,\r\n                  (<SelectionPath>arg1).start,\r\n                  (<SelectionPath>arg1).end\r\n              )\r\n            : createRange(arg1, arg2, arg3, arg4);\r\n        return this.contains(range) && this.core.api.selectRange(this.core, range);\r\n    }\r\n\r\n    /**\r\n     * Get current selection\r\n     * @return current selection object\r\n     */\r\n    public getSelection(): Selection {\r\n        return this.core.document.defaultView.getSelection();\r\n    }\r\n\r\n    /**\r\n     * Save the current selection in editor so that when focus again, the selection can be restored\r\n     */\r\n    public saveSelectionRange() {\r\n        this.core.cachedSelectionRange = this.core.api.getSelectionRange(\r\n            this.core,\r\n            false /*tryGetFromCache*/\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Restore the saved selection range and clear it\r\n     */\r\n    public restoreSavedRange() {\r\n        this.select(this.core.cachedSelectionRange);\r\n        this.core.cachedSelectionRange = null;\r\n    }\r\n\r\n    /**\r\n     * Get current focused position. Return null if editor doesn't have focus at this time.\r\n     */\r\n    public getFocusedPosition(): NodePosition {\r\n        let sel = this.getSelection();\r\n        if (this.contains(sel && sel.focusNode)) {\r\n            return new Position(sel.focusNode, sel.focusOffset);\r\n        }\r\n\r\n        let range = this.getSelectionRange();\r\n        if (range) {\r\n            return Position.getStart(range);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get a rect representing the location of the cursor.\r\n     * @returns a Rect object representing cursor location\r\n     */\r\n    public getCursorRect(): Rect {\r\n        let position = this.getFocusedPosition();\r\n        return position && getPositionRect(position);\r\n    }\r\n\r\n    /**\r\n     * Get an HTML element from current cursor position.\r\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\r\n     * or its parent node (if current node is a Text node).\r\n     * When expectedTags is specified, return value is the first anscestor of current node which has\r\n     * one of the expected tags.\r\n     * If no element found within editor by the given tag, return null.\r\n     * @param selector Optional, an HTML selector to find HTML element with.\r\n     * @param startFrom Start search from this node. If not specified, start from current focused position\r\n     */\r\n    public getElementAtCursor(selector?: string, startFrom?: Node): HTMLElement {\r\n        if (!startFrom) {\r\n            let position = this.getFocusedPosition();\r\n            startFrom = position && position.node;\r\n        }\r\n        return startFrom && findClosestElementAncestor(startFrom, this.core.contentDiv, selector);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is at beginning of the editor.\r\n     * This will return true if all nodes between the beginning of target node and the position are empty.\r\n     * @param position The position to check\r\n     * @returns True if position is at beginning of the editor, otherwise false\r\n     */\r\n    public isPositionAtBeginning(position: NodePosition): boolean {\r\n        return isPositionAtBeginningOf(position, this.core.contentDiv);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region EVENT API\r\n\r\n    /**\r\n     * Add a custom DOM event handler to handle events not handled by roosterjs.\r\n     * Caller need to take the responsibility to dispose the handler properly\r\n     * @param eventName DOM event name to handle\r\n     * @param handler Handler callback\r\n     * @returns A dispose function. Call the function to dispose this event handler\r\n     */\r\n    public addDomEventHandler(eventName: string, handler: (event: UIEvent) => void): () => void;\r\n\r\n    /**\r\n     * Add a bunch of custom DOM event handler to handle events not handled by roosterjs.\r\n     * Caller need to take the responsibility to dispose the handler properly\r\n     * @param handlerMap A event name => event handler map\r\n     * @returns A dispose function. Call the function to dispose all event handlers added by this function\r\n     */\r\n    public addDomEventHandler(handlerMap: {\r\n        [eventName: string]: (event: UIEvent) => void;\r\n    }): () => void;\r\n\r\n    public addDomEventHandler(\r\n        nameOrMap:\r\n            | string\r\n            | {\r\n                  [eventName: string]: (event: UIEvent) => void;\r\n              },\r\n        handler?: (event: UIEvent) => void\r\n    ): () => void {\r\n        if (nameOrMap instanceof Object) {\r\n            let handlers = Object.keys(nameOrMap)\r\n                .map(\r\n                    eventName =>\r\n                        nameOrMap[eventName] &&\r\n                        this.core.api.attachDomEvent(\r\n                            this.core,\r\n                            eventName,\r\n                            null /*pluginEventType*/,\r\n                            nameOrMap[eventName]\r\n                        )\r\n                )\r\n                .filter(x => x);\r\n            return () => handlers.forEach(handler => handler());\r\n        } else {\r\n            return this.core.api.attachDomEvent(\r\n                this.core,\r\n                nameOrMap,\r\n                null /*pluginEventType*/,\r\n                handler\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger an event to be dispatched to all plugins\r\n     * @param eventType Type of the event\r\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\r\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\r\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\r\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\r\n     * the result of this function provides a chance to read the modified result\r\n     */\r\n    public triggerPluginEvent<T extends PluginEventType>(\r\n        eventType: T,\r\n        data: PluginEventData<T>,\r\n        broadcast?: boolean\r\n    ): PluginEventFromType<T> {\r\n        let event = ({\r\n            eventType,\r\n            ...data,\r\n        } as any) as PluginEventFromType<T>;\r\n        this.core.api.triggerEvent(this.core, event, broadcast);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use triggerPluginEvent instead\r\n     */\r\n    public triggerEvent(pluginEvent: PluginEvent, broadcast: boolean = true) {\r\n        this.core.api.triggerEvent(this.core, pluginEvent, broadcast);\r\n    }\r\n\r\n    /**\r\n     * Trigger a ContentChangedEvent\r\n     * @param source Source of this event, by default is 'SetContent'\r\n     * @param data additional data for this event\r\n     */\r\n    public triggerContentChangedEvent(\r\n        source: ChangeSource | string = ChangeSource.SetContent,\r\n        data?: any\r\n    ) {\r\n        this.triggerPluginEvent(PluginEventType.ContentChanged, {\r\n            source,\r\n            data,\r\n        });\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Undo API\r\n\r\n    /**\r\n     * Undo last edit operation\r\n     */\r\n    public undo() {\r\n        this.focus();\r\n        this.core.corePlugins.undo.undo();\r\n    }\r\n\r\n    /**\r\n     * Redo next edit operation\r\n     */\r\n    public redo() {\r\n        this.focus();\r\n        this.core.corePlugins.undo.redo();\r\n    }\r\n\r\n    /**\r\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\r\n     * ContentChangedEvent with given change source.\r\n     * If this function is called nested, undo snapshot will only be added in the outside one\r\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\r\n     * the data field in ContentChangedEvent if changeSource is not null.\r\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\r\n     * a ContentChangedEvent will be fired with change source equal to this value\r\n     */\r\n    public addUndoSnapshot(\r\n        callback?: (start: NodePosition, end: NodePosition, snapshotBeforeCallback: string) => any,\r\n        changeSource?: ChangeSource | string\r\n    ) {\r\n        this.core.api.editWithUndo(this.core, callback, changeSource);\r\n    }\r\n\r\n    /**\r\n     * Perform an auto complete action in the callback, save a snapsnot of content before the action,\r\n     * and trigger ContentChangedEvent with the change source if specified\r\n     * @param callback The auto complete callback, return value will be used as data field of ContentChangedEvent\r\n     * @param changeSource Chagne source of ContentChangedEvent. If not passed, no ContentChangedEvent will be  triggered\r\n     */\r\n    public performAutoComplete(callback: () => any, changeSource?: ChangeSource | string) {\r\n        this.core.corePlugins.edit.performAutoComplete(callback, changeSource);\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available undo snapshot\r\n     */\r\n    public canUndo(): boolean {\r\n        return this.core.corePlugins.undo.canUndo();\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available redo snapshot\r\n     */\r\n    public canRedo(): boolean {\r\n        return this.core.corePlugins.undo.canRedo();\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Misc\r\n\r\n    /**\r\n     * Get document which contains this editor\r\n     * @returns The HTML document which contains this editor\r\n     */\r\n    public getDocument(): Document {\r\n        return this.core.document;\r\n    }\r\n\r\n    /**\r\n     * Get the scroll container of the editor\r\n     */\r\n    public getScrollContainer(): HTMLElement {\r\n        return this.core.scrollContainer;\r\n    }\r\n\r\n    /**\r\n     * Get custom data related to this editor\r\n     * @param key Key of the custom data\r\n     * @param getter Getter function. If custom data for the given key doesn't exist,\r\n     * call this function to get one and store it if it is specified. Otherwise return undefined\r\n     * @param disposer An optional disposer function to dispose this custom data when\r\n     * dispose editor.\r\n     */\r\n    public getCustomData<T>(key: string, getter?: () => T, disposer?: (value: T) => void): T {\r\n        return this.core.api.getCustomData(this.core, key, getter, disposer);\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME(): boolean {\r\n        return this.core.corePlugins.domEvent.isInIME();\r\n    }\r\n\r\n    /**\r\n     * Get default format of this editor\r\n     * @returns Default format object of this editor\r\n     */\r\n    public getDefaultFormat(): DefaultFormat {\r\n        return this.core.defaultFormat;\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for the whole editor\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    public getBodyTraverser(startNode?: Node): ContentTraverser {\r\n        return ContentTraverser.createBodyTraverser(this.core.contentDiv, startNode);\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current selection\r\n     */\r\n    public getSelectionTraverser(): ContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range &&\r\n            ContentTraverser.createSelectionTraverser(\r\n                this.core.contentDiv,\r\n                this.getSelectionRange()\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current block element start from specified position\r\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\r\n     */\r\n    public getBlockTraverser(\r\n        startFrom: ContentPosition = ContentPosition.SelectionStart\r\n    ): ContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range && ContentTraverser.createBlockTraverser(this.core.contentDiv, range, startFrom)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a text traverser of current selection\r\n     */\r\n    public getContentSearcherOfCursor(): PositionContentSearcher {\r\n        let range = this.getSelectionRange();\r\n        return range && new PositionContentSearcher(this.core.contentDiv, Position.getStart(range));\r\n    }\r\n\r\n    /**\r\n     * Run a callback function asynchronously\r\n     * @param callback The callback function to run\r\n     */\r\n    public runAsync(callback: () => void) {\r\n        let win = this.core.contentDiv.ownerDocument.defaultView || window;\r\n        win.requestAnimationFrame(() => {\r\n            if (!this.isDisposed() && callback) {\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     * @param value Value of the attribute\r\n     */\r\n    public setEditorDomAttribute(name: string, value: string) {\r\n        if (value === null) {\r\n            this.core.contentDiv.removeAttribute(name);\r\n        } else {\r\n            this.core.contentDiv.setAttribute(name, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     */\r\n    public getEditorDomAttribute(name: string): string {\r\n        return this.core.contentDiv.getAttribute(name);\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature. This is mostly called from ContentEdit plugin\r\n     * @param feature The feature to add\r\n     */\r\n    public addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        this.core.corePlugins.edit.addFeature(feature);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Dark mode APIs\r\n\r\n    /**\r\n     * Set the dark mode state and transforms the content to match the new state.\r\n     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\r\n     */\r\n    public setDarkModeState(nextDarkMode?: boolean) {\r\n        if (this.isDarkMode() == nextDarkMode) {\r\n            return;\r\n        }\r\n\r\n        const currentContent = this.getContent(\r\n            undefined /* triggerContentChangedEvent */,\r\n            true /* getSelectionMarker */\r\n        );\r\n\r\n        this.core.inDarkMode = nextDarkMode;\r\n        this.core.defaultFormat = calculateDefaultFormat(\r\n            this.core.contentDiv,\r\n            this.core.defaultFormat,\r\n            this.core.inDarkMode\r\n        );\r\n\r\n        this.setContent(currentContent);\r\n        this.triggerPluginEvent(PluginEventType.DarkModeChanged, {\r\n            changedToDarkMode: nextDarkMode,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if the editor is in dark mode\r\n     * @returns True if the editor is in dark mode, otherwise false\r\n     */\r\n    public isDarkMode(): boolean {\r\n        return this.core.inDarkMode;\r\n    }\r\n\r\n    /**\r\n     * Returns the dark mode options set on the editor\r\n     * @returns A DarkModeOptions object\r\n     */\r\n    public getDarkModeOptions(): DarkModeOptions {\r\n        return this.core.darkModeOptions;\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\n\r\nconst COMMANDS: {\r\n    [command: string]: any;\r\n} = Browser.isFirefox\r\n    ? {\r\n          /**\r\n           * Disable these object resizing for firefox since other browsers don't have these behaviors\r\n           */\r\n          [DocumentCommand.EnableObjectResizing]: false,\r\n          [DocumentCommand.EnableInlineTableEditing]: false,\r\n      }\r\n    : Browser.isIE\r\n    ? {\r\n          /**\r\n           * Change the default paragraph separater to DIV. This is mainly for IE since its default setting is P\r\n           */\r\n          [DocumentCommand.DefaultParagraphSeparator]: 'div',\r\n\r\n          /**\r\n           * Disable auto link feature in IE since we have our own implementation\r\n           */\r\n          [DocumentCommand.AutoUrlDetect]: false,\r\n      }\r\n    : {};\r\n\r\n/**\r\n * Execute document command to adjust browser default behavior\r\n */\r\nexport default function adjustBrowserBehavior(document: HTMLDocument) {\r\n    Object.keys(COMMANDS).forEach(command => {\r\n        // Catch any possible exception since this should not block the initialization of editor\r\n        try {\r\n            document.execCommand(command, false, COMMANDS[command]);\r\n        } catch {}\r\n    });\r\n}\r\n","import CopyPlugin from '../corePlugins/CopyPlugin';\r\nimport DOMEventPlugin from '../corePlugins/DOMEventPlugin';\r\nimport EditorCore, { CoreApiMap, CorePlugins } from '../interfaces/EditorCore';\r\nimport EditorOptions from '../interfaces/EditorOptions';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport EditPlugin from '../corePlugins/EditPlugin';\r\nimport FirefoxTypeAfterLink from '../corePlugins/FirefoxTypeAfterLink';\r\nimport MouseUpPlugin from '../corePlugins/MouseUpPlugin';\r\nimport TypeInContainerPlugin from '../corePlugins/TypeInContainerPlugin';\r\nimport Undo from '../undo/Undo';\r\nimport { attachDomEvent } from '../coreAPI/attachDomEvent';\r\nimport { Browser } from 'roosterjs-editor-dom';\r\nimport { calculateDefaultFormat } from '../coreAPI/calculateDefaultFormat';\r\nimport { CustomDataMap } from '../interfaces/CustomData';\r\nimport { editWithUndo } from '../coreAPI/editWithUndo';\r\nimport { focus } from '../coreAPI/focus';\r\nimport { getCustomData } from '../coreAPI/getCustomData';\r\nimport { getSelectionRange } from '../coreAPI/getSelectionRange';\r\nimport { hasFocus } from '../coreAPI/hasFocus';\r\nimport { insertNode } from '../coreAPI/insertNode';\r\nimport { select, selectRange } from '../coreAPI/selectRange';\r\nimport { triggerEvent } from '../coreAPI/triggerEvent';\r\n\r\n/**\r\n * Create core object for editor\r\n * @param contentDiv The DIV element used for editor\r\n * @param options Options to create an editor\r\n */\r\nexport default function createEditorCore(\r\n    contentDiv: HTMLDivElement,\r\n    options: EditorOptions\r\n): EditorCore {\r\n    let corePlugins: CorePlugins = {\r\n        undo: options.undo || new Undo(),\r\n        edit: new EditPlugin(),\r\n        typeInContainer: new TypeInContainerPlugin(),\r\n        mouseUp: new MouseUpPlugin(),\r\n        domEvent: new DOMEventPlugin(options.disableRestoreSelectionOnFocus),\r\n        firefoxTypeAfterLink: new FirefoxTypeAfterLink(),\r\n        copyPlugin: !Browser.isIE && new CopyPlugin(),\r\n    };\r\n    let allPlugins = buildPluginList(corePlugins, options.plugins);\r\n    let eventHandlerPlugins = allPlugins.filter(\r\n        plugin => plugin.onPluginEvent || plugin.willHandleEventExclusively\r\n    );\r\n    return {\r\n        contentDiv,\r\n        scrollContainer: options.scrollContainer || contentDiv,\r\n        document: contentDiv.ownerDocument,\r\n        defaultFormat: calculateDefaultFormat(\r\n            contentDiv,\r\n            options.defaultFormat,\r\n            options.inDarkMode\r\n        ),\r\n        corePlugins,\r\n        currentUndoSnapshot: null,\r\n        customData: createCustomData(options.customData || {}),\r\n        cachedSelectionRange: null,\r\n        plugins: allPlugins,\r\n        eventHandlerPlugins: eventHandlerPlugins,\r\n        api: createCoreApiMap(options.coreApiOverride),\r\n        defaultApi: createCoreApiMap(),\r\n        inDarkMode: options.inDarkMode,\r\n        darkModeOptions: options.darkModeOptions,\r\n    };\r\n}\r\n\r\nfunction buildPluginList(corePlugins: CorePlugins, plugins: EditorPlugin[]): EditorPlugin[] {\r\n    return [\r\n        corePlugins.typeInContainer,\r\n        corePlugins.edit,\r\n        corePlugins.mouseUp,\r\n        ...(plugins || []),\r\n        corePlugins.firefoxTypeAfterLink,\r\n        corePlugins.undo,\r\n        corePlugins.domEvent,\r\n        corePlugins.copyPlugin,\r\n    ].filter(plugin => !!plugin);\r\n}\r\n\r\nfunction createCoreApiMap(map?: Partial<CoreApiMap>): CoreApiMap {\r\n    map = map || {};\r\n    return {\r\n        attachDomEvent: map.attachDomEvent || attachDomEvent,\r\n        editWithUndo: map.editWithUndo || editWithUndo,\r\n        focus: map.focus || focus,\r\n        getCustomData: map.getCustomData || getCustomData,\r\n        getSelectionRange: map.getSelectionRange || getSelectionRange,\r\n        hasFocus: map.hasFocus || hasFocus,\r\n        insertNode: map.insertNode || insertNode,\r\n        select: map.select || select,\r\n        selectRange: map.selectRange || selectRange,\r\n        triggerEvent: map.triggerEvent || triggerEvent,\r\n    };\r\n}\r\n\r\nfunction createCustomData(initValue: { [key: string]: any }): CustomDataMap {\r\n    return Object.keys(initValue).reduce(\r\n        (result, key) => {\r\n            result[key] = {\r\n                value: initValue[key],\r\n            };\r\n            return result;\r\n        },\r\n        <CustomDataMap>{}\r\n    );\r\n}\r\n","import UndoSnapshotsService from '../interfaces/UndoSnapshotsService';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\nimport {\r\n    addSnapshot,\r\n    canMoveCurrentSnapshot,\r\n    moveCurrentSnapsnot,\r\n    clearProceedingSnapshots,\r\n    createSnapshots,\r\n} from 'roosterjs-editor-dom';\r\n\r\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\r\n// to keep size under limit. This is kept at 10MB\r\nconst MAXSIZELIMIT = 1e7;\r\n\r\n/**\r\n * A class to help manage undo snapshots\r\n */\r\nexport default class UndoSnapshots implements UndoSnapshotsService {\r\n    private snapshots: Snapshots;\r\n\r\n    constructor(public readonly maxSize: number = MAXSIZELIMIT) {\r\n        this.snapshots = createSnapshots(maxSize);\r\n    }\r\n\r\n    /**\r\n     * Check whether can move current undo snapshot with the given step\r\n     * @param step The step to check, can be positive, negative or 0\r\n     * @returns True if can move current snapshot with the given step, otherwise false\r\n     */\r\n    public canMove(delta: number): boolean {\r\n        return canMoveCurrentSnapshot(this.snapshots, delta);\r\n    }\r\n\r\n    /**\r\n     * Move current snapshot with the given step if can move this step. Otherwise no action and return null\r\n     * @param step The step to move\r\n     * @returns If can move with the given step, returns the snapshot after move, otherwise null\r\n     */\r\n    public move(delta: number): string {\r\n        return moveCurrentSnapsnot(this.snapshots, delta);\r\n    }\r\n\r\n    /**\r\n     * Add a new undo snapshot\r\n     * @param snapshot The snapshot to add\r\n     */\r\n    public addSnapshot(snapshot: string) {\r\n        addSnapshot(this.snapshots, snapshot);\r\n    }\r\n\r\n    /**\r\n     * Clear all undo snapshots after the current one\r\n     */\r\n    public clearRedo() {\r\n        clearProceedingSnapshots(this.snapshots);\r\n    }\r\n}\r\n","import EditorCore, { AttachDomEvent } from '../interfaces/EditorCore';\r\nimport isCharacterValue from '../eventApi/isCharacterValue';\r\nimport { PluginDomEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Attach a DOM event to the editor content DIV\r\n * @param core The EditorCore object\r\n * @param eventName The DOM event name\r\n * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered\r\n * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event\r\n */\r\nexport const attachDomEvent: AttachDomEvent = (\r\n    core: EditorCore,\r\n    eventName: string,\r\n    pluginEventType?: PluginEventType,\r\n    beforeDispatch?: (event: UIEvent) => void\r\n) => {\r\n    let onEvent = (event: UIEvent) => {\r\n        // Stop propagation of a printable keyboard event (a keyboard event which is caused by printable char input).\r\n        // This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\r\n        // event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\r\n        // So if we missed some case here it is still acceptable.\r\n        if (\r\n            (isKeyboardEvent(event) && isCharacterValue(event)) ||\r\n            pluginEventType == PluginEventType.Input\r\n        ) {\r\n            event.stopPropagation();\r\n        }\r\n\r\n        if (beforeDispatch) {\r\n            beforeDispatch(event);\r\n        }\r\n        if (pluginEventType != null) {\r\n            core.api.triggerEvent(\r\n                core,\r\n                <PluginDomEvent>{\r\n                    eventType: pluginEventType,\r\n                    rawEvent: event,\r\n                },\r\n                false /*broadcast*/\r\n            );\r\n        }\r\n    };\r\n    core.contentDiv.addEventListener(eventName, onEvent);\r\n    return () => {\r\n        core.contentDiv.removeEventListener(eventName, onEvent);\r\n    };\r\n};\r\n\r\nfunction isKeyboardEvent(e: UIEvent): e is KeyboardEvent {\r\n    return e.type == 'keydown' || e.type == 'keypress' || e.type == 'keyup';\r\n}\r\n","import EditorCore, { EditWithUndo } from '../interfaces/EditorCore';\r\nimport { Position } from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    ContentChangedEvent,\r\n    NodePosition,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.\r\n * Undo snapshot will not be added if this call is nested inside another editWithUndo() call.\r\n * @param core The EditorCore object\r\n * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.\r\n * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent\r\n */\r\nexport const editWithUndo: EditWithUndo = (\r\n    core: EditorCore,\r\n    callback: (start: NodePosition, end: NodePosition, snapshotBeforeCallback: string) => any,\r\n    changeSource: ChangeSource | string\r\n) => {\r\n    let isNested = core.currentUndoSnapshot !== null;\r\n    let data: any;\r\n\r\n    if (!isNested) {\r\n        core.currentUndoSnapshot = core.corePlugins.undo.addUndoSnapshot();\r\n    }\r\n\r\n    try {\r\n        if (callback) {\r\n            let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\r\n            data = callback(\r\n                range && Position.getStart(range).normalize(),\r\n                range && Position.getEnd(range).normalize(),\r\n                core.currentUndoSnapshot\r\n            );\r\n\r\n            if (!isNested) {\r\n                core.corePlugins.undo.addUndoSnapshot();\r\n            }\r\n        }\r\n    } finally {\r\n        if (!isNested) {\r\n            core.currentUndoSnapshot = null;\r\n        }\r\n    }\r\n\r\n    if (callback && changeSource) {\r\n        let event: ContentChangedEvent = {\r\n            eventType: PluginEventType.ContentChanged,\r\n            source: changeSource,\r\n            data: data,\r\n        };\r\n        core.api.triggerEvent(core, event, true /*broadcast*/);\r\n    }\r\n};\r\n","import EditorCore, { Focus } from '../interfaces/EditorCore';\r\nimport { createRange, getFirstLeafNode } from 'roosterjs-editor-dom';\r\nimport { PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Focus to editor. If there is a cached selection range, use it as current selection\r\n * @param core The EditorCore object\r\n */\r\nexport const focus: Focus = (core: EditorCore) => {\r\n    if (!core.api.hasFocus(core) || !core.api.getSelectionRange(core, false /*tryGetFromCache*/)) {\r\n        // Focus (document.activeElement indicates) and selection are mostly in sync, but could be out of sync in some extreme cases.\r\n        // i.e. if you programmatically change window selection to point to a non-focusable DOM element (i.e. tabindex=-1 etc.).\r\n        // On Chrome/Firefox, it does not change document.activeElement. On Edge/IE, it change document.activeElement to be body\r\n        // Although on Chrome/Firefox, document.activeElement points to editor, you cannot really type which we don't want (no cursor).\r\n        // So here we always do a live selection pull on DOM and make it point in Editor. The pitfall is, the cursor could be reset\r\n        // to very begin to of editor since we don't really have last saved selection (created on blur which does not fire in this case).\r\n        // It should be better than the case you cannot type\r\n        if (\r\n            !core.cachedSelectionRange ||\r\n            !core.api.selectRange(core, core.cachedSelectionRange, true /*skipSameRange*/)\r\n        ) {\r\n            let node = getFirstLeafNode(core.contentDiv) || core.contentDiv;\r\n            core.api.selectRange(\r\n                core,\r\n                createRange(node, PositionType.Begin),\r\n                true /*skipSameRange*/\r\n            );\r\n        }\r\n    }\r\n\r\n    // remember to clear cachedSelectionRange\r\n    core.cachedSelectionRange = null;\r\n\r\n    // This is more a fallback to ensure editor gets focus if it didn't manage to move focus to editor\r\n    if (!core.api.hasFocus(core)) {\r\n        core.contentDiv.focus();\r\n    }\r\n};\r\n","import EditorCore, { GetCustomData } from '../interfaces/EditorCore';\r\n\r\n/**\r\n * Get custom data related with this editor\r\n * @param core The EditorCore object\r\n * @param key Key of the custom data\r\n * @param getter Getter function. If custom data for the given key doesn't exist,\r\n * call this function to get one and store it if it is specified. Otherwise return undefined\r\n * @param disposer An optional disposer function to dispose this custom data when\r\n * dispose editor.\r\n */\r\nexport const getCustomData: GetCustomData = <T>(\r\n    core: EditorCore,\r\n    key: string,\r\n    getter: () => T,\r\n    disposer?: (value: T) => void\r\n): T => {\r\n    return (core.customData[key] = core.customData[key] || {\r\n        value: getter ? getter() : undefined,\r\n        disposer,\r\n    }).value as T;\r\n};\r\n","import EditorCore, { GetSelectionRange } from '../interfaces/EditorCore';\r\nimport { contains } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Get current or cached selection range\r\n * @param core The EditorCore object\r\n * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now\r\n * @returns A Range object of the selection range\r\n */\r\nexport const getSelectionRange: GetSelectionRange = (\r\n    core: EditorCore,\r\n    tryGetFromCache: boolean\r\n) => {\r\n    let result: Range = null;\r\n\r\n    if (!tryGetFromCache || core.api.hasFocus(core)) {\r\n        let selection = core.document.defaultView.getSelection();\r\n        if (selection && selection.rangeCount > 0) {\r\n            let range = selection.getRangeAt(0);\r\n            if (contains(core.contentDiv, range)) {\r\n                result = range;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!result && tryGetFromCache) {\r\n        result = core.cachedSelectionRange;\r\n    }\r\n\r\n    return result;\r\n};\r\n","import EditorCore, { InsertNode } from '../interfaces/EditorCore';\r\nimport {\r\n    ContentPosition,\r\n    InsertOption,\r\n    NodeType,\r\n    PositionType,\r\n    BlockElement,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    Position,\r\n    getBlockElementAtNode,\r\n    getFirstLastBlockElement,\r\n    isBlockElement,\r\n    isVoidHtmlElement,\r\n    wrap,\r\n    adjustNodeInsertPosition,\r\n    createRange,\r\n} from 'roosterjs-editor-dom';\r\n\r\nfunction getInitialRange(\r\n    core: EditorCore,\r\n    option: InsertOption\r\n): { range: Range; rangeToRestore: Range } {\r\n    // Selection start replaces based on the current selection.\r\n    // Range inserts based on a provided range.\r\n    // Both have the potential to use the current selection to restore cursor position\r\n    // So in both cases we need to store the selection state.\r\n    let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\r\n    let rangeToRestore = null;\r\n    if (option.position == ContentPosition.Range) {\r\n        rangeToRestore = range;\r\n        range = option.range;\r\n    } else if (range) {\r\n        rangeToRestore = range.cloneRange();\r\n    }\r\n\r\n    return { range, rangeToRestore };\r\n}\r\n\r\n/**\r\n * Insert a DOM node into editor content\r\n * @param core The EditorCore object. No op if null.\r\n * @param option An insert option object to specify how to insert the node\r\n */\r\nexport const insertNode: InsertNode = (core: EditorCore, node: Node, option: InsertOption) => {\r\n    option = option || {\r\n        position: ContentPosition.SelectionStart,\r\n        insertOnNewLine: false,\r\n        updateCursor: true,\r\n        replaceSelection: true,\r\n    };\r\n    let contentDiv = core.contentDiv;\r\n\r\n    if (option.updateCursor) {\r\n        core.api.focus(core);\r\n    }\r\n\r\n    switch (option.position) {\r\n        case ContentPosition.Begin:\r\n        case ContentPosition.End: {\r\n            let isBegin = option.position == ContentPosition.Begin;\r\n            let block = getFirstLastBlockElement(contentDiv, isBegin);\r\n            let insertedNode: Node;\r\n            if (block) {\r\n                let refNode = isBegin ? block.getStartNode() : block.getEndNode();\r\n                if (\r\n                    option.insertOnNewLine ||\r\n                    refNode.nodeType == NodeType.Text ||\r\n                    isVoidHtmlElement(refNode)\r\n                ) {\r\n                    // For insert on new line, or refNode is text or void html element (HR, BR etc.)\r\n                    // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\r\n                    // first and last node. Insert before 'hello' or after 'world', but still inside DIV\r\n                    insertedNode = refNode.parentNode.insertBefore(\r\n                        node,\r\n                        isBegin ? refNode : refNode.nextSibling\r\n                    );\r\n                } else {\r\n                    // if the refNode can have child, use appendChild (which is like to insert as first/last child)\r\n                    // i.e. <div>hello</div>, the content will be inserted before/after hello\r\n                    insertedNode = refNode.insertBefore(node, isBegin ? refNode.firstChild : null);\r\n                }\r\n            } else {\r\n                // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\r\n                insertedNode = contentDiv.appendChild(node);\r\n            }\r\n\r\n            // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\r\n            // add a DIV wrapping\r\n            if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\r\n                wrap(insertedNode);\r\n            }\r\n\r\n            break;\r\n        }\r\n        case ContentPosition.DomEnd:\r\n            // Use appendChild to insert the node at the end of the content div.\r\n            let insertedNode = contentDiv.appendChild(node);\r\n            // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\r\n            // add a DIV wrapping\r\n            if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\r\n                wrap(insertedNode);\r\n            }\r\n            break;\r\n        case ContentPosition.Range:\r\n        case ContentPosition.SelectionStart:\r\n            let { range, rangeToRestore } = getInitialRange(core, option);\r\n\r\n            if (!range) {\r\n                return;\r\n            }\r\n\r\n            // if to replace the selection and the selection is not collapsed, remove the the content at selection first\r\n            if (option.replaceSelection && !range.collapsed) {\r\n                range.deleteContents();\r\n            }\r\n\r\n            let pos = Position.getStart(range);\r\n            let blockElement: BlockElement;\r\n\r\n            if (\r\n                option.insertOnNewLine &&\r\n                (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))\r\n            ) {\r\n                pos = new Position(blockElement.getEndNode(), PositionType.After);\r\n            } else {\r\n                pos = adjustNodeInsertPosition(contentDiv, node, pos);\r\n            }\r\n\r\n            let nodeForCursor = node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\r\n            range = createRange(pos);\r\n            range.insertNode(node);\r\n            if (option.updateCursor && nodeForCursor) {\r\n                rangeToRestore = createRange(\r\n                    new Position(nodeForCursor, PositionType.After).normalize()\r\n                );\r\n            }\r\n            core.api.selectRange(core, rangeToRestore);\r\n\r\n            break;\r\n        case ContentPosition.Outside:\r\n            core.contentDiv.parentNode.insertBefore(node, contentDiv.nextSibling);\r\n            break;\r\n    }\r\n\r\n    return true;\r\n};\r\n","import EditorCore, { Select, SelectRange } from '../interfaces/EditorCore';\r\nimport { Browser, contains, createRange } from 'roosterjs-editor-dom';\r\nimport { hasFocus } from './hasFocus';\r\nimport { isRange } from 'roosterjs-cross-window';\r\n\r\n/**\r\n * Change the editor selection to the given range\r\n * @param core The EditorCore object\r\n * @param range The range to select\r\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection\r\n * in editor, otherwise it will always remove current selection ranage and set to the given one.\r\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\r\n */\r\nexport const selectRange: SelectRange = (\r\n    core: EditorCore,\r\n    range: Range,\r\n    skipSameRange?: boolean\r\n) => {\r\n    let selection: Selection;\r\n    let needAddRange = true;\r\n\r\n    if (\r\n        !contains(core.contentDiv, range) ||\r\n        !(selection = core.document.defaultView.getSelection())\r\n    ) {\r\n        return false;\r\n    }\r\n\r\n    if (selection.rangeCount > 0) {\r\n        // Workaround IE exception 800a025e\r\n        try {\r\n            let currentRange: Range;\r\n            // Do not remove/add range if current selection is the same with target range\r\n            // Without this check, execCommand() may fail in Edge since we changed the selection\r\n            if (\r\n                (skipSameRange || Browser.isEdge) &&\r\n                (currentRange = selection.rangeCount == 1 ? selection.getRangeAt(0) : null) &&\r\n                currentRange.startContainer == range.startContainer &&\r\n                currentRange.startOffset == range.startOffset &&\r\n                currentRange.endContainer == range.endContainer &&\r\n                currentRange.endOffset == range.endOffset\r\n            ) {\r\n                needAddRange = false;\r\n            } else {\r\n                selection.removeAllRanges();\r\n            }\r\n        } catch (e) {}\r\n    }\r\n\r\n    if (needAddRange) {\r\n        selection.addRange(range);\r\n    }\r\n\r\n    if (!hasFocus(core)) {\r\n        core.cachedSelectionRange = range;\r\n    }\r\n\r\n    if (range.collapsed) {\r\n        // If selected, and current selection is collapsed,\r\n        // need to restore pending format state if exists.\r\n        core.corePlugins.domEvent.restorePendingFormatState();\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n/**\r\n * @deprecated Only for compatibility with existing code, don't use ths function, use selectRange instead\r\n */\r\nexport const select: Select = (core: EditorCore, arg1: any, arg2?: any, arg3?: any, arg4?: any) => {\r\n    let range = isRange(arg1) ? arg1 : createRange(arg1, arg2, arg3, arg4);\r\n    return core.api.selectRange(core, range);\r\n};\r\n","import EditorCore, { TriggerEvent } from '../interfaces/EditorCore';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Trigger a plugin event\r\n * @param core The EditorCore object\r\n * @param pluginEvent The event object to trigger\r\n * @param broadcast Set to true to skip the shouldHandleEventExclusively check\r\n */\r\nexport const triggerEvent: TriggerEvent = (\r\n    core: EditorCore,\r\n    pluginEvent: PluginEvent,\r\n    broadcast: boolean\r\n) => {\r\n    if (\r\n        broadcast ||\r\n        !core.eventHandlerPlugins.some(plugin => handledExclusively(pluginEvent, plugin))\r\n    ) {\r\n        core.eventHandlerPlugins.forEach(plugin => {\r\n            if (plugin.onPluginEvent) {\r\n                plugin.onPluginEvent(pluginEvent);\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\nfunction handledExclusively(event: PluginEvent, plugin: EditorPlugin): boolean {\r\n    if (\r\n        plugin.onPluginEvent &&\r\n        plugin.willHandleEventExclusively &&\r\n        plugin.willHandleEventExclusively(event)\r\n    ) {\r\n        plugin.onPluginEvent(event);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\nimport { EditorCore } from '..';\r\nimport { PluginEventType } from 'roosterjs-editor-types';\r\n\r\nconst EVENT_MAPPING: { [domEvent: string]: PluginEventType } = {\r\n    keypress: PluginEventType.KeyPress,\r\n    keydown: PluginEventType.KeyDown,\r\n    keyup: PluginEventType.KeyUp,\r\n    mousedown: PluginEventType.MouseDown,\r\n    [Browser.isIE ? 'textinput' : 'input']: PluginEventType.Input,\r\n};\r\n\r\n/**\r\n * Map DOM events to editor plugin events\r\n * @param core The EditorCore object\r\n */\r\nexport default function mapPluginEvents(core: EditorCore): (() => void)[] {\r\n    return Object.keys(EVENT_MAPPING).map(pluginEvent =>\r\n        core.api.attachDomEvent(core, pluginEvent, EVENT_MAPPING[pluginEvent])\r\n    );\r\n}\r\n","import { isDocumentFragment, isHTMLElement } from 'roosterjs-cross-window';\r\n\r\n/**\r\n * Converter for dark mode that runs all child elements of a node through the content transform function.\r\n * @param node The node containing HTML elements to convert.\r\n * @param skipRootElement Optional parameter to skip the root element of the Node passed in, if applicable.\r\n */\r\nexport function convertContentToDarkMode(\r\n    node: Node,\r\n    onExternalContentTransform?: (element: Element) => void,\r\n    skipRootElement?: boolean\r\n): () => void {\r\n    let childElements: HTMLElement[] = [];\r\n\r\n    // Get a list of all the decendents of a node.\r\n    // querySelectorAll doesn't return a live list when called on an HTMLElement\r\n    // So we use getElementsByTagName instead for HTMLElement types.\r\n    if (isHTMLElement(node)) {\r\n        childElements = Array.prototype.slice.call(node.getElementsByTagName('*'));\r\n        if (!skipRootElement) {\r\n            childElements.unshift(node);\r\n        }\r\n    } else if (isDocumentFragment(node)) {\r\n        childElements = Array.prototype.slice.call(node.querySelectorAll('*'));\r\n    }\r\n\r\n    return childElements.length > 0\r\n        ? () => {\r\n              childElements.forEach(element => {\r\n                  if (onExternalContentTransform) {\r\n                      onExternalContentTransform(element);\r\n                  } else {\r\n                      element.style.color = null;\r\n                      element.style.backgroundColor = null;\r\n                  }\r\n              });\r\n          }\r\n        : null;\r\n}\r\n","import cacheGetEventData from './cacheGetEventData';\r\nimport Editor from '../editor/Editor';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\n\r\nconst CACHE_KEY_PREFIX = 'GET_ELEMENT_AT_CURSOR_';\r\n\r\n/**\r\n * Get an HTML element at cursor from event cache if it exists.\r\n * If an selector is specified, return the nearest ancestor of current node\r\n * which matches the selector, or null if no match found in editor.\r\n * @param editor The editor instance\r\n * @param event Event object to get cached object from\r\n * @param selector The expected selector. If null, return the element at cursor\r\n * @returns The element at cursor or the nearest ancestor with the tag name is specified\r\n */\r\nexport default function cacheGetElementAtCursor(\r\n    editor: Editor,\r\n    event: PluginEvent,\r\n    selector: string\r\n): HTMLElement {\r\n    return cacheGetEventData(event, CACHE_KEY_PREFIX + selector, () =>\r\n        editor.getElementAtCursor(selector)\r\n    );\r\n}\r\n","import ContentEditFeatures, { getDefaultContentEditFeatures } from './ContentEditFeatures';\r\nimport { AutoLink, UnlinkWhenBackspaceAfterLink } from './features/autoLinkFeatures';\r\nimport { DefaultShortcut } from './features/shortcutFeatures';\r\nimport { Editor, EditorPlugin, GenericContentEditFeature } from 'roosterjs-editor-core';\r\nimport { InsertLineBeforeStructuredNodeFeature } from './features/insertLineBeforeStructuredNodeFeature';\r\nimport { NoCycleCursorMove } from './features/noCycleCursorMove';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\nimport { TabInTable, UpDownInTable } from './features/tableFeatures';\r\n\r\nimport {\r\n    AutoBullet,\r\n    IndentWhenTab,\r\n    OutdentWhenShiftTab,\r\n    MergeInNewLine,\r\n    OutdentWhenBackOn1stEmptyLine,\r\n    OutdentWhenEnterOnEmptyLine,\r\n    getSmartOrderedList,\r\n} from './features/listFeatures';\r\nimport {\r\n    UnquoteWhenBackOnEmpty1stLine,\r\n    UnquoteWhenEnterOnEmptyLine,\r\n} from './features/quoteFeatures';\r\n\r\n/**\r\n * An editor plugin to handle content edit event.\r\n * The following cases are included:\r\n * 1. Auto increase/decrease indentation on Tab, Shift+tab\r\n * 2. Enter, Backspace on empty list item\r\n * 3. Enter, Backspace on empty blockquote line\r\n * 4. Auto bullet/numbering\r\n * 5. Auto link\r\n * 6. Tab in table\r\n * 7. Up/Down in table\r\n * 8. Manage list style\r\n */\r\nexport default class ContentEdit implements EditorPlugin {\r\n    private editor: Editor;\r\n\r\n    /**\r\n     * Create instance of ContentEdit plugin\r\n     * @param features An optional feature set to determine which features the plugin should provide\r\n     */\r\n    constructor(private featureSet?: ContentEditFeatures) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'ContentEdit';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    public initialize(editor: Editor): void {\r\n        this.editor = editor;\r\n        this.getFilteredFeatures().forEach(feature => this.editor.addContentEditFeature(feature));\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose(): void {\r\n        this.editor = null;\r\n    }\r\n\r\n    private getFilteredFeatures(): GenericContentEditFeature<PluginEvent>[] {\r\n        let featureSet = this.featureSet || getDefaultContentEditFeatures();\r\n        let allFeatures: {\r\n            [key in keyof Partial<ContentEditFeatures>]: GenericContentEditFeature<PluginEvent>;\r\n        } = {\r\n            indentWhenTab: IndentWhenTab,\r\n            outdentWhenShiftTab: OutdentWhenShiftTab,\r\n            outdentWhenBackspaceOnEmptyFirstLine: OutdentWhenBackOn1stEmptyLine,\r\n            outdentWhenEnterOnEmptyLine: OutdentWhenEnterOnEmptyLine,\r\n            mergeInNewLineWhenBackspaceOnFirstChar: MergeInNewLine,\r\n            unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,\r\n            unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,\r\n            tabInTable: TabInTable,\r\n            upDownInTable: UpDownInTable,\r\n            insertLineBeforeStructuredNodeFeature: InsertLineBeforeStructuredNodeFeature,\r\n            autoBullet: AutoBullet,\r\n            autoLink: AutoLink,\r\n            unlinkWhenBackspaceAfterLink: UnlinkWhenBackspaceAfterLink,\r\n            defaultShortcut: DefaultShortcut,\r\n            noCycleCursorMove: NoCycleCursorMove,\r\n            smartOrderedList: getSmartOrderedList(featureSet.smartOrderedListStyles),\r\n        };\r\n        let keys = Object.keys(allFeatures) as (keyof ContentEditFeatures)[];\r\n        return keys.filter(key => featureSet[key]).map(key => allFeatures[key]);\r\n    }\r\n}\r\n","import { LinkInlineElement, matchLink } from 'roosterjs-editor-dom';\r\nimport { removeLink, replaceWithNode } from 'roosterjs-editor-api';\r\nimport {\r\n    ChangeSource,\r\n    LinkData,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginKeyboardEvent,\r\n    ClipboardData,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    Editor,\r\n    cacheGetEventData,\r\n    cacheGetContentSearcher,\r\n    clearContentSearcherCache,\r\n    GenericContentEditFeature,\r\n    Keys,\r\n} from 'roosterjs-editor-core';\r\n\r\n/**\r\n * When user type, they may end a link with a puncatuation, i.e. www.bing.com;\r\n * we need to trim off the trailing puncatuation before turning it to link match\r\n */\r\nconst TRAILING_PUNCTUATION_REGEX = /[.+=\\s:;\"',>]+$/i;\r\nconst MINIMUM_LENGTH = 5;\r\n\r\n/**\r\n * AutoLink edit feature, provides the ability to automatically convert text user typed or pasted\r\n * in hyperlink format into a real hyperlink\r\n */\r\nexport const AutoLink: GenericContentEditFeature<PluginEvent> = {\r\n    keys: [Keys.ENTER, Keys.SPACE, Keys.CONTENTCHANGED],\r\n    shouldHandleEvent: cacheGetLinkData,\r\n    handleEvent: autoLink,\r\n};\r\n\r\n/**\r\n * UnlinkWhenBackspaceAfterLink edit feature, provides the ability to convert a hyperlink back into text\r\n * if user presses BACKSPACE right after a hyperlink\r\n */\r\nexport const UnlinkWhenBackspaceAfterLink: GenericContentEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: hasLinkBeforeCursor,\r\n    handleEvent: (event, editor) => {\r\n        event.rawEvent.preventDefault();\r\n        removeLink(editor);\r\n    },\r\n};\r\n\r\nfunction cacheGetLinkData(event: PluginEvent, editor: Editor): LinkData {\r\n    return event.eventType == PluginEventType.KeyDown ||\r\n        (event.eventType == PluginEventType.ContentChanged && event.source == ChangeSource.Paste)\r\n        ? cacheGetEventData(event, 'LINK_DATA', () => {\r\n              // First try to match link from the whole paste string from the plain text in clipboard.\r\n              // This helps when we paste a link next to some existing character, and the text we got\r\n              // from clipboard will only contain what we pasted, any existing characters will not\r\n              // be included.\r\n              let clipboardData =\r\n                  event.eventType == PluginEventType.ContentChanged &&\r\n                  event.source == ChangeSource.Paste &&\r\n                  (event.data as ClipboardData);\r\n              let link = matchLink((clipboardData.text || '').trim());\r\n              let searcher = cacheGetContentSearcher(event, editor);\r\n\r\n              // In case the matched link is already inside a <A> tag, we do a range search.\r\n              // getRangeFromText will return null if the given text is already in a LinkInlineElement\r\n              if (link && searcher.getRangeFromText(link.originalUrl, false /*exactMatch*/)) {\r\n                  return link;\r\n              }\r\n\r\n              let word = searcher && searcher.getWordBefore();\r\n              if (word && word.length > MINIMUM_LENGTH) {\r\n                  // Check for trailing punctuation\r\n                  let trailingPunctuations = word.match(TRAILING_PUNCTUATION_REGEX);\r\n                  let trailingPunctuation = (trailingPunctuations || [])[0] || '';\r\n                  let candidate = word.substring(0, word.length - trailingPunctuation.length);\r\n\r\n                  // Do special handling for ')', '}', ']'\r\n                  ['()', '{}', '[]'].forEach(str => {\r\n                      if (\r\n                          candidate[candidate.length - 1] == str[1] &&\r\n                          candidate.indexOf(str[0]) < 0\r\n                      ) {\r\n                          candidate = candidate.substr(0, candidate.length - 1);\r\n                      }\r\n                  });\r\n\r\n                  // Match and replace in editor\r\n                  return matchLink(candidate);\r\n              }\r\n              return null;\r\n          })\r\n        : null;\r\n}\r\n\r\nfunction hasLinkBeforeCursor(event: PluginKeyboardEvent, editor: Editor): boolean {\r\n    let contentSearcher = cacheGetContentSearcher(event, editor);\r\n    let inline = contentSearcher.getInlineElementBefore();\r\n    return inline instanceof LinkInlineElement;\r\n}\r\n\r\nfunction autoLink(event: PluginEvent, editor: Editor) {\r\n    let anchor = editor.getDocument().createElement('a');\r\n    let linkData = cacheGetLinkData(event, editor);\r\n\r\n    // Need to get searcher before we enter the async callback since the callback can happen when cursor is moved to next line\r\n    // and at that time a new searcher won't be able to find the link text to replace\r\n    let searcher = editor.getContentSearcherOfCursor();\r\n    anchor.textContent = linkData.originalUrl;\r\n    anchor.href = linkData.normalizedUrl;\r\n\r\n    editor.runAsync(() => {\r\n        editor.performAutoComplete(() => {\r\n            replaceWithNode(editor, linkData.originalUrl, anchor, false /* exactMatch */, searcher);\r\n\r\n            // The content at cursor has changed. Should also clear the cursor data cache\r\n            clearContentSearcherCache(event);\r\n            return anchor;\r\n        }, ChangeSource.AutoLink);\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FontSizeChange } from 'roosterjs-editor-types';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,\r\n * So that when increase/decrease font size, the font size can match the sequence of your font size picker\r\n */\r\nexport const FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];\r\nconst MIN_FONT_SIZE = 1;\r\nconst MAX_FONT_SIZE = 1000;\r\n\r\n/**\r\n * Increase or decrease font size in selection\r\n * @param editor The editor instance\r\n * @param change Whether increase or decrease font size\r\n * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES\r\n */\r\nexport default function changeFontSize(\r\n    editor: Editor,\r\n    change: FontSizeChange,\r\n    fontSizes: number[] = FONT_SIZES\r\n) {\r\n    let changeBase: 1 | -1 = change == FontSizeChange.Increase ? 1 : -1;\r\n    applyInlineStyle(editor, element => {\r\n        let pt = parseFloat(getComputedStyle(element, 'font-size'));\r\n        element.style.fontSize = getNewFontSize(pt, changeBase, fontSizes) + 'pt';\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n\r\nexport function getNewFontSize(pt: number, changeBase: 1 | -1, fontSizes: number[]): number {\r\n    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n    let last = fontSizes[fontSizes.length - 1];\r\n    if (pt <= fontSizes[0]) {\r\n        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);\r\n    } else if (pt > last || (pt == last && changeBase == 1)) {\r\n        pt = pt / 10;\r\n        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);\r\n    } else if (changeBase == 1) {\r\n        for (let i = 0; i < fontSizes.length; i++) {\r\n            if (pt < fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = fontSizes.length - 1; i >= 0; i--) {\r\n            if (pt > fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return pt;\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, NodeType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    getTagOfNode,\r\n    isBlockElement,\r\n    unwrap,\r\n    wrap,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n} from 'roosterjs-editor-dom';\r\n\r\nexport const TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(\r\n    ','\r\n);\r\nexport const TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];\r\nexport const ATTRIBUTES_TO_PRESERVE = ['href'];\r\n\r\n/**\r\n * Clear all formats of selected blocks.\r\n * When selection is collapsed, only clear format of current block.\r\n * @param editor The editor instance\r\n * @param tagsToUnwrap Optional. A string array contains HTML tags in upper case which we will unwrap when clear format\r\n * @param tagsToStopUnwrap Optional. A string array contains HTML tags in upper case which we will stop unwrap if these tags are hit\r\n */\r\nexport default function clearBlockFormat(\r\n    editor: Editor,\r\n    tagsToUnwrap: string[] = TAGS_TO_UNWRAP,\r\n    tagsToStopUnwrap: string[] = TAGS_TO_STOP_UNWRAP,\r\n    attributesToPreserve: string[] = ATTRIBUTES_TO_PRESERVE\r\n) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        let groups: {\r\n            first?: HTMLElement;\r\n            last?: HTMLElement;\r\n            td?: HTMLElement;\r\n        }[] = [{}];\r\n        let stopUnwrapSelector = tagsToStopUnwrap.join(',');\r\n\r\n        // 1. Collapse the selected blocks and get first and last element\r\n        collapseSelectedBlocks(editor, element => {\r\n            let group = groups[groups.length - 1];\r\n            let td = editor.getElementAtCursor(stopUnwrapSelector, element);\r\n            if (td != group.td && group.first) {\r\n                groups.push((group = {}));\r\n            }\r\n\r\n            group.td = td;\r\n            group.first = group.first || element;\r\n            group.last = element;\r\n        });\r\n\r\n        groups\r\n            .filter(group => group.first)\r\n            .forEach(group => {\r\n                // 2. Collapse with first and last element to make them under same parent\r\n                let nodes = editor.collapseNodes(group.first, group.last, true /*canSplitParent*/);\r\n\r\n                // 3. Continue collapse until we can't collapse any more (hit root node, or a table)\r\n                if (canCollapse(tagsToStopUnwrap, nodes[0])) {\r\n                    while (\r\n                        editor.contains(nodes[0].parentNode) &&\r\n                        canCollapse(tagsToStopUnwrap, nodes[0].parentNode as HTMLElement)\r\n                    ) {\r\n                        nodes = [splitBalancedNodeRange(nodes)];\r\n                    }\r\n                }\r\n\r\n                // 4. Clear formats of the nodes\r\n                nodes.forEach(node =>\r\n                    clearNodeFormat(\r\n                        node as HTMLElement,\r\n                        tagsToUnwrap,\r\n                        tagsToStopUnwrap,\r\n                        attributesToPreserve\r\n                    )\r\n                );\r\n\r\n                // 5. Clear CSS of container TD if exist\r\n                if (group.td) {\r\n                    let styles = group.td.getAttribute('style') || '';\r\n                    let styleArray = styles.split(';');\r\n                    styleArray = styleArray.filter(\r\n                        style =>\r\n                            style\r\n                                .trim()\r\n                                .toLowerCase()\r\n                                .indexOf('border') == 0\r\n                    );\r\n                    styles = styleArray.join(';');\r\n                    if (styles) {\r\n                        group.td.setAttribute('style', styles);\r\n                    } else {\r\n                        group.td.removeAttribute('style');\r\n                    }\r\n                }\r\n            });\r\n\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction clearNodeFormat(\r\n    node: Node,\r\n    tagsToUnwrap: string[],\r\n    tagsToStopUnwrap: string[],\r\n    attributesToPreserve: string[]\r\n): boolean {\r\n    if (node.nodeType != NodeType.Element || getTagOfNode(node) == 'BR') {\r\n        return false;\r\n    }\r\n\r\n    // 1. Recursively clear format of all its child nodes\r\n    let allChildrenAreBlock = toArray(node.childNodes)\r\n        .map(n => clearNodeFormat(n, tagsToUnwrap, tagsToStopUnwrap, attributesToPreserve))\r\n        .reduce((previousValue, value) => previousValue && value, true);\r\n\r\n    if (!canCollapse(tagsToStopUnwrap, node)) {\r\n        return false;\r\n    }\r\n\r\n    let returnBlockElement = isBlockElement(node);\r\n\r\n    // 2. If we should unwrap this tag, put it into an array and unwrap it later\r\n    if (tagsToUnwrap.indexOf(getTagOfNode(node)) >= 0 || allChildrenAreBlock) {\r\n        if (returnBlockElement && !allChildrenAreBlock) {\r\n            wrap(node);\r\n        }\r\n        unwrap(node);\r\n    } else {\r\n        // 3. Otherwise, remove all attributes\r\n        clearAttribute(node as HTMLElement, attributesToPreserve);\r\n    }\r\n\r\n    return returnBlockElement;\r\n}\r\n\r\nfunction clearAttribute(element: HTMLElement, attributesToPreserve: string[]) {\r\n    for (let attr of toArray(element.attributes)) {\r\n        if (\r\n            attributesToPreserve.indexOf(attr.name.toLowerCase()) < 0 &&\r\n            attr.name.indexOf('data-') != 0\r\n        ) {\r\n            element.removeAttribute(attr.name);\r\n        }\r\n    }\r\n}\r\n\r\nfunction canCollapse(tagsToStopUnwrap: string[], node: Node) {\r\n    return tagsToStopUnwrap.indexOf(getTagOfNode(node)) < 0;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport setBackgroundColor from './setBackgroundColor';\r\nimport setFontName from './setFontName';\r\nimport setFontSize from './setFontSize';\r\nimport setTextColor from './setTextColor';\r\nimport toggleBold from './toggleBold';\r\nimport toggleItalic from './toggleItalic';\r\nimport toggleUnderline from './toggleUnderline';\r\nimport { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\nconst STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];\r\n\r\n/**\r\n * Clear the format in current selection, after cleaning, the format will be\r\n * changed to default format. The format that get cleaned include B/I/U/font name/\r\n * font size/text color/background color/align left/align right/align center/superscript/subscript\r\n * @param editor The editor instance\r\n */\r\nexport default function clearFormat(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, DocumentCommand.RemoveFormat);\r\n\r\n        editor.queryElements('[class]', QueryScope.OnSelection, node =>\r\n            node.removeAttribute('class')\r\n        );\r\n\r\n        const defaultFormat = editor.getDefaultFormat();\r\n        const isDefaultFormatEmpty = Object.keys(defaultFormat).length === 0;\r\n        editor.queryElements('[style]', QueryScope.InSelection, node => {\r\n            STYLES_TO_REMOVE.forEach(style => node.style.removeProperty(style));\r\n\r\n            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style\r\n            // (note: because default format is empty, we're not adding style back in)\r\n            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {\r\n                node.removeAttribute('style');\r\n            }\r\n        });\r\n\r\n        if (!isDefaultFormatEmpty) {\r\n            if (defaultFormat.fontFamily) {\r\n                setFontName(editor, defaultFormat.fontFamily);\r\n            }\r\n            if (defaultFormat.fontSize) {\r\n                setFontSize(editor, defaultFormat.fontSize);\r\n            }\r\n            if (defaultFormat.textColor) {\r\n                if (defaultFormat.textColors) {\r\n                    setTextColor(editor, defaultFormat.textColors);\r\n                } else {\r\n                    setTextColor(editor, defaultFormat.textColor);\r\n                }\r\n            }\r\n            if (defaultFormat.backgroundColor) {\r\n                if (defaultFormat.backgroundColors) {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColors);\r\n                } else {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColor);\r\n                }\r\n            }\r\n            if (defaultFormat.bold) {\r\n                toggleBold(editor);\r\n            }\r\n            if (defaultFormat.italic) {\r\n                toggleItalic(editor);\r\n            }\r\n            if (defaultFormat.underline) {\r\n                toggleUnderline(editor);\r\n            }\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { HtmlSanitizer } from 'roosterjs-html-sanitizer';\r\nimport { matchLink } from 'roosterjs-editor-dom';\r\n\r\n// Regex matching Uri scheme\r\nconst URI_REGEX = /^[a-zA-Z]+:/i;\r\n// Regex matching begin of email address\r\nconst MAILTO_REGEX = /^[\\w.%+-]+@/i;\r\n// Regex matching begin of ftp, i.e. ftp.microsoft.com\r\nconst FTP_REGEX = /^ftp\\./i;\r\nconst TEMP_TITLE = 'istemptitle';\r\n\r\nfunction applyLinkPrefix(url: string): string {\r\n    if (!url) {\r\n        return url;\r\n    }\r\n\r\n    // Add link prefix per rule:\r\n    // (a) if the url always starts with a URI scheme, leave it as it is\r\n    // (b) if the url is an email address, xxx@... add mailto: prefix\r\n    // (c) if the url starts with ftp., add ftp:// prefix\r\n    // (d) rest, add http:// prefix\r\n    let prefix = '';\r\n    if (url.search(URI_REGEX) < 0) {\r\n        if (url.search(MAILTO_REGEX) == 0) {\r\n            prefix = 'mailto:';\r\n        } else if (url.search(FTP_REGEX) == 0) {\r\n            prefix = 'ftp://';\r\n        } else {\r\n            // fallback to http://\r\n            prefix = 'http://';\r\n        }\r\n    }\r\n\r\n    return prefix + url;\r\n}\r\n\r\n/**\r\n * Insert a hyperlink at cursor.\r\n * When there is a selection, hyperlink will be applied to the selection,\r\n * otherwise a hyperlink will be inserted to the cursor position.\r\n * @param editor Editor object\r\n * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.\r\n * When protocol is not specified, a best matched protocol will be predicted.\r\n * @param altText Optional alt text of the link, will be shown when hover on the link\r\n * @param displayText Optional display text for the link.\r\n * If specified, the display text of link will be replaced with this text.\r\n * If not specified and there wasn't a link, the link url will be used as display text.\r\n */\r\nexport default function createLink(\r\n    editor: Editor,\r\n    link: string,\r\n    altText?: string,\r\n    displayText?: string\r\n) {\r\n    editor.focus();\r\n    let url = (checkXss(link) || '').trim();\r\n    if (url) {\r\n        let linkData = matchLink(url);\r\n        // matchLink can match most links, but not all, i.e. if you pass link a link as \"abc\", it won't match\r\n        // we know in that case, users will want to insert a link like http://abc\r\n        // so we have separate logic in applyLinkPrefix to add link prefix depending on the format of the link\r\n        // i.e. if the link starts with something like abc@xxx, we will add mailto: prefix\r\n        // if the link starts with ftp.xxx, we will add ftp:// link. For more, see applyLinkPrefix\r\n        let normalizedUrl = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);\r\n        let originalUrl = linkData ? linkData.originalUrl : url;\r\n\r\n        editor.addUndoSnapshot(() => {\r\n            let range = editor.getSelectionRange();\r\n            let anchor: HTMLAnchorElement = null;\r\n            if (range && range.collapsed) {\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n\r\n                // If there is already a link, just change its href\r\n                if (anchor) {\r\n                    anchor.href = normalizedUrl;\r\n                    // Change text content if it is specified\r\n                    updateAnchorDisplayText(anchor, displayText);\r\n                } else {\r\n                    anchor = editor.getDocument().createElement('A') as HTMLAnchorElement;\r\n                    anchor.textContent = displayText || originalUrl;\r\n                    anchor.href = normalizedUrl;\r\n                    editor.insertNode(anchor);\r\n                }\r\n            } else {\r\n                // the selection is not collapsed, use browser execCommand\r\n                editor.getDocument().execCommand(DocumentCommand.CreateLink, false, normalizedUrl);\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n                updateAnchorDisplayText(anchor, displayText);\r\n            }\r\n            if (altText && anchor) {\r\n                // Hack: Ideally this should be done by HyperLink plugin.\r\n                // We make a hack here since we don't have an event to notify HyperLink plugin\r\n                // before we apply the link.\r\n                anchor.removeAttribute(TEMP_TITLE);\r\n                anchor.title = altText;\r\n            }\r\n            return anchor;\r\n        }, ChangeSource.CreateLink);\r\n    }\r\n}\r\n\r\nfunction getAnchorNodeAtCursor(editor: Editor): HTMLAnchorElement {\r\n    return editor.queryElements('a[href]', QueryScope.OnSelection)[0] as HTMLAnchorElement;\r\n}\r\n\r\nfunction updateAnchorDisplayText(anchor: HTMLAnchorElement, displayText: string) {\r\n    if (displayText && anchor.textContent != displayText) {\r\n        anchor.textContent = displayText;\r\n    }\r\n}\r\n\r\nfunction checkXss(link: string): string {\r\n    const santizer = new HtmlSanitizer();\r\n    const doc = new DOMParser().parseFromString('<a></a>', 'text/html');\r\n    const a = doc.body.firstChild as HTMLAnchorElement;\r\n\r\n    a.href = link || '';\r\n    santizer.sanitize(doc.body);\r\n    return a.href;\r\n}\r\n","import getInheritableStyles from '../utils/getInheritableStyles';\r\nimport HtmlSanitizerOptions from '../types/HtmlSanitizerOptions';\r\nimport htmlToDom from '../utils/htmlToDom';\r\nimport SanitizeHtmlOptions from '../types/SanitizeHtmlOptions';\r\nimport { cloneObject } from '../utils/cloneObject';\r\nimport { isHTMLElement } from 'roosterjs-cross-window';\r\nimport {\r\n    StringMap,\r\n    StyleCallbackMap,\r\n    ElementCallbackMap,\r\n    AttributeCallbackMap,\r\n} from '../types/maps';\r\nimport {\r\n    getAllowedAttributes,\r\n    getAllowedTags,\r\n    getDefaultStyleValues,\r\n    getStyleCallbacks,\r\n} from '../utils/getAllowedValues';\r\n\r\n/**\r\n * HTML sanitizer class provides two featuers:\r\n * 1. Convert global CSS to inline CSS\r\n * 2. Sanitize an HTML document, remove unnecessary/dangerous attribute/nodes\r\n */\r\nexport default class HtmlSanitizer {\r\n    /**\r\n     * Convert global CSS to inline CSS if any\r\n     * @param html HTML source\r\n     * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS\r\n     */\r\n    static convertInlineCss(html: string, additionalStyleNodes?: HTMLStyleElement[]) {\r\n        let sanitizer = new HtmlSanitizer({\r\n            additionalGlobalStyleNodes: additionalStyleNodes,\r\n        });\r\n        return sanitizer.exec(html, true /*convertCssOnly*/);\r\n    }\r\n\r\n    /**\r\n     * Sanitize HTML string, remove any unuseful HTML node/attribute/CSS.\r\n     * @param html HTML source string\r\n     * @param options Options used for this sanitizing process\r\n     */\r\n    static sanitizeHtml(html: string, options?: SanitizeHtmlOptions) {\r\n        options = options || {};\r\n        let sanitizer = new HtmlSanitizer(options);\r\n        let currentStyles = isHTMLElement(options.currentElementOrStyle)\r\n            ? getInheritableStyles(options.currentElementOrStyle)\r\n            : options.currentElementOrStyle;\r\n        return sanitizer.exec(\r\n            html,\r\n            options.convertCssOnly,\r\n            options.preserveFragmentOnly,\r\n            currentStyles\r\n        );\r\n    }\r\n\r\n    private elementCallbacks: ElementCallbackMap;\r\n    private styleCallbacks: StyleCallbackMap;\r\n    private attributeCallbacks: AttributeCallbackMap;\r\n    private allowedTags: string[];\r\n    private allowedAttributes: string[];\r\n    private defaultStyleValues: StringMap;\r\n    private additionalGlobalStyleNodes: HTMLStyleElement[];\r\n    private allowPreserveWhiteSpace: boolean;\r\n\r\n    /**\r\n     * Construct a new instance of HtmlSanitizer\r\n     * @param options Options for HtmlSanitizer\r\n     */\r\n    constructor(options?: HtmlSanitizerOptions) {\r\n        options = options || {};\r\n        this.elementCallbacks = cloneObject(options.elementCallbacks);\r\n        this.styleCallbacks = getStyleCallbacks(options.styleCallbacks);\r\n        this.attributeCallbacks = cloneObject(options.attributeCallbacks);\r\n        this.allowedTags = getAllowedTags(options.additionalAllowedTags);\r\n        this.allowedAttributes = getAllowedAttributes(options.additionalAllowAttributes);\r\n        this.defaultStyleValues = getDefaultStyleValues(options.additionalDefaultStyleValues);\r\n        this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];\r\n        this.allowPreserveWhiteSpace = options.allowPreserveWhiteSpace;\r\n    }\r\n\r\n    /**\r\n     * Sanitize HTML string\r\n     * This function will do the following work:\r\n     * 1. Convert global CSS into inline CSS\r\n     * 2. Remove dangerous HTML tags and attributes\r\n     * 3. Remove useless CSS properties\r\n     * @param html The input HTML\r\n     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing\r\n     * @param preserveFragmentOnly If set to true, only preserve the html content between &lt;!--StartFragment--&gt; and &lt;!--Endfragment--&gt;\r\n     * @param currentStyles Current inheritable CSS styles\r\n     */\r\n    exec(\r\n        html: string,\r\n        convertCssOnly?: boolean,\r\n        preserveFragmentOnly?: boolean,\r\n        currentStyles?: StringMap\r\n    ): string {\r\n        let doc = htmlToDom(html, preserveFragmentOnly);\r\n        if (doc) {\r\n            this.convertGlobalCssToInlineCss(doc);\r\n            if (!convertCssOnly) {\r\n                this.sanitize(doc.body, currentStyles);\r\n            }\r\n        }\r\n        return (doc && doc.body && doc.body.innerHTML) || '';\r\n    }\r\n\r\n    /**\r\n     * Sanitize an HTML element, remove unnecessary or dangerous elements/attribute/CSS rules\r\n     * @param rootNode Root node to sanitize\r\n     * @param currentStyles Current CSS styles. Inheritable styles in the given node which has\r\n     * the same value with current styles will be ignored.\r\n     */\r\n    sanitize(rootNode: HTMLElement, currentStyles?: StringMap) {\r\n        if (!rootNode) {\r\n            return '';\r\n        }\r\n        currentStyles = cloneObject(currentStyles, getInheritableStyles(null));\r\n        this.processNode(rootNode, currentStyles, {});\r\n    }\r\n\r\n    /**\r\n     * Convert global CSS into inline CSS\r\n     * @param rootNode The HTML Document\r\n     */\r\n    convertGlobalCssToInlineCss(rootNode: HTMLDocument) {\r\n        let styleNodes = toArray(rootNode.querySelectorAll('style'));\r\n        let styleSheets = this.additionalGlobalStyleNodes\r\n            .reverse()\r\n            .map(node => node.sheet as CSSStyleSheet)\r\n            .concat(styleNodes.map(node => node.sheet as CSSStyleSheet).reverse())\r\n            .filter(sheet => sheet);\r\n        for (let styleSheet of styleSheets) {\r\n            for (let j = styleSheet.cssRules.length - 1; j >= 0; j--) {\r\n                // Skip any none-style rule, i.e. @page\r\n                let styleRule = styleSheet.cssRules[j] as CSSStyleRule;\r\n                let text = styleRule && styleRule.style ? styleRule.style.cssText : null;\r\n                if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {\r\n                    continue;\r\n                }\r\n                // Make sure the selector is not empty\r\n                for (let selector of styleRule.selectorText.split(',')) {\r\n                    if (!selector || !selector.trim() || selector.indexOf(':') >= 0) {\r\n                        continue;\r\n                    }\r\n                    let nodes = toArray(rootNode.querySelectorAll(selector));\r\n                    // Always put existing styles after so that they have higher priority\r\n                    // Which means if both global style and inline style apply to the same element,\r\n                    // inline style will have higher priority\r\n                    nodes.forEach(node =>\r\n                        node.setAttribute('style', text + (node.getAttribute('style') || ''))\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        styleNodes.forEach(node => {\r\n            if (node.parentNode) {\r\n                node.parentNode.removeChild(node);\r\n            }\r\n        });\r\n    }\r\n\r\n    private processNode(node: Node, currentStyle: StringMap, context: Object) {\r\n        let nodeType = node.nodeType;\r\n        let isElement = nodeType == Node.ELEMENT_NODE;\r\n        let isText = nodeType == Node.TEXT_NODE;\r\n        let element = <HTMLElement>node;\r\n        let tag = isElement ? element.tagName.toUpperCase() : '';\r\n\r\n        if (\r\n            (isElement && !this.allowElement(element, tag, context)) ||\r\n            (isText && /^[\\r\\n]*$/g.test(node.nodeValue) && !currentStyle.insidePRE) ||\r\n            (!isElement && !isText)\r\n        ) {\r\n            node.parentNode.removeChild(node);\r\n        } else if (\r\n            isText &&\r\n            !this.allowPreserveWhiteSpace &&\r\n            currentStyle['white-space'] == 'pre'\r\n        ) {\r\n            node.nodeValue = node.nodeValue.replace(/^ /gm, '\\u00A0').replace(/ {2}/g, ' \\u00A0');\r\n        } else if (isElement) {\r\n            let thisStyle = cloneObject(currentStyle);\r\n            this.processAttributes(element, context);\r\n            this.processCss(element, tag, thisStyle, context);\r\n\r\n            // Special handling for PRE tag, need to preserve \\r\\n inside PRE\r\n            if (tag == 'PRE') {\r\n                thisStyle.insidePRE = 'true';\r\n            }\r\n\r\n            let child: Node = element.firstChild;\r\n            let next: Node;\r\n            for (; child; child = next) {\r\n                next = child.nextSibling;\r\n                this.processNode(child, thisStyle, context);\r\n            }\r\n        }\r\n    }\r\n\r\n    private processCss(element: HTMLElement, tag: string, thisStyle: StringMap, context: Object) {\r\n        let styleNode = element.getAttributeNode('style');\r\n        if (!styleNode) {\r\n            return;\r\n        }\r\n\r\n        let source = styleNode.value.split(';');\r\n        let result = source.filter(style => {\r\n            let pair: string[];\r\n\r\n            if (!style || style.trim() == '' || (pair = style.split(':')).length != 2) {\r\n                return false;\r\n            }\r\n\r\n            let name = pair[0].trim().toLowerCase();\r\n            let value = pair[1].trim().toLowerCase();\r\n            let callback = this.styleCallbacks[name];\r\n            let isInheritable = thisStyle[name] != undefined;\r\n            let keep =\r\n                (!callback || callback(value, element, context)) &&\r\n                value != 'inherit' &&\r\n                value.indexOf('expression') < 0 &&\r\n                name.substr(0, 1) != '-' &&\r\n                this.defaultStyleValues[name] != value &&\r\n                ((isInheritable && value != thisStyle[name]) ||\r\n                    (!isInheritable && value != 'initial' && value != 'normal'));\r\n            if (keep && isInheritable) {\r\n                thisStyle[name] = value;\r\n            }\r\n            return keep && (this.allowPreserveWhiteSpace || name != 'white-space');\r\n        });\r\n\r\n        if (source.length != result.length) {\r\n            if (result.length > 0) {\r\n                element.setAttribute('style', result.map(s => s.trim()).join('; '));\r\n            } else {\r\n                element.removeAttribute('style');\r\n            }\r\n        }\r\n    }\r\n\r\n    private processAttributes(element: HTMLElement, context: Object) {\r\n        for (let i = element.attributes.length - 1; i >= 0; i--) {\r\n            let attribute = element.attributes[i];\r\n            let name = attribute.name.toLowerCase().trim();\r\n            let value = attribute.value;\r\n            let callback = this.attributeCallbacks[name];\r\n\r\n            if (callback) {\r\n                value = callback(value, element, context);\r\n            } else if (this.allowedAttributes.indexOf(name) < 0) {\r\n                value = null;\r\n            }\r\n\r\n            if (\r\n                value === null ||\r\n                value === undefined ||\r\n                value.match(/s\\n*c\\n*r\\n*i\\n*p\\n*t\\n*:/i) // match script: with any NewLine inside. Browser will ignore those NewLine char and still treat it as script prefix\r\n            ) {\r\n                element.removeAttribute(name);\r\n            } else {\r\n                attribute.value = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    private allowElement(element: HTMLElement, tag: string, context: Object): boolean {\r\n        let callback = this.elementCallbacks[tag];\r\n        return callback\r\n            ? callback(element, context)\r\n            : this.allowedTags.indexOf(tag) >= 0 || tag.indexOf(':') > 0;\r\n    }\r\n}\r\n\r\nfunction toArray<T extends Node>(list: NodeListOf<T>): T[] {\r\n    return [].slice.call(list) as T[];\r\n}\r\n","import { cloneObject } from './cloneObject';\r\nimport { StringMap, StyleCallbackMap } from '../types/maps';\r\n\r\nconst ALLOWED_HTML_TAGS = (\r\n    'BODY,H1,H2,H3,H4,H5,H6,FORM,P,BR,NOBR,HR,ACRONYM,ABBR,ADDRESS,B,' +\r\n    'BDI,BDO,BIG,BLOCKQUOTE,CENTER,CITE,CODE,DEL,DFN,EM,FONT,I,INS,KBD,MARK,METER,PRE,PROGRESS,' +\r\n    'Q,RP,RT,RUBY,S,SAMP,SMALL,STRIKE,STRONG,SUB,SUP,TEMPLATE,TIME,TT,U,VAR,WBR,XMP,INPUT,TEXTAREA,' +\r\n    'BUTTON,SELECT,OPTGROUP,OPTION,LABEL,FIELDSET,LEGEND,DATALIST,OUTPUT,IMG,MAP,AREA,CANVAS,FIGCAPTION,' +\r\n    'FIGURE,PICTURE,A,NAV,UL,OL,LI,DIR,UL,DL,DT,DD,MENU,MENUITEM,TABLE,CAPTION,TH,TR,TD,THEAD,TBODY,' +\r\n    'TFOOT,COL,COLGROUP,DIV,SPAN,HEADER,FOOTER,MAIN,SECTION,ARTICLE,ASIDE,DETAILS,DIALOG,SUMMARY,DATA'\r\n).split(',');\r\n\r\nconst ALLOWED_HTML_ATTRIBUTES = (\r\n    'accept,align,alt,checked,cite,color,cols,colspan,contextmenu,' +\r\n    'coords,datetime,default,dir,dirname,disabled,download,face,headers,height,hidden,high,href,' +\r\n    'hreflang,ismap,kind,label,lang,list,low,max,maxlength,media,min,multiple,open,optimum,pattern,' +\r\n    'placeholder,readonly,rel,required,reversed,rows,rowspan,scope,selected,shape,size,sizes,span,' +\r\n    'spellcheck,src,srclang,srcset,start,step,style,tabindex,target,title,translate,type,usemap,value,' +\r\n    'width,wrap'\r\n).split(',');\r\n\r\nconst DEFAULT_STYLE_VALUES: { [name: string]: string } = {\r\n    'background-color': 'transparent',\r\n    'border-bottom-color': 'rgb(0, 0, 0)',\r\n    'border-bottom-style': 'none',\r\n    'border-bottom-width': '0px',\r\n    'border-image-outset': '0',\r\n    'border-image-repeat': 'stretch',\r\n    'border-image-slice': '100%',\r\n    'border-image-source': 'none',\r\n    'border-image-width': '1',\r\n    'border-left-color': 'rgb(0, 0, 0)',\r\n    'border-left-style': 'none',\r\n    'border-left-width': '0px',\r\n    'border-right-color': 'rgb(0, 0, 0)',\r\n    'border-right-style': 'none',\r\n    'border-right-width': '0px',\r\n    'border-top-color': 'rgb(0, 0, 0)',\r\n    'border-top-style': 'none',\r\n    'border-top-width': '0px',\r\n    'outline-color': 'transparent',\r\n    'outline-style': 'none',\r\n    'outline-width': '0px',\r\n    overflow: 'visible',\r\n    'text-decoration': 'none',\r\n    '-webkit-text-stroke-width': '0px',\r\n    'word-wrap': 'break-word',\r\n    'margin-left': '0px',\r\n    'margin-right': '0px',\r\n    padding: '0px',\r\n    'padding-top': '0px',\r\n    'padding-left': '0px',\r\n    'padding-right': '0px',\r\n    'padding-bottom': '0px',\r\n    border: '0px',\r\n    'border-top': '0px',\r\n    'border-left': '0px',\r\n    'border-right': '0px',\r\n    'border-bottom': '0px',\r\n    'vertical-align': 'baseline',\r\n    float: 'none',\r\n};\r\n\r\nexport function getAllowedTags(additionalTags: string[]): string[] {\r\n    return unique(ALLOWED_HTML_TAGS.concat(additionalTags || [])).map(tag => tag.toUpperCase());\r\n}\r\n\r\nexport function getAllowedAttributes(additionalAttributes: string[]): string[] {\r\n    return unique(ALLOWED_HTML_ATTRIBUTES.concat(additionalAttributes || [])).map(attr =>\r\n        attr.toLocaleLowerCase()\r\n    );\r\n}\r\n\r\nexport function getDefaultStyleValues(additionalDefaultStyles: StringMap): StringMap {\r\n    let result = cloneObject(DEFAULT_STYLE_VALUES);\r\n    if (additionalDefaultStyles) {\r\n        Object.keys(additionalDefaultStyles).forEach(name => {\r\n            let value = additionalDefaultStyles[name];\r\n            if (value !== null && value !== undefined) {\r\n                result[name] = value;\r\n            } else {\r\n                delete result[name];\r\n            }\r\n        });\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport function getStyleCallbacks(callbacks: StyleCallbackMap): StyleCallbackMap {\r\n    let result = cloneObject(callbacks);\r\n    result.position = result.position || removeValue;\r\n    result.width = result.width || removeWidthForLiAndDiv;\r\n    return result;\r\n}\r\n\r\nfunction removeValue(): null {\r\n    return null;\r\n}\r\n\r\nfunction removeWidthForLiAndDiv(value: string, element: HTMLElement) {\r\n    let tag = element.tagName;\r\n    return !(tag == 'LI' || tag == 'DIV');\r\n}\r\n\r\nfunction unique<T>(array: T[]): T[] {\r\n    return array.filter((value, index, self) => self.indexOf(value) == index);\r\n}\r\n","import { cacheGetElementAtCursor, Editor } from 'roosterjs-editor-core';\r\nimport { getComputedStyles, getTagOfNode, Position } from 'roosterjs-editor-dom';\r\nimport { getPendableFormatState } from 'roosterjs-editor-dom';\r\nimport {\r\n    ElementBasedFormatState,\r\n    FormatState,\r\n    PluginEvent,\r\n    QueryScope,\r\n    StyleBasedFormatState,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get element based Format State at cursor\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns An ElementBasedFormatState object\r\n */\r\nexport function getElementBasedFormatState(\r\n    editor: Editor,\r\n    event?: PluginEvent\r\n): ElementBasedFormatState {\r\n    let listTag = getTagOfNode(cacheGetElementAtCursor(editor, event, 'OL,UL'));\r\n    let headerTag = getTagOfNode(cacheGetElementAtCursor(editor, event, 'H1,H2,H3,H4,H5,H6'));\r\n\r\n    return {\r\n        isBullet: listTag == 'UL',\r\n        isNumbering: listTag == 'OL',\r\n        headerLevel: (headerTag && parseInt(headerTag[1])) || 0,\r\n\r\n        canUnlink: !!editor.queryElements('a[href]', QueryScope.OnSelection)[0],\r\n        canAddImageAltText: !!editor.queryElements('img', QueryScope.OnSelection)[0],\r\n        isBlockQuote: !!editor.queryElements('blockquote', QueryScope.OnSelection)[0],\r\n    };\r\n}\r\n\r\n/**\r\n * Get style based Format State at cursor\r\n * @param editor The editor instance\r\n * @returns A StyleBasedFormatState object\r\n */\r\nexport function getStyleBasedFormatState(editor: Editor): StyleBasedFormatState {\r\n    let range = editor.getSelectionRange();\r\n    let node = range && Position.getStart(range).normalize().node;\r\n    let styles = node ? getComputedStyles(node) : [];\r\n    return {\r\n        fontName: styles[0],\r\n        fontSize: styles[1],\r\n        textColor: styles[2],\r\n        backgroundColor: styles[3],\r\n    };\r\n}\r\n\r\n/**\r\n * Get format state at cursor\r\n * A format state is a collection of all format related states, e.g.,\r\n * bold, italic, underline, font name, font size, etc.\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns The format state at cursor\r\n */\r\nexport default function getFormatState(editor: Editor, event?: PluginEvent): FormatState {\r\n    return {\r\n        ...getPendableFormatState(editor.getDocument()),\r\n        ...getElementBasedFormatState(editor, event),\r\n        ...getStyleBasedFormatState(editor),\r\n        canUndo: editor.canUndo(),\r\n        canRedo: editor.canRedo(),\r\n    };\r\n}\r\n","import { ChangeSource } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image file. There are at least 3 ways to obtain the file object:\r\n * From local file, from clipboard data, from drag-and-drop\r\n */\r\nexport default function insertImage(editor: Editor, imageFile: File): void;\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image link.\r\n */\r\nexport default function insertImage(editor: Editor, url: string): void;\r\n\r\nexport default function insertImage(editor: Editor, imageFile: File | string): void {\r\n    if (typeof imageFile == 'string') {\r\n        insertImageWithSrc(editor, imageFile);\r\n    } else {\r\n        let reader = new FileReader();\r\n        reader.onload = (event: ProgressEvent) => {\r\n            if (!editor.isDisposed()) {\r\n                insertImageWithSrc(editor, (event.target as FileReader).result as string);\r\n            }\r\n        };\r\n        reader.readAsDataURL(imageFile);\r\n    }\r\n}\r\n\r\nfunction insertImageWithSrc(editor: Editor, src: string) {\r\n    editor.addUndoSnapshot(() => {\r\n        const image = editor.getDocument().createElement('img');\r\n        image.src = src;\r\n        image.style.maxWidth = '100%';\r\n        editor.insertNode(image);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, PositionType, TableFormat } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { Position, VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert table into editor at current selection\r\n * @param editor The editor instance\r\n * @param columns Number of columns in table, it also controls the default table cell width:\r\n * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px\r\n * @param rows Number of rows in table\r\n * @param format (Optional) The table format. If not passed, the default format will be applied:\r\n * background color: #FFF; border color: #ABABAB\r\n */\r\nexport default function insertTable(\r\n    editor: Editor,\r\n    columns: number,\r\n    rows: number,\r\n    format?: TableFormat\r\n) {\r\n    let document = editor.getDocument();\r\n    let fragment = document.createDocumentFragment();\r\n    let table = document.createElement('table') as HTMLTableElement;\r\n    fragment.appendChild(table);\r\n    table.cellSpacing = '0';\r\n    table.cellPadding = '1';\r\n    for (let i = 0; i < rows; i++) {\r\n        let tr = document.createElement('tr') as HTMLTableRowElement;\r\n        table.appendChild(tr);\r\n        for (let j = 0; j < columns; j++) {\r\n            let td = document.createElement('td') as HTMLTableCellElement;\r\n            tr.appendChild(td);\r\n            td.appendChild(document.createElement('br'));\r\n            td.style.width = getTableCellWidth(columns);\r\n        }\r\n    }\r\n\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        let vtable = new VTable(table);\r\n        vtable.applyFormat(\r\n            format || {\r\n                bgColorEven: '#FFF',\r\n                bgColorOdd: '#FFF',\r\n                topBorderColor: '#ABABAB',\r\n                bottomBorderColor: '#ABABAB',\r\n                verticalBorderColor: '#ABABAB',\r\n            }\r\n        );\r\n        vtable.writeBack();\r\n        editor.insertNode(fragment);\r\n        editor.runAsync(() => editor.select(new Position(table, PositionType.Begin).normalize()));\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction getTableCellWidth(columns: number): string {\r\n    if (columns <= 4) {\r\n        return '120px';\r\n    } else if (columns <= 6) {\r\n        return '100px';\r\n    } else {\r\n        return '70px';\r\n    }\r\n}\r\n","import { ChangeSource, TableOperation } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Edit table with given operation. If there is no table at cursor then no op.\r\n * @param editor The editor instance\r\n * @param operation Table operation\r\n */\r\nexport default function editTable(editor: Editor, operation: TableOperation) {\r\n    let td = editor.getElementAtCursor('TD,TH') as HTMLTableCellElement;\r\n    if (td) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(td);\r\n            vtable.edit(operation);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n\r\n            if (!editor.select(start, end)) {\r\n                editor.select(editor.contains(td) ? td : vtable.getCurrentTd());\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, TableFormat } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Format table\r\n * @param editor The editor which contains the table to format\r\n * @param format A TableFormat object contains format information we want to apply to the table\r\n * @param table The table to format. This is optional. When not passed, the current table (if any) will be formatted\r\n */\r\nexport default function formatTable(\r\n    editor: Editor,\r\n    format: Partial<TableFormat>,\r\n    table?: HTMLTableElement\r\n) {\r\n    table = table || (editor.getElementAtCursor('TABLE') as HTMLTableElement);\r\n    if (table) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(table);\r\n            vtable.applyFormat(format);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n            editor.select(start, end);\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { unwrap } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Remove link at selection. If no links at selection, do nothing.\r\n * If selection contains multiple links, all of the link styles will be removed.\r\n * If only part of a link is selected, the whole link style will be removed.\r\n * @param editor The editor instance\r\n */\r\nexport default function removeLink(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        editor.queryElements('a[href]', QueryScope.OnSelection, unwrap);\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ContentPosition } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { PositionContentSearcher } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Replace text before current selection with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param text The text for matching. We will try to match the text with the text before cursor\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n * @param searcher Optional PositionContentSearcher of current selection to help search text\r\n */\r\nexport default function replaceWithNode(\r\n    editor: Editor,\r\n    text: string,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: PositionContentSearcher\r\n): boolean;\r\n\r\n/**\r\n * Replace a given range with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param range The range to replace from\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n */\r\nexport default function replaceWithNode(\r\n    editor: Editor,\r\n    range: Range,\r\n    node: Node,\r\n    exactMatch: boolean\r\n): boolean;\r\n\r\nexport default function replaceWithNode(\r\n    editor: Editor,\r\n    textOrRange: string | Range,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: PositionContentSearcher\r\n): boolean {\r\n    // Make sure the text and node is valid\r\n    if (!textOrRange || !node) {\r\n        return false;\r\n    }\r\n\r\n    let range: Range;\r\n\r\n    if (typeof textOrRange == 'string') {\r\n        searcher = searcher || editor.getContentSearcherOfCursor();\r\n        range = searcher && searcher.getRangeFromText(textOrRange, exactMatch);\r\n    } else {\r\n        range = textOrRange;\r\n    }\r\n\r\n    if (range) {\r\n        const backupRange = editor.getSelectionRange();\r\n\r\n        // If the range to replace is right before current cursor, it is actually an exact match\r\n        if (\r\n            backupRange.collapsed &&\r\n            range.endContainer == backupRange.startContainer &&\r\n            range.endOffset == backupRange.startOffset\r\n        ) {\r\n            exactMatch = true;\r\n        }\r\n\r\n        editor.insertNode(node, {\r\n            position: ContentPosition.Range,\r\n            updateCursor: exactMatch,\r\n            replaceSelection: true,\r\n            insertOnNewLine: false,\r\n            range: range,\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { Alignment, ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set content alignment\r\n * @param editor The editor instance\r\n * @param alignment The alignment option:\r\n * Alignment.Center, Alignment.Left, Alignment.Right\r\n */\r\nexport default function setAlignment(editor: Editor, alignment: Alignment) {\r\n    let command = DocumentCommand.JustifyLeft;\r\n    let align = 'left';\r\n\r\n    if (alignment == Alignment.Center) {\r\n        command = DocumentCommand.JustifyCenter;\r\n        align = 'center';\r\n    } else if (alignment == Alignment.Right) {\r\n        command = DocumentCommand.JustifyRight;\r\n        align = 'right';\r\n    }\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, command);\r\n        editor.queryElements(\r\n            '[align]',\r\n            QueryScope.OnSelection,\r\n            node => (node.style.textAlign = align)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, Direction } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Change direction for the blocks/paragraph at selection\r\n * @param editor The editor instance\r\n * @param direction The direction option:\r\n * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'\r\n */\r\nexport default function setDirection(editor: Editor, direction: Direction) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        collapseSelectedBlocks(editor, element => {\r\n            element.setAttribute('dir', direction == Direction.LeftToRight ? 'ltr' : 'rtl');\r\n            element.style.textAlign = direction == Direction.LeftToRight ? 'left' : 'right';\r\n        });\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set image alt text for all selected images at selection. If no images is contained\r\n * in selection, do nothing.\r\n * The alt attribute provides alternative information for an image if a user for some reason\r\n * cannot view it (because of slow connection, an error in the src attribute, or if the user\r\n * uses a screen reader). See https://www.w3schools.com/tags/att_img_alt.asp\r\n * @param editor The editor instance\r\n * @param altText The image alt text\r\n */\r\nexport default function setImageAltText(editor: Editor, altText: string) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        editor.queryElements('img', QueryScope.OnSelection, node =>\r\n            node.setAttribute('alt', altText)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import processList from '../utils/processList';\r\nimport { ChangeSource, DocumentCommand, Indentation, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set indentation at selection\r\n * If selection contains bullet/numbering list, increase/decrease indentation will\r\n * increase/decrease the list level by one.\r\n * @param editor The editor instance\r\n * @param indentation The indentation option:\r\n * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation\r\n */\r\nexport default function setIndentation(editor: Editor, indentation: Indentation) {\r\n    let command: DocumentCommand.Indent | DocumentCommand.Outdent =\r\n        indentation == Indentation.Increase ? DocumentCommand.Indent : DocumentCommand.Outdent;\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n        let listNode = editor.getElementAtCursor('OL,UL');\r\n        let newNode: Node;\r\n\r\n        if (listNode) {\r\n            // There is already list node, setIndentation() will increase/decrease the list level,\r\n            // so we need to process the list when change indentation\r\n            newNode = processList(editor, command);\r\n        } else {\r\n            // No existing list node, browser will create <Blockquote> node for indentation.\r\n            // We need to set top and bottom margin to 0 to avoid unnecessary spaces\r\n            editor.getDocument().execCommand(command, false, null);\r\n            editor.queryElements('BLOCKQUOTE', QueryScope.OnSelection, node => {\r\n                newNode = newNode || node;\r\n                node.style.marginTop = '0px';\r\n                node.style.marginBottom = '0px';\r\n            });\r\n        }\r\n\r\n        return newNode;\r\n    }, ChangeSource.Format);\r\n}\r\n","import processList from '../utils/processList';\r\nimport { ChangeSource, DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle bullet at selection\r\n * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one\r\n * If selection contains number list, toggle bullet will convert the number list into bullet list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBullet(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(\r\n        () => processList(editor, DocumentCommand.InsertUnorderedList),\r\n        ChangeSource.Format\r\n    );\r\n}\r\n","import processList from '../utils/processList';\r\nimport { ChangeSource, DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle numbering at selection\r\n * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one\r\n * If selection contains bullet list, toggle numbering will convert the bullet list into number list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * realization of browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleNumbering(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(\r\n        () => processList(editor, DocumentCommand.InsertOrderedList),\r\n        ChangeSource.Format\r\n    );\r\n}\r\n","import toggleTagCore from '../utils/toggleTagCore';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\nconst BLOCKQUOTE_TAG = 'blockquote';\r\nconst DEFAULT_STYLER = (element: HTMLElement): void => {\r\n    element.style.borderLeft = '3px solid';\r\n    element.style.borderColor = '#C8C8C8';\r\n    element.style.paddingLeft = '10px';\r\n    element.style.color = '#666666';\r\n};\r\n\r\n/**\r\n * Toggle blockquote at selection, if selection already contains any blockquoted elements,\r\n * the blockquoted elements will be unblockquoted and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the blockquote element\r\n */\r\nexport default function toggleBlockQuote(editor: Editor, styler?: (element: HTMLElement) => void) {\r\n    toggleTagCore(editor, BLOCKQUOTE_TAG, styler || DEFAULT_STYLER);\r\n}\r\n","import toggleTagCore from '../utils/toggleTagCore';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getTagOfNode, unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst PRE_TAG = 'pre';\r\nconst CODE_TAG = 'code';\r\nconst CODE_NODE_TAG = 'CODE';\r\n\r\n/**\r\n * Toggle code block at selection, if selection already contains any code blocked elements,\r\n * the code block elements will be no longer be code blocked and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the code block element\r\n */\r\nexport default function toggleCodeBlock(\r\n    editor: Editor,\r\n    styler?: (element: HTMLElement) => void\r\n): void {\r\n    toggleTagCore(editor, PRE_TAG, styler, wrapFunction, unwrapFunction);\r\n}\r\n\r\nfunction wrapFunction(nodes: Node[]): HTMLElement {\r\n    let codeBlock = wrap(nodes, CODE_TAG);\r\n    return wrap(codeBlock, PRE_TAG);\r\n}\r\n\r\nfunction unwrapFunction(node: HTMLElement): Node {\r\n    if (!node) {\r\n        return null;\r\n    }\r\n\r\n    let firstChild = node.childNodes[0];\r\n    if (node.childNodes.length == 1 && getTagOfNode(firstChild) == CODE_NODE_TAG) {\r\n        unwrap(firstChild);\r\n    }\r\n\r\n    return unwrap(node);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle strikethrough at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only strikethrough text, the strikethrough style will be removed\r\n * If selection contains only normal text, strikethrough style will be added to the whole selected text\r\n * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleStrikethrough(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.StrikeThrough);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle subscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only subscript text, the subscript style will be removed\r\n * If selection contains only normal text, subscript style will be added to the whole selected text\r\n * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text\r\n * If selection contains any superscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSubscript(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Subscript);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle superscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only superscript text, the superscript style will be removed\r\n * If selection contains only normal text, superscript style will be added to the whole selected text\r\n * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text\r\n * If selection contains any subscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSuperscript(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Superscript);\r\n}\r\n","import { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { HtmlSanitizer } from 'roosterjs-html-sanitizer';\r\n\r\n/**\r\n * Toggle header at selection\r\n * @param editor The editor instance\r\n * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to\r\n * the HTML header element &lt;H1&gt; to &lt;H6&gt;, 0 means no header\r\n * if passed in param is outside the range, will be rounded to nearest number in the range\r\n */\r\nexport default function toggleHeader(editor: Editor, level: number) {\r\n    level = Math.min(Math.max(Math.round(level), 0), 6);\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n\r\n        let wrapped = false;\r\n        editor.queryElements('H1,H2,H3,H4,H5,H6', QueryScope.OnSelection, header => {\r\n            if (!wrapped) {\r\n                editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, '<DIV>');\r\n                wrapped = true;\r\n            }\r\n\r\n            let div = editor.getDocument().createElement('div');\r\n            while (header.firstChild) {\r\n                div.appendChild(header.firstChild);\r\n            }\r\n            editor.replaceNode(header, div);\r\n        });\r\n\r\n        if (level > 0) {\r\n            let traverser = editor.getSelectionTraverser();\r\n            let blockElement = traverser ? traverser.currentBlockElement : null;\r\n            let sanitizer = new HtmlSanitizer({\r\n                styleCallbacks: {\r\n                    'font-size': () => false,\r\n                },\r\n            });\r\n            while (blockElement) {\r\n                let element = blockElement.collapseToSingleElement();\r\n                sanitizer.sanitize(element);\r\n                blockElement = traverser.getNextBlockElement();\r\n            }\r\n            editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, `<H${level}>`);\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\nimport { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\r\nimport { FontSizeChange, PluginEventType, PluginKeyboardEvent } from 'roosterjs-editor-types';\r\nimport {\r\n    changeFontSize,\r\n    toggleBold,\r\n    toggleItalic,\r\n    toggleUnderline,\r\n    toggleBullet,\r\n    toggleNumbering,\r\n} from 'roosterjs-editor-api';\r\n\r\ninterface ShortcutCommand {\r\n    winKey: number;\r\n    macKey: number;\r\n    action: (editor: Editor) => any;\r\n}\r\n\r\nfunction createCommand(winKey: number, macKey: number, action: (editor: Editor) => any) {\r\n    return {\r\n        winKey,\r\n        macKey,\r\n        action,\r\n    };\r\n}\r\n\r\nconst commands: ShortcutCommand[] = [\r\n    createCommand(Keys.Ctrl | Keys.B, Keys.Meta | Keys.B, toggleBold),\r\n    createCommand(Keys.Ctrl | Keys.I, Keys.Meta | Keys.I, toggleItalic),\r\n    createCommand(Keys.Ctrl | Keys.U, Keys.Meta | Keys.U, toggleUnderline),\r\n    createCommand(Keys.Ctrl | Keys.Z, Keys.Meta | Keys.Z, editor => editor.undo()),\r\n    createCommand(Keys.Ctrl | Keys.Y, Keys.Meta | Keys.Shift | Keys.Z, editor => editor.redo()),\r\n    createCommand(Keys.Ctrl | Keys.PERIOD, Keys.Meta | Keys.PERIOD, toggleBullet),\r\n    createCommand(Keys.Ctrl | Keys.FORWARDSLASH, Keys.Meta | Keys.FORWARDSLASH, toggleNumbering),\r\n    createCommand(\r\n        Keys.Ctrl | Keys.Shift | Keys.PERIOD,\r\n        Keys.Meta | Keys.Shift | Keys.PERIOD,\r\n        editor => changeFontSize(editor, FontSizeChange.Increase)\r\n    ),\r\n    createCommand(\r\n        Keys.Ctrl | Keys.Shift | Keys.COMMA,\r\n        Keys.Meta | Keys.Shift | Keys.COMMA,\r\n        editor => changeFontSize(editor, FontSizeChange.Decrease)\r\n    ),\r\n];\r\n\r\n/**\r\n * DefaultShortcut edit feature, provides shortcuts for the following features:\r\n * Ctrl/Meta+B: toggle bold style\r\n * Ctrl/Meta+I: toggle italic style\r\n * Ctrl/Meta+U: toggle underline style\r\n * Ctrl/Meta+Z: undo\r\n * Ctrl+Y/Meta+Shift+Z: redo\r\n * Ctrl/Meta+PERIOD: toggle bullet list\r\n * Ctrl/Meta+/: toggle numbering list\r\n * Ctrl/Meta+Shift+>: increase font size\r\n * Ctrl/Meta+Shift+<: decrease font size\r\n */\r\nexport const DefaultShortcut: ContentEditFeature = {\r\n    allowFunctionKeys: true,\r\n    keys: [Keys.B, Keys.I, Keys.U, Keys.Y, Keys.Z, Keys.COMMA, Keys.PERIOD, Keys.FORWARDSLASH],\r\n    shouldHandleEvent: cacheGetCommand,\r\n    handleEvent: (event, editor) => {\r\n        let command = cacheGetCommand(event);\r\n        if (command) {\r\n            command.action(editor);\r\n            event.rawEvent.preventDefault();\r\n            event.rawEvent.stopPropagation();\r\n        }\r\n    },\r\n};\r\n\r\nfunction cacheGetCommand(event: PluginKeyboardEvent) {\r\n    return cacheGetEventData(event, 'DEFAULT_SHORT_COMMAND', () => {\r\n        let e = event.rawEvent;\r\n        let key =\r\n            // Need to check ALT key to be false since in some language (e.g. Polski) uses AltGr to input some special charactors\r\n            // In that case, ctrlKey and altKey are both true in Edge, but we should not trigger any shortcut function here\r\n            event.eventType == PluginEventType.KeyDown && !e.altKey\r\n                ? e.which |\r\n                  (e.metaKey && Keys.Meta) |\r\n                  (e.shiftKey && Keys.Shift) |\r\n                  (e.ctrlKey && Keys.Ctrl)\r\n                : 0;\r\n        return key && commands.filter(cmd => (Browser.isMac ? cmd.macKey : cmd.winKey) == key)[0];\r\n    });\r\n}\r\n","import { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\r\nimport { PluginKeyboardEvent, PositionType } from 'roosterjs-editor-types';\r\nimport {\r\n    Browser,\r\n    fromHtml,\r\n    isPositionAtBeginningOf,\r\n    Position,\r\n    getTagOfNode,\r\n} from 'roosterjs-editor-dom';\r\n\r\n// Edge can sometimes lose current format when Enter to new line.\r\n// So here we add an extra SPAN for Edge to workaround this bug\r\nconst NEWLINE_HTML = Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>';\r\nconst CHILD_PARENT_TAG_MAP: { [childTag: string]: string } = {\r\n    TD: 'TABLE',\r\n    TH: 'TABLE',\r\n    LI: 'OL,UL',\r\n};\r\nconst CHILD_SELECTOR = Object.keys(CHILD_PARENT_TAG_MAP).join(',');\r\n\r\n/**\r\n * InsertLineBeforeStructuredNode edit feature, provides the ability to insert an empty line before\r\n * a structured element (bullet/numbering list, blockquote, table) if the element is at beginning of\r\n * document\r\n */\r\nexport const InsertLineBeforeStructuredNodeFeature: ContentEditFeature = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: cacheGetStructuredElement,\r\n    handleEvent: (event, editor) => {\r\n        let element = cacheGetStructuredElement(event, editor);\r\n        let div = fromHtml(NEWLINE_HTML, editor.getDocument())[0] as HTMLElement;\r\n        editor.addUndoSnapshot(() => {\r\n            element.parentNode.insertBefore(div, element);\r\n            // Select the new line when we are in table. This is the same behavior with Word\r\n            if (getTagOfNode(element) == 'TABLE') {\r\n                editor.select(new Position(div, PositionType.Begin).normalize());\r\n            }\r\n        });\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\nfunction cacheGetStructuredElement(event: PluginKeyboardEvent, editor: Editor) {\r\n    return cacheGetEventData(event, 'FIRST_STRUCTURE', () => {\r\n        // Provide a chance to keep browser default behavior by pressing SHIFT\r\n        let element = event.rawEvent.shiftKey ? null : editor.getElementAtCursor(CHILD_SELECTOR);\r\n\r\n        if (element) {\r\n            let range = editor.getSelectionRange();\r\n            if (\r\n                range &&\r\n                range.collapsed &&\r\n                isPositionAtBeginningOf(Position.getStart(range), element) &&\r\n                !editor.getBodyTraverser(element).getPreviousBlockElement()\r\n            ) {\r\n                return editor.getElementAtCursor(CHILD_PARENT_TAG_MAP[getTagOfNode(element)]);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    });\r\n}\r\n","import { ContentEditFeature, Keys } from 'roosterjs-editor-core';\r\nimport { isRtl, Position } from 'roosterjs-editor-dom';\r\n\r\nexport const NoCycleCursorMove: ContentEditFeature = {\r\n    keys: [Keys.LEFT, Keys.RIGHT],\r\n    allowFunctionKeys: true,\r\n    shouldHandleEvent: (event, editor, ctrlOrMeta) => {\r\n        let range: Range;\r\n        let position: Position;\r\n\r\n        if (\r\n            !ctrlOrMeta ||\r\n            !(range = editor.getSelectionRange()) ||\r\n            !range.collapsed ||\r\n            !(position = Position.getStart(range)) ||\r\n            !editor.isPositionAtBeginning(position)\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        let rtl = isRtl(position.element);\r\n        let rawEvent = event.rawEvent;\r\n\r\n        return (!rtl && rawEvent.which == Keys.LEFT) || (rtl && rawEvent.which == Keys.RIGHT);\r\n    },\r\n    handleEvent: event => {\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n","import { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\r\nimport { contains, getTagOfNode, isVoidHtmlElement, Position, VTable } from 'roosterjs-editor-dom';\r\nimport { NodeType, PluginEvent, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table\r\n */\r\nexport const TabInTable: ContentEditFeature = {\r\n    keys: [Keys.TAB],\r\n    shouldHandleEvent: cacheGetTableCell,\r\n    handleEvent: (event, editor) => {\r\n        let shift = event.rawEvent.shiftKey;\r\n        let td = cacheGetTableCell(event, editor);\r\n        for (\r\n            let vtable = new VTable(td),\r\n                step = shift ? -1 : 1,\r\n                row = vtable.row,\r\n                col = vtable.col + step;\r\n            ;\r\n            col += step\r\n        ) {\r\n            if (col < 0 || col >= vtable.cells[row].length) {\r\n                row += step;\r\n                if (row < 0 || row >= vtable.cells.length) {\r\n                    editor.select(vtable.table, shift ? PositionType.Before : PositionType.After);\r\n                    break;\r\n                }\r\n                col = shift ? vtable.cells[row].length - 1 : 0;\r\n            }\r\n            let cell = vtable.getCell(row, col);\r\n            if (cell.td) {\r\n                editor.select(cell.td, PositionType.Begin);\r\n                break;\r\n            }\r\n        }\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\n/**\r\n * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN\r\n * in table\r\n */\r\nexport const UpDownInTable: ContentEditFeature = {\r\n    keys: [Keys.UP, Keys.DOWN],\r\n    shouldHandleEvent: cacheGetTableCell,\r\n    handleEvent: (event, editor) => {\r\n        let td = cacheGetTableCell(event, editor);\r\n        let vtable = new VTable(td);\r\n        let isUp = event.rawEvent.which == Keys.UP;\r\n        let step = isUp ? -1 : 1;\r\n        let targetTd: HTMLTableCellElement = null;\r\n        let hasShiftKey = event.rawEvent.shiftKey;\r\n        let { anchorNode, anchorOffset } = editor.getSelection();\r\n\r\n        for (let row = vtable.row; row >= 0 && row < vtable.cells.length; row += step) {\r\n            let cell = vtable.getCell(row, vtable.col);\r\n            if (cell.td && cell.td != td) {\r\n                targetTd = cell.td;\r\n                break;\r\n            }\r\n        }\r\n\r\n        editor.runAsync(() => {\r\n            let newContainer = editor.getElementAtCursor();\r\n            if (\r\n                contains(vtable.table, newContainer) &&\r\n                !contains(td, newContainer, true /*treatSameNodeAsContain*/)\r\n            ) {\r\n                let newPos = targetTd\r\n                    ? new Position(targetTd, PositionType.Begin)\r\n                    : new Position(vtable.table, isUp ? PositionType.Before : PositionType.After);\r\n                if (hasShiftKey) {\r\n                    newPos =\r\n                        newPos.node.nodeType == NodeType.Element && isVoidHtmlElement(newPos.node)\r\n                            ? new Position(\r\n                                  newPos.node,\r\n                                  newPos.isAtEnd ? PositionType.After : PositionType.Before\r\n                              )\r\n                            : newPos;\r\n                    editor\r\n                        .getSelection()\r\n                        .setBaseAndExtent(anchorNode, anchorOffset, newPos.node, newPos.offset);\r\n                } else {\r\n                    editor.select(newPos);\r\n                }\r\n            }\r\n        });\r\n    },\r\n};\r\n\r\nfunction cacheGetTableCell(event: PluginEvent, editor: Editor): HTMLTableCellElement {\r\n    return cacheGetEventData(event, 'TABLECELL_FOR_TABLE_FEATURES', () => {\r\n        let pos = editor.getFocusedPosition();\r\n        let firstTd = pos && editor.getElementAtCursor('TD,TH,LI', pos.node);\r\n        return (\r\n            firstTd && (getTagOfNode(firstTd) == 'LI' ? null : (firstTd as HTMLTableCellElement))\r\n        );\r\n    });\r\n}\r\n","import { isHTMLOListElement } from 'roosterjs-cross-window';\r\nimport { setIndentation, toggleBullet, toggleNumbering } from 'roosterjs-editor-api';\r\nimport {\r\n    cacheGetContentSearcher,\r\n    cacheGetElementAtCursor,\r\n    Editor,\r\n    ContentEditFeature,\r\n    GenericContentEditFeature,\r\n    Keys,\r\n} from 'roosterjs-editor-core';\r\nimport {\r\n    ContentChangedEvent,\r\n    Indentation,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    Browser,\r\n    Position,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    isPositionAtBeginningOf,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * IndentWhenTab edit feature, provides the ability to indent current list when user press TAB\r\n */\r\nexport const IndentWhenTab: ContentEditFeature = {\r\n    keys: [Keys.TAB],\r\n    shouldHandleEvent: (event, editor) =>\r\n        !event.rawEvent.shiftKey && cacheGetListElement(event, editor),\r\n    handleEvent: (event, editor) => {\r\n        setIndentation(editor, Indentation.Increase);\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\n/**\r\n * OutdentWhenShiftTab edit feature, provides the ability to outdent current list when user press Shift+TAB\r\n */\r\nexport const OutdentWhenShiftTab: ContentEditFeature = {\r\n    keys: [Keys.TAB],\r\n    shouldHandleEvent: (event, editor) =>\r\n        event.rawEvent.shiftKey && cacheGetListElement(event, editor),\r\n    handleEvent: (event, editor) => {\r\n        setIndentation(editor, Indentation.Decrease);\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\n/**\r\n * MergeInNewLine edit feature, provides the ability to merge current line into a new line when user press\r\n * BACKSPACE at beginning of a list item\r\n */\r\nexport const MergeInNewLine: ContentEditFeature = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\r\n        let range = editor.getSelectionRange();\r\n        return li && range && isPositionAtBeginningOf(Position.getStart(range), li);\r\n    },\r\n    handleEvent: (event, editor) => {\r\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\r\n        if (li.previousSibling) {\r\n            editor.runAsync(() => {\r\n                let br = editor.getDocument().createElement('BR');\r\n                editor.insertNode(br);\r\n                editor.select(br, PositionType.After);\r\n            });\r\n        } else {\r\n            toggleListAndPreventDefault(event, editor);\r\n        }\r\n    },\r\n};\r\n\r\n/**\r\n * OutdentWhenBackOn1stEmptyLine edit feature, provides the ability to outdent current item if user press\r\n * BACKSPACE at the first and empty line of a list\r\n */\r\nexport const OutdentWhenBackOn1stEmptyLine: ContentEditFeature = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\r\n        return li && isNodeEmpty(li) && !li.previousSibling;\r\n    },\r\n    handleEvent: toggleListAndPreventDefault,\r\n};\r\n\r\n/**\r\n * OutdentWhenEnterOnEmptyLine edit feature, provides the ability to outdent current item if user press\r\n * ENTER at the beginning of an empty line of a list\r\n */\r\nexport const OutdentWhenEnterOnEmptyLine: ContentEditFeature = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\r\n        return !event.rawEvent.shiftKey && li && isNodeEmpty(li);\r\n    },\r\n    handleEvent: (event, editor) => {\r\n        editor.performAutoComplete(() => toggleListAndPreventDefault(event, editor));\r\n    },\r\n};\r\n\r\n/**\r\n * AutoBullet edit feature, provides the ablility to automatically convert current line into a list.\r\n * When user input \"1. \", convert into a numbering list\r\n * When user input \"- \" or \"* \", convert into a bullet list\r\n */\r\nexport const AutoBullet: ContentEditFeature = {\r\n    keys: [Keys.SPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        if (!cacheGetListElement(event, editor)) {\r\n            let searcher = cacheGetContentSearcher(event, editor);\r\n            let textBeforeCursor = searcher.getSubStringBefore(3);\r\n\r\n            // Auto list is triggered if:\r\n            // 1. Text before cursor exactly mathces '*', '-' or '1.'\r\n            // 2. There's no non-text inline entities before cursor\r\n            return (\r\n                ['*', '-', '1.'].indexOf(textBeforeCursor) >= 0 &&\r\n                !searcher.getNearestNonTextInlineElement()\r\n            );\r\n        }\r\n        return false;\r\n    },\r\n    handleEvent: (event, editor) => {\r\n        editor.runAsync(() => {\r\n            editor.performAutoComplete(() => {\r\n                let searcher = editor.getContentSearcherOfCursor();\r\n                let textBeforeCursor = searcher.getSubStringBefore(3);\r\n                let rangeToDelete = searcher.getRangeFromText(\r\n                    textBeforeCursor,\r\n                    true /*exactMatch*/\r\n                );\r\n\r\n                if (rangeToDelete) {\r\n                    rangeToDelete.deleteContents();\r\n                }\r\n\r\n                // If not explicitly insert br, Chrome/Safari/IE will operate on the previous line\r\n                let tempBr = editor.getDocument().createElement('BR');\r\n                if (Browser.isChrome || Browser.isSafari || Browser.isIE11OrGreater) {\r\n                    editor.insertNode(tempBr);\r\n                }\r\n\r\n                if (textBeforeCursor.indexOf('1.') == 0) {\r\n                    toggleNumbering(editor);\r\n                } else {\r\n                    toggleBullet(editor);\r\n                }\r\n\r\n                editor.deleteNode(tempBr);\r\n            });\r\n        });\r\n    },\r\n};\r\n\r\n/**\r\n * Get an instance of SmartOrderedList edit feature. This feature provides the ability to use different\r\n * number style for different level of numbering list.\r\n * @param styleList The list of number styles used for this feature.\r\n * See https://www.w3schools.com/cssref/pr_list-style-type.asp for more information\r\n */\r\nexport function getSmartOrderedList(\r\n    styleList: string[]\r\n): GenericContentEditFeature<ContentChangedEvent> {\r\n    return {\r\n        keys: [Keys.CONTENTCHANGED], // Triggered by ContentChangedEvent\r\n        shouldHandleEvent: (event, editor) => isHTMLOListElement(event.data),\r\n        handleEvent: (event, editor) => {\r\n            let ol = event.data as HTMLOListElement;\r\n            let parentOl = editor.getElementAtCursor('OL', ol.parentNode) as HTMLOListElement;\r\n            if (parentOl) {\r\n                // The style list must has at least one value. If no value is passed in, fallback to decimal\r\n                let styles = styleList && styleList.length > 0 ? styleList : ['decimal'];\r\n                ol.style.listStyle =\r\n                    styles[(styles.indexOf(parentOl.style.listStyle) + 1) % styles.length];\r\n            }\r\n        },\r\n    };\r\n}\r\n\r\nfunction toggleListAndPreventDefault(event: PluginKeyboardEvent, editor: Editor) {\r\n    let listInfo = cacheGetListElement(event, editor);\r\n    if (listInfo) {\r\n        let listElement = listInfo[0];\r\n        let tag = getTagOfNode(listElement);\r\n        if (tag == 'UL') {\r\n            toggleBullet(editor);\r\n        } else if (tag == 'OL') {\r\n            toggleNumbering(editor);\r\n        }\r\n        editor.focus();\r\n        event.rawEvent.preventDefault();\r\n    }\r\n}\r\n\r\nfunction cacheGetListElement(event: PluginKeyboardEvent, editor: Editor) {\r\n    let li = cacheGetElementAtCursor(editor, event, 'LI,TABLE');\r\n    let listElement = li && getTagOfNode(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);\r\n    return listElement ? [listElement, li] : null;\r\n}\r\n","import { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\r\nimport { PluginKeyboardEvent, PositionType } from 'roosterjs-editor-types';\r\nimport {\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst QUOTE_TAG = 'BLOCKQUOTE';\r\nconst STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');\r\n\r\n/**\r\n * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when\r\n * user press BACKSPACE on first and empty line of a BLOCKQUOTE\r\n */\r\nexport const UnquoteWhenBackOnEmpty1stLine: ContentEditFeature = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let childOfQuote = cacheGetQuoteChild(event, editor);\r\n        return childOfQuote && isNodeEmpty(childOfQuote) && !childOfQuote.previousSibling;\r\n    },\r\n    handleEvent: splitQuote,\r\n};\r\n\r\n/**\r\n * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when\r\n * user press ENTER on an empty line of a BLOCKQUOTE\r\n */\r\nexport const UnquoteWhenEnterOnEmptyLine: ContentEditFeature = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let childOfQuote = cacheGetQuoteChild(event, editor);\r\n        let shift = event.rawEvent.shiftKey;\r\n        return !shift && childOfQuote && isNodeEmpty(childOfQuote);\r\n    },\r\n    handleEvent: (event, editor) => editor.performAutoComplete(() => splitQuote(event, editor)),\r\n};\r\n\r\nfunction cacheGetQuoteChild(event: PluginKeyboardEvent, editor: Editor): Node {\r\n    return cacheGetEventData(event, 'QUOTE_CHILD', () => {\r\n        let quote = editor.getElementAtCursor(STRUCTURED_TAGS);\r\n        if (quote && getTagOfNode(quote) == QUOTE_TAG) {\r\n            let pos = editor.getFocusedPosition();\r\n            let block = pos && editor.getBlockElementAtNode(pos.normalize().node);\r\n            if (block) {\r\n                let node =\r\n                    block.getStartNode() == quote\r\n                        ? block.getStartNode()\r\n                        : block.collapseToSingleElement();\r\n                return isNodeEmpty(node) ? node : null;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    });\r\n}\r\n\r\nfunction splitQuote(event: PluginKeyboardEvent, editor: Editor) {\r\n    editor.addUndoSnapshot(() => {\r\n        let childOfQuote = cacheGetQuoteChild(event, editor);\r\n        let parent: Node;\r\n        if (getTagOfNode(childOfQuote) == QUOTE_TAG) {\r\n            childOfQuote = wrap(toArray(childOfQuote.childNodes));\r\n        }\r\n        parent = splitBalancedNodeRange(childOfQuote);\r\n        unwrap(parent);\r\n        editor.select(childOfQuote, PositionType.Begin);\r\n    });\r\n    event.rawEvent.preventDefault();\r\n}\r\n","import buildClipboardData from './buildClipboardData';\r\nimport fragmentHandler from './fragmentHandler';\r\nimport textToHtml from './textToHtml';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport { getFormatState } from 'roosterjs-editor-api';\r\nimport { insertImage } from 'roosterjs-editor-api';\r\nimport {\r\n    AttributeCallbackMap,\r\n    getInheritableStyles,\r\n    HtmlSanitizer,\r\n    htmlToDom,\r\n} from 'roosterjs-html-sanitizer';\r\nimport {\r\n    BeforePasteEvent,\r\n    ChangeSource,\r\n    ClipboardData,\r\n    DefaultFormat,\r\n    NodeType,\r\n    PasteOption,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    applyFormat,\r\n    fromHtml,\r\n    getFirstLeafNode,\r\n    getNextLeafSibling,\r\n    Position,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Paste plugin, handles onPaste event and paste content into editor\r\n */\r\nexport default class Paste implements EditorPlugin {\r\n    private editor: Editor;\r\n    private pasteDisposer: () => void;\r\n    private sanitizer: HtmlSanitizer;\r\n\r\n    /**\r\n     * Create an instance of Paste\r\n     * @param preserved Not used. Preserved parameter only used for compatibility with old code\r\n     * @param attributeCallbacks A set of callbacks to help handle html attribute during sanitization\r\n     */\r\n    constructor(preserved?: any, attributeCallbacks?: AttributeCallbackMap) {\r\n        this.sanitizer = new HtmlSanitizer({\r\n            attributeCallbacks,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Paste';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.pasteDisposer = editor.addDomEventHandler('paste', this.onPaste);\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.pasteDisposer();\r\n        this.pasteDisposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    private onPaste = (event: Event) => {\r\n        buildClipboardData(<ClipboardEvent>event, this.editor, items => {\r\n            this.pasteOriginal({\r\n                snapshotBeforePaste: null,\r\n                originalFormat: this.getCurrentFormat(),\r\n                types: items.types,\r\n                image: items.image,\r\n                text: items.text,\r\n                rawHtml: items.html,\r\n                html: items.html ? this.sanitizeHtml(items.html) : textToHtml(items.text),\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Paste into editor using passed in clipboardData with original format\r\n     * @param clipboardData The clipboardData to paste\r\n     */\r\n    public pasteOriginal(clipboardData: ClipboardData) {\r\n        this.paste(clipboardData, this.detectPasteOption(clipboardData));\r\n    }\r\n\r\n    /**\r\n     * Paste plain text into editor using passed in clipboardData\r\n     * @param clipboardData The clipboardData to paste\r\n     */\r\n    public pasteText(clipboardData: ClipboardData) {\r\n        this.paste(clipboardData, PasteOption.PasteText);\r\n    }\r\n\r\n    /**\r\n     * Paste into editor using passed in clipboardData with curent format\r\n     * @param clipboardData The clipboardData to paste\r\n     */\r\n    public pasteAndMergeFormat(clipboardData: ClipboardData) {\r\n        this.paste(clipboardData, this.detectPasteOption(clipboardData), true /*mergeFormat*/);\r\n    }\r\n\r\n    private detectPasteOption(clipboardData: ClipboardData): PasteOption {\r\n        return clipboardData.text || !clipboardData.image\r\n            ? PasteOption.PasteHtml\r\n            : PasteOption.PasteImage;\r\n    }\r\n\r\n    private paste(\r\n        clipboardData: ClipboardData,\r\n        pasteOption: PasteOption,\r\n        mergeCurrentFormat?: boolean\r\n    ) {\r\n        let document = this.editor.getDocument();\r\n        let fragment = document.createDocumentFragment();\r\n\r\n        if (pasteOption == PasteOption.PasteHtml) {\r\n            let html = clipboardData.html;\r\n            let nodes = fromHtml(html, document);\r\n\r\n            for (let node of nodes) {\r\n                if (mergeCurrentFormat) {\r\n                    this.applyToElements(node, this.applyFormatting(clipboardData.originalFormat, this.editor.isDarkMode()));\r\n                }\r\n                fragment.appendChild(node);\r\n            }\r\n        }\r\n\r\n        let event = this.editor.triggerPluginEvent(\r\n            PluginEventType.BeforePaste,\r\n            {\r\n                clipboardData,\r\n                fragment,\r\n                pasteOption,\r\n            },\r\n            true /*broadcast*/\r\n        );\r\n        this.internalPaste(event);\r\n    }\r\n\r\n    private internalPaste(event: BeforePasteEvent) {\r\n        let { clipboardData, fragment, pasteOption } = event;\r\n        this.editor.focus();\r\n        this.editor.addUndoSnapshot(() => {\r\n            if (clipboardData.snapshotBeforePaste == null) {\r\n                clipboardData.snapshotBeforePaste = this.editor.getContent(\r\n                    false /*triggerExtractContentEvent*/,\r\n                    true /*markSelection*/\r\n                );\r\n            } else {\r\n                this.editor.setContent(clipboardData.snapshotBeforePaste);\r\n            }\r\n\r\n            switch (pasteOption) {\r\n                case PasteOption.PasteHtml:\r\n                    this.editor.insertNode(fragment);\r\n                    break;\r\n\r\n                case PasteOption.PasteText:\r\n                    let html = textToHtml(clipboardData.text);\r\n                    this.editor.insertContent(html);\r\n                    break;\r\n\r\n                case PasteOption.PasteImage:\r\n                    insertImage(this.editor, clipboardData.image);\r\n                    break;\r\n            }\r\n\r\n            return clipboardData;\r\n        }, ChangeSource.Paste);\r\n    }\r\n\r\n    private applyFormatting = (format: DefaultFormat, isDarkMode: boolean) => (element: HTMLElement) => {\r\n        applyFormat(element, format, isDarkMode);\r\n    }\r\n\r\n    private applyToElements(node: Node, elementTransform: (element: HTMLElement) => void) {\r\n        let leaf = getFirstLeafNode(node);\r\n        let parents: HTMLElement[] = [];\r\n        while (leaf) {\r\n            if (\r\n                leaf.nodeType == NodeType.Text &&\r\n                leaf.parentNode &&\r\n                parents.indexOf(<HTMLElement>leaf.parentNode) < 0\r\n            ) {\r\n                parents.push(<HTMLElement>leaf.parentNode);\r\n            }\r\n            leaf = getNextLeafSibling(node, leaf);\r\n        }\r\n        parents.push(<HTMLElement>node);\r\n        for (let parent of parents) {\r\n            elementTransform(parent);\r\n        }\r\n    }\r\n\r\n    private getCurrentFormat(): DefaultFormat {\r\n        let format = getFormatState(this.editor);\r\n        return format\r\n            ? {\r\n                fontFamily: format.fontName,\r\n                fontSize: format.fontSize,\r\n                textColor: format.textColor,\r\n                backgroundColor: format.backgroundColor,\r\n                bold: format.isBold,\r\n                italic: format.isItalic,\r\n                underline: format.isUnderline,\r\n            }\r\n            : {};\r\n    }\r\n\r\n    private sanitizeHtml(html: string): string {\r\n        let doc = htmlToDom(html, true /*preserveFragmentOnly*/, fragmentHandler);\r\n        if (doc && doc.body) {\r\n            this.sanitizer.convertGlobalCssToInlineCss(doc);\r\n\r\n            let range = this.editor.getSelectionRange();\r\n            let element = range && Position.getStart(range).normalize().element;\r\n            let currentStyles = getInheritableStyles(element);\r\n            this.sanitizer.sanitize(doc.body, currentStyles);\r\n            return doc.body.innerHTML;\r\n        }\r\n        return '';\r\n    }\r\n}\r\n","import { ClipboardItems, ContentPosition } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { extractClipboardEvent, fromHtml } from 'roosterjs-editor-dom';\r\n\r\nconst CONTAINER_HTML =\r\n    '<div contenteditable style=\"width: 1px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text\"></div>';\r\n\r\n/**\r\n * Build ClipboardData from a paste event\r\n * @param event The paste event\r\n * @param editor The editor\r\n * @param callback Callback function when data is ready\r\n */\r\nexport default function buildClipboardData(\r\n    event: ClipboardEvent,\r\n    editor: Editor,\r\n    callback: (items: ClipboardItems) => void\r\n) {\r\n    extractClipboardEvent(event, items => {\r\n        if (items.html === undefined) {\r\n            retrieveHtmlViaTempDiv(editor, html => {\r\n                items.html = html;\r\n                callback(items);\r\n            });\r\n        } else {\r\n            callback(items);\r\n        }\r\n    });\r\n}\r\n\r\nfunction retrieveHtmlViaTempDiv(editor: Editor, callback: (html: string) => void) {\r\n    // cache original selection range in editor\r\n    let originalSelectionRange = editor.getSelectionRange();\r\n    let tempDiv = getTempDivForPaste(editor);\r\n    tempDiv.focus();\r\n\r\n    editor.runAsync(() => {\r\n        // restore original selection range in editor\r\n        editor.select(originalSelectionRange);\r\n        callback(tempDiv.innerHTML);\r\n        tempDiv.style.display = 'none';\r\n        tempDiv.innerHTML = '';\r\n    });\r\n}\r\n\r\nfunction getTempDivForPaste(editor: Editor): HTMLElement {\r\n    let tempDiv = editor.getCustomData(\r\n        'PasteDiv',\r\n        () => {\r\n            let pasteDiv = fromHtml(CONTAINER_HTML, editor.getDocument())[0] as HTMLElement;\r\n            editor.insertNode(pasteDiv, {\r\n                position: ContentPosition.Outside,\r\n                updateCursor: false,\r\n                replaceSelection: false,\r\n                insertOnNewLine: false,\r\n            });\r\n            return pasteDiv;\r\n        },\r\n        pasteDiv => {\r\n            pasteDiv.parentNode.removeChild(pasteDiv);\r\n        }\r\n    );\r\n    tempDiv.style.display = '';\r\n    return tempDiv;\r\n}\r\n","import convertPastedContentFromExcel from './excelConverter/convertPastedContentFromExcel';\r\nimport convertPastedContentFromWord from './wordConverter/convertPastedContentFromWord';\r\nimport convertPastedContentFromWordOnline, { isWordOnlineWithList } from './officeOnlineConverter/convertPastedContentFromWordOnline';\r\nimport { WAC_IDENTIFING_SELECTOR } from './officeOnlineConverter/constants';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { splitWithFragment } from 'roosterjs-html-sanitizer';\r\n\r\nconst WORD_ATTRIBUTE_NAME = 'xmlns:w';\r\nconst WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';\r\nconst EXCEL_ATTRIBUTE_NAME = 'xmlns:x';\r\nconst EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';\r\n\r\nconst LAST_TD_END_REGEX = /<\\/\\s*td\\s*>((?!<\\/\\s*tr\\s*>)[\\s\\S])*$/i;\r\nconst LAST_TR_END_REGEX = /<\\/\\s*tr\\s*>((?!<\\/\\s*table\\s*>)[\\s\\S])*$/i;\r\nconst LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;\r\nconst LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;\r\n\r\nexport default function fragmentHandler(doc: HTMLDocument, source: string) {\r\n    let [html, before] = splitWithFragment(source);\r\n    let firstNode = doc && doc.body && (doc.querySelector('html') as HTMLElement);\r\n    if (getTagOfNode(firstNode) == 'HTML') {\r\n        let wacListElements: NodeListOf<Element>;\r\n        if (firstNode.getAttribute(WORD_ATTRIBUTE_NAME) == WORD_ATTRIBUTE_VALUE) {\r\n            // Handle HTML copied from MS Word\r\n            doc.body.innerHTML = html;\r\n            convertPastedContentFromWord(doc);\r\n        } else if ((wacListElements = firstNode.querySelectorAll(WAC_IDENTIFING_SELECTOR))[0]) {\r\n            // Once it is known that the document is from WAC\r\n            // We need to remove the display property and margin from all the list item\r\n            wacListElements.forEach((el: HTMLElement) => {\r\n                el.style.display = null;\r\n                el.style.margin = null;\r\n            });\r\n            // call conversion function if the pasted content is from word online and\r\n            // has list element in the pasted content.\r\n            if (isWordOnlineWithList(firstNode)) {\r\n                convertPastedContentFromWordOnline(doc);\r\n            }\r\n        } else if (firstNode.getAttribute(EXCEL_ATTRIBUTE_NAME) == EXCEL_ATTRIBUTE_VALUE) {\r\n            // Handle HTML copied from MS Excel\r\n            if (html.match(LAST_TD_END_REGEX)) {\r\n                let trMatch = before.match(LAST_TR_REGEX);\r\n                let tr = trMatch ? trMatch[0] : '<TR>';\r\n                html = tr + html + '</TR>';\r\n            }\r\n            if (html.match(LAST_TR_END_REGEX)) {\r\n                let tableMatch = before.match(LAST_TABLE_REGEX);\r\n                let table = tableMatch ? tableMatch[0] : '<TABLE>';\r\n                html = table + html + '</TABLE>';\r\n            }\r\n            doc.body.innerHTML = html;\r\n            convertPastedContentFromExcel(doc);\r\n        } else {\r\n            // Handle HTML copied from other places\r\n            doc.body.innerHTML = html;\r\n        }\r\n    }\r\n}\r\n","import { HtmlSanitizer } from 'roosterjs-html-sanitizer';\r\n\r\n/**\r\n * Convert pasted content from Excel, add borders when source doc doesn't have a border\r\n * @param doc HTML Document which contains the content from Excel\r\n */\r\nexport default function convertPastedContentFromExcel(doc: HTMLDocument) {\r\n    let sanitizer = new HtmlSanitizer({\r\n        styleCallbacks: {\r\n            border: (value, element) => value != 'none' || element.style.border != 'none',\r\n        },\r\n        additionalAllowAttributes: ['class'],\r\n    });\r\n    sanitizer.sanitize(doc.body);\r\n\r\n    let styleNode = doc.createElement('style');\r\n    doc.body.appendChild(styleNode);\r\n    styleNode.innerHTML = 'td {border: solid 1px #d4d4d4}';\r\n    sanitizer.convertGlobalCssToInlineCss(doc);\r\n}\r\n","import { createWordConverter } from './wordConverter';\r\nimport { createWordConverterArguments } from './WordConverterArguments';\r\nimport { HtmlSanitizer } from 'roosterjs-html-sanitizer';\r\nimport { processNodeConvert, processNodesDiscovery } from './converterUtils';\r\n\r\n/** Converts all the Word generated list items in the specified node into standard HTML UL and OL tags */\r\nexport default function convertPastedContentFromWord(doc: HTMLDocument) {\r\n    let sanitizer = new HtmlSanitizer({\r\n        elementCallbacks: {\r\n            ['O:P']: element => element.innerHTML == '&nbsp;', // Preserve <o:p> when its innerHTML is \"&nbsp;\" to avoid dropping an empty line\r\n        },\r\n        additionalAllowAttributes: ['class'],\r\n    });\r\n    sanitizer.sanitize(doc.body);\r\n\r\n    let wordConverter = createWordConverter();\r\n\r\n    // First find all the nodes that we need to check for list item information\r\n    // This call will return all the p and header elements under the root node.. These are the elements that\r\n    // Word uses a list items, so we'll only process them and avoid walking the whole tree.\r\n    let elements = doc.querySelectorAll('p');\r\n    if (elements.length > 0) {\r\n        wordConverter.wordConverterArgs = createWordConverterArguments(elements);\r\n        if (processNodesDiscovery(wordConverter)) {\r\n            processNodeConvert(wordConverter);\r\n        }\r\n    }\r\n}\r\n","import CustomData, { createCustomData } from './CustomData';\r\nimport WordConverterArguments from './WordConverterArguments';\r\n\r\n/** Processes HTML generated by Word, converting Word Lists into standard HTML UL and OL tags */\r\nexport default interface WordConverter {\r\n    /** Next unique id to be assigned to a list */\r\n    nextUniqueId: number;\r\n\r\n    /** Number of bullets converted */\r\n    numBulletsConverted: number;\r\n\r\n    /** Number of numbering converted */\r\n    numNumberedConverted: number;\r\n\r\n    /** The structure that records the status of the conversion */\r\n    wordConverterArgs: WordConverterArguments;\r\n\r\n    /** Custom data storage for list items */\r\n    customData: CustomData;\r\n}\r\n\r\n/** create an empty WordConverter */\r\nexport function createWordConverter(): WordConverter {\r\n    return {\r\n        nextUniqueId: 1,\r\n        numBulletsConverted: 0,\r\n        numNumberedConverted: 0,\r\n        wordConverterArgs: null,\r\n        customData: createCustomData(),\r\n    };\r\n}\r\n","import LevelLists, { createLevelLists } from './LevelLists';\r\nimport ListItemMetadata from './ListItemMetadata';\r\nimport ListMetadata from './ListMetadata';\r\n\r\n/** Contains the state of the WordConverter when called back after yielding */\r\nexport default interface WordConverterArguments {\r\n    /** The list of element nodes being processed */\r\n    nodes: NodeListOf<HTMLElement>;\r\n\r\n    /** The index of the element currently being processed */\r\n    currentIndex: number;\r\n\r\n    /**\r\n     * Holds the metadata for all the lists we have found\r\n     * key: unique list id, value: list metadata\r\n     */\r\n    lists: { [key: string]: ListMetadata };\r\n\r\n    /**\r\n     * Stores the list item metatada of the items we\r\n     * have found that need to be converted\r\n     */\r\n    listItems: ListItemMetadata[];\r\n\r\n    /**\r\n     * This array holds the list id of the lists we are processing\r\n     * that are next to each other.. This list will be used to determine\r\n     * if list items are next to each other or if they are separated...\r\n     * Separated items are ignored from the conversion\r\n     */\r\n\r\n    currentListIdsByLevels: LevelLists[];\r\n\r\n    /** Remembers the item that was last processed  */\r\n    lastProcessedItem: HTMLElement;\r\n}\r\n\r\n/** create an empty WordConverterArguments */\r\nexport function createWordConverterArguments(\r\n    nodes: NodeListOf<HTMLElement>\r\n): WordConverterArguments {\r\n    return {\r\n        nodes: nodes,\r\n        currentIndex: 0,\r\n        lists: {},\r\n        listItems: [],\r\n        currentListIdsByLevels: [createLevelLists()],\r\n        lastProcessedItem: null,\r\n    };\r\n}\r\n","import ListItemMetadata from './ListItemMetadata';\r\nimport ListMetadata from './ListMetadata';\r\nimport WordConverter from './wordConverter';\r\nimport WordConverterArguments from './WordConverterArguments';\r\nimport { createLevelLists } from './LevelLists';\r\nimport { getObject, setObject } from './CustomData';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/** Word list metadata style name */\r\nconst LOOKUP_DEPTH = 5;\r\n\r\n/** Name for the word list id property in the custom data */\r\nconst UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';\r\n\r\n/** Word list metadata style name */\r\nconst MSO_LIST_STYLE_NAME = 'mso-list';\r\n\r\n/** Regular expression to match line breaks */\r\nconst LINE_BREAKS = /[\\n|\\r]/gi;\r\n\r\n/**\r\n * Handles the pass 1: Discovery\r\n * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.\r\n * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these\r\n * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.\r\n */\r\nexport function processNodesDiscovery(wordConverter: WordConverter): boolean {\r\n    let args = wordConverter.wordConverterArgs;\r\n    while (args.currentIndex < args.nodes.length) {\r\n        let node = args.nodes.item(args.currentIndex);\r\n\r\n        // Try to get the list metadata for the specified node\r\n        let itemMetadata = getListItemMetadata(node);\r\n        if (itemMetadata) {\r\n            let levelInfo =\r\n                args.currentListIdsByLevels[itemMetadata.level - 1] || createLevelLists();\r\n            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;\r\n\r\n            // We need to drop some list information if this is not an item next to another\r\n            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {\r\n                // This list item is not next to the previous one. This means that there is some content in between them\r\n                // so we need to reset our list of list ids per level\r\n                resetCurrentLists(args);\r\n            }\r\n\r\n            // Get the list metadata for the list that will hold this item\r\n            let listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];\r\n            if (!listMetadata) {\r\n                // Get the first item fake bullet.. This will be used later to check what is the right type of list\r\n                let firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\r\n\r\n                // This is a the first item of a list.. We'll create the list metadata using the information\r\n                // we already have from this first item\r\n                listMetadata = {\r\n                    numberOfItems: 0,\r\n                    uniqueListId: wordConverter.nextUniqueId++,\r\n                    firstFakeBullet: firstFakeBullet,\r\n\r\n                    // If the bullet we got is emtpy or not found, we ignore the list out.. this means\r\n                    // that this is not an item we need to convert of that the format doesn't match what\r\n                    // we are expecting\r\n                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,\r\n\r\n                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second\r\n                    // item, we'll perform a better comparasion, but for one item lists, this will be check that will determine the list type\r\n                    tagName: getFakeBulletTagName(firstFakeBullet),\r\n                };\r\n                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;\r\n                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;\r\n            } else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {\r\n                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet\r\n                // items we have an decide if we create ordered or unordered lists based on this.\r\n                // This is the best way we can do this since we cannot read the metadata that Word\r\n                // puts in the head of the HTML...\r\n                let secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\r\n                listMetadata.tagName =\r\n                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';\r\n            }\r\n\r\n            // Set the unique id to the list\r\n            itemMetadata.uniqueListId = listMetadata.uniqueListId;\r\n\r\n            // Check if we need to ignore this list... we'll either know already that we need to ignore\r\n            // it, or we'll know it because the previous list items are not next to this one\r\n            if (\r\n                listMetadata.ignore ||\r\n                (listMetadata.tagName == 'OL' &&\r\n                    listMetadata.numberOfItems > 0 &&\r\n                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)\r\n            ) {\r\n                // We need to ignore this item... and we also need to forget about the lists that\r\n                // are not at the root level\r\n                listMetadata.ignore = true;\r\n                args.currentListIdsByLevels[0].currentUniqueListId = -1;\r\n                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);\r\n            } else {\r\n                // This is an item we don't need to ignore... If added lists deep under this one before\r\n                // we'll drop their ids from the list of ids per level.. this is because this list item\r\n                // breaks the deeper lists.\r\n                if (args.currentListIdsByLevels.length > itemMetadata.level) {\r\n                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(\r\n                        0,\r\n                        itemMetadata.level\r\n                    );\r\n                }\r\n\r\n                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;\r\n\r\n                // Add the list item into the list of items to be processed\r\n                args.listItems.push(itemMetadata);\r\n                listMetadata.numberOfItems++;\r\n            }\r\n\r\n            args.lastProcessedItem = node;\r\n        } else {\r\n            // Here, we know that this is not a list item, but we'll want to check if it is one \"no bullet\" list items...\r\n            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will\r\n            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but\r\n            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips\r\n            // the list conversion thinking that the list items are not together...\r\n            let last = args.lastProcessedItem;\r\n            if (\r\n                last &&\r\n                getRealPreviousSibling(node) == last &&\r\n                node.tagName == last.tagName &&\r\n                node.className == last.className\r\n            ) {\r\n                // Add 2 line breaks and move all the nodes to the last item\r\n                last.appendChild(last.ownerDocument.createElement('br'));\r\n                last.appendChild(last.ownerDocument.createElement('br'));\r\n                while (node.firstChild != null) {\r\n                    last.appendChild(node.firstChild);\r\n                }\r\n\r\n                // Remove the item that we don't need anymore\r\n                node.parentNode.removeChild(node);\r\n            }\r\n        }\r\n\r\n        // Move to the next element are return true if more elements need to be processed\r\n        args.currentIndex++;\r\n    }\r\n\r\n    return args.listItems.length > 0;\r\n}\r\n\r\n/**\r\n * Handles the pass 2: Conversion\r\n * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the\r\n * conversion needed\r\n */\r\nexport function processNodeConvert(wordConverter: WordConverter): boolean {\r\n    let args = wordConverter.wordConverterArgs;\r\n    args.currentIndex = 0;\r\n\r\n    while (args.currentIndex < args.listItems.length) {\r\n        let metadata = args.listItems[args.currentIndex];\r\n        let node = metadata.originalNode;\r\n        let listMetadata = args.lists[metadata.uniqueListId.toString()];\r\n        if (!listMetadata.ignore) {\r\n            // We have a list item that we need to convert, get or create the list\r\n            // that hold this item out\r\n            let list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);\r\n            if (list) {\r\n                // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes\r\n                cleanupListIgnore(node, LOOKUP_DEPTH);\r\n\r\n                // Create a new list item and transfer the children\r\n                let li = node.ownerDocument.createElement('LI');\r\n                while (node.firstChild) {\r\n                    li.appendChild(node.firstChild);\r\n                }\r\n\r\n                // Append the list item into the list\r\n                list.appendChild(li);\r\n\r\n                // Remove the node we just converted\r\n                node.parentNode.removeChild(node);\r\n\r\n                if (listMetadata.tagName == 'UL') {\r\n                    wordConverter.numBulletsConverted++;\r\n                } else {\r\n                    wordConverter.numNumberedConverted++;\r\n                }\r\n            }\r\n        }\r\n\r\n        args.currentIndex++;\r\n    }\r\n\r\n    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;\r\n}\r\n\r\n/**\r\n * Gets or creates the list (UL or OL) that holds this item out based on the\r\n * items content and the specified metadata\r\n */\r\nfunction getOrCreateListForNode(\r\n    wordConverter: WordConverter,\r\n    node: HTMLElement,\r\n    metadata: ListItemMetadata,\r\n    listMetadata: ListMetadata\r\n): Node {\r\n    // First get the last list next to this node under the specified level. This code\r\n    // path will return the list or will create lists if needed\r\n    let list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);\r\n\r\n    // Here use the unique list ID to detect if we have the right list...\r\n    // it is possible to have 2 different lists next to each other with different formats, so\r\n    // we want to detect this an create separate lists for those cases\r\n    let listId = getObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA);\r\n\r\n    // If we have a list with and ID, but the ID is different than the ID for this list item, this\r\n    // is a completely new list, so we'll append a new list for that\r\n    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {\r\n        let newList = node.ownerDocument.createElement(listMetadata.tagName);\r\n        list.parentNode.insertBefore(newList, list.nextSibling);\r\n        list = newList;\r\n    }\r\n\r\n    // Set the list id into the custom data\r\n    setObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA, metadata.uniqueListId);\r\n\r\n    // This call will convert the list if needed to the right type of list required. This can happen\r\n    // on the cases where the first list item for this list is located after a deeper list. for that\r\n    // case, we will have created a UL for it, and we may need to convert it\r\n    return convertListIfNeeded(wordConverter, list, listMetadata);\r\n}\r\n\r\n/**\r\n * Converts the list between UL and OL if needed, by using the fake bullet and\r\n * information already stored in the list itself\r\n */\r\nfunction convertListIfNeeded(\r\n    wordConverter: WordConverter,\r\n    list: Node,\r\n    listMetadata: ListMetadata\r\n): Node {\r\n    // Check if we need to convert the list out\r\n    if (listMetadata.tagName != getTagOfNode(list)) {\r\n        // We have the wrong list type.. convert it, set the id again and tranfer all the childs\r\n        let newList = list.ownerDocument.createElement(listMetadata.tagName);\r\n        setObject(\r\n            wordConverter.customData,\r\n            newList,\r\n            UNIQUE_LIST_ID_CUSTOM_DATA,\r\n            getObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA)\r\n        );\r\n        while (list.firstChild) {\r\n            newList.appendChild(list.firstChild);\r\n        }\r\n        list.parentNode.insertBefore(newList, list);\r\n        list.parentNode.removeChild(list);\r\n        list = newList;\r\n    }\r\n\r\n    return list;\r\n}\r\n\r\n/**\r\n * Gets or creates the specified list\r\n */\r\nfunction recurringGetOrCreateListAtNode(\r\n    node: HTMLElement,\r\n    level: number,\r\n    listMetadata: ListMetadata\r\n): Node {\r\n    let parent: Node = null;\r\n    let possibleList: Node;\r\n    if (level == 1) {\r\n        // Root case, we'll check if the list is the previous sibling of the node\r\n        possibleList = getRealPreviousSibling(node);\r\n    } else {\r\n        // If we get here, we are looking for level 2 or deeper... get the upper list\r\n        // and check if the last element is a list\r\n        parent = recurringGetOrCreateListAtNode(node, level - 1, null);\r\n        possibleList = parent.lastChild;\r\n    }\r\n\r\n    // Check the element that we got and verify that it is a list\r\n    if (possibleList && possibleList.nodeType == NodeType.Element) {\r\n        let tag = getTagOfNode(possibleList);\r\n        if (tag == 'UL' || tag == 'OL') {\r\n            // We have a list.. use it\r\n            return possibleList;\r\n        }\r\n    }\r\n\r\n    // If we get here, it means we don't have a list and we need to create one\r\n    // this code path will always create new lists as UL lists\r\n    let newList = node.ownerDocument.createElement(listMetadata ? listMetadata.tagName : 'UL');\r\n    if (level == 1) {\r\n        // For level 1, we'll insert the list beofre the node\r\n        node.parentNode.insertBefore(newList, node);\r\n    } else {\r\n        // Any level 2 or above, we insert the list as the last\r\n        // child of the upper level list\r\n        parent.appendChild(newList);\r\n    }\r\n\r\n    return newList;\r\n}\r\n\r\n/**\r\n * Cleans up the node children by removing the childs marked as mso-list: Ignore.\r\n * This nodes hold the fake bullet information that Word puts in and when\r\n * conversion is happening, we want to get rid of these elements\r\n */\r\nfunction cleanupListIgnore(node: Node, levels: number) {\r\n    let nodesToRemove: Node[] = [];\r\n\r\n    for (let child: Node = node.firstChild; child; child = child.nextSibling) {\r\n        // Clean up the item internally first if we need to based on the number of levels\r\n        if (child.nodeType == NodeType.Element && levels > 1) {\r\n            cleanupListIgnore(child, levels - 1);\r\n        }\r\n\r\n        // Try to convert word comments into ignore elements if we haven't done so for this element\r\n        child = fixWordListComments(child, true /*removeComments*/);\r\n\r\n        // Check if we can remove this item out\r\n        if (isEmptySpan(child) || isIgnoreNode(child)) {\r\n            nodesToRemove.push(child);\r\n        }\r\n    }\r\n\r\n    nodesToRemove.forEach(child => node.removeChild(child));\r\n}\r\n\r\n/**\r\n * Reads the word list metadada out of the specified node. If the node\r\n * is not a Word list item, it returns null.\r\n */\r\nfunction getListItemMetadata(node: HTMLElement): ListItemMetadata {\r\n    if (node.nodeType == NodeType.Element) {\r\n        let listatt = getStyleValue(node, MSO_LIST_STYLE_NAME);\r\n        if (listatt && listatt.length > 0) {\r\n            try {\r\n                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0\r\n                // Where:\r\n                // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; metada\r\n                // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but\r\n                // for almost all cases, it maps to the list identation (or level). We'll use it as the\r\n                // list indentation value\r\n                // (2) Contains a specific list identifier.\r\n                // Example value: \"l0 level1 lfo1\"\r\n                let listprops = listatt.split(' ');\r\n                if (listprops.length == 3) {\r\n                    return <ListItemMetadata>{\r\n                        level: parseInt(listprops[1].substr('level'.length)),\r\n                        wordListId: listatt,\r\n                        originalNode: node,\r\n                        uniqueListId: 0,\r\n                    };\r\n                }\r\n            } catch (e) {}\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction isFakeBullet(fakeBullet: string): boolean {\r\n    return ['o', '·', '§', '-'].indexOf(fakeBullet) >= 0;\r\n}\r\n\r\n/** Given a fake bullet text, returns the type of list that should be used for it */\r\nfunction getFakeBulletTagName(fakeBullet: string): string {\r\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\r\n}\r\n\r\n/**\r\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\r\n * a bullet string. If not found, it returns null...\r\n */\r\nfunction getFakeBulletText(node: Node, levels: number): string {\r\n    // Word uses the following format for their bullets:\r\n    // &lt;p style=\"mso-list:l1 level1 lfo2\"&gt;\r\n    // &lt;span style=\"...\"&gt;\r\n    // &lt;span style=\"mso-list:Ignore\"&gt;1.&lt;span style=\"...\"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;\r\n    // &lt;/span&gt;\r\n    // Content here...\r\n    // &lt;/p&gt;\r\n    //\r\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\r\n    // text or image node will be the fake bullet we are looking for\r\n    let result: string = null;\r\n    let child: Node = node.firstChild;\r\n    while (!result && child) {\r\n        // First, check if we need to convert the Word list comments into real elements\r\n        child = fixWordListComments(child, true /*removeComments*/);\r\n\r\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\r\n        if (isIgnoreNode(child)) {\r\n            // Yes... this is the node that holds either the text or image data\r\n            result = child.textContent.trim();\r\n\r\n            // This is the case for image case\r\n            if (result.length == 0) {\r\n                result = 'o';\r\n            }\r\n        } else if (child.nodeType == NodeType.Element && levels > 1) {\r\n            // If this is an element and we are not in the last level, try to get the fake bullet\r\n            // out of the child\r\n            result = getFakeBulletText(child, levels - 1);\r\n        }\r\n\r\n        child = child.nextSibling;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * If the specified element is a Word List comments, this code verifies and fixes\r\n * the markup when needed to ensure that Chrome bullet conversions work as expected\r\n * -----\r\n * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into\r\n * &lt;span style=\"mso-list:Ignore\"&gt;&lt;/span&gt;... Chrome has a bug where it drops the\r\n * styles of the span, but we'll use these comments to recreate them out\r\n */\r\nfunction fixWordListComments(child: Node, removeComments: boolean): Node {\r\n    if (child.nodeType == NodeType.Comment) {\r\n        let value = (child as Comment).data;\r\n        if (value && value.trim().toLowerCase() == '[if !supportlists]') {\r\n            // We have a list ignore start, find the end.. We know is not more than\r\n            // 3 nodes away, so we'll optimize our checks\r\n            let nextElement = child;\r\n            let endComment: Node = null;\r\n            for (let j = 0; j < 4; j++) {\r\n                nextElement = getRealNextSibling(nextElement);\r\n                if (!nextElement) {\r\n                    break;\r\n                }\r\n                if (nextElement.nodeType == NodeType.Comment) {\r\n                    value = (nextElement as Comment).data;\r\n                    if (value && value.trim().toLowerCase() == '[endif]') {\r\n                        endComment = nextElement;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if we found the end node, wrap everything out\r\n            if (endComment) {\r\n                let newSpan = child.ownerDocument.createElement('span');\r\n                newSpan.setAttribute('style', 'mso-list: ignore');\r\n                nextElement = getRealNextSibling(child);\r\n                while (nextElement != endComment) {\r\n                    nextElement = nextElement.nextSibling as HTMLElement;\r\n                    newSpan.appendChild(nextElement.previousSibling);\r\n                }\r\n\r\n                // Insert the element out and use that one as the current child\r\n                endComment.parentNode.insertBefore(newSpan, endComment);\r\n\r\n                // Remove the comments out if the call specified it out\r\n                if (removeComments) {\r\n                    child.parentNode.removeChild(child);\r\n                    endComment.parentNode.removeChild(endComment);\r\n                }\r\n\r\n                // Last, make sure we return the new element out instead of the comment\r\n                child = newSpan;\r\n            }\r\n        }\r\n    }\r\n\r\n    return child;\r\n}\r\n\r\n/** Finds the real previous sibling, ignoring emtpy text nodes */\r\nfunction getRealPreviousSibling(node: Node): Node {\r\n    let prevSibling = node;\r\n    do {\r\n        prevSibling = prevSibling.previousSibling;\r\n    } while (prevSibling && isEmptyTextNode(prevSibling));\r\n    return prevSibling;\r\n}\r\n\r\n/** Finds the real next sibling, ignoring empty text nodes */\r\nfunction getRealNextSibling(node: Node): Node {\r\n    let nextSibling = node;\r\n    do {\r\n        nextSibling = nextSibling.nextSibling;\r\n    } while (nextSibling && isEmptyTextNode(nextSibling));\r\n\r\n    return nextSibling;\r\n}\r\n\r\n/**\r\n * Checks if the specified node is marked as a mso-list: Ignore. These\r\n * nodes need to be ignored when a list item is converted into standard\r\n * HTML lists\r\n */\r\nfunction isIgnoreNode(node: Node): boolean {\r\n    if (node.nodeType == NodeType.Element) {\r\n        let listatt = getStyleValue(node as HTMLElement, MSO_LIST_STYLE_NAME);\r\n        if (listatt && listatt.length > 0 && listatt.trim().toLowerCase() == 'ignore') {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/** Checks if the specified node is an empty span. */\r\nfunction isEmptySpan(node: Node): boolean {\r\n    return getTagOfNode(node) == 'SPAN' && !node.firstChild;\r\n}\r\n\r\n/** Reads the specified style value from the node */\r\nfunction getStyleValue(node: HTMLElement, styleName: string): string {\r\n    // Word uses non-standard names for the metadata that puts in the style of the element...\r\n    // Most browsers will not provide the information for those unstandard values throug the node.style\r\n    // property, so the only reliable way to read them is to get the attribute directly and do\r\n    // the required parsing..\r\n    let textStyle = node.getAttribute('style');\r\n    if (textStyle && textStyle.length > 0 && textStyle.indexOf(styleName) >= 0) {\r\n        // Split all the CSS name: value pairs\r\n        let inStyles = textStyle.split(';');\r\n        for (let i = 0; i < inStyles.length; i++) {\r\n            // Split the name and value\r\n            let nvpair = inStyles[i].split(':');\r\n            if (nvpair.length == 2 && nvpair[0].trim() == styleName) {\r\n                return nvpair[1].trim();\r\n            }\r\n        }\r\n    }\r\n\r\n    // As a backup mechanism, we'll still try to get the value from the style object\r\n    // Dictionary styles = (Dictionary)(object)node.Style;\r\n    // return (string)styles[styleName];\r\n    return null;\r\n}\r\n\r\n/** Checks if the node is an empty text node that can be ignored */\r\nfunction isEmptyTextNode(node: Node): boolean {\r\n    // No node is empty\r\n    if (!node) {\r\n        return true;\r\n    }\r\n\r\n    // Empty text node is empty\r\n    if (node.nodeType == NodeType.Text) {\r\n        let value = node.nodeValue;\r\n        value = value.replace(LINE_BREAKS, '');\r\n        return value.trim().length == 0;\r\n    }\r\n\r\n    // Span or Font with an empty child node is empty\r\n    let tagName = getTagOfNode(node);\r\n    if (node.firstChild == node.lastChild && (tagName == 'SPAN' || tagName == 'FONT')) {\r\n        return isEmptyTextNode(node.firstChild);\r\n    }\r\n\r\n    // If not found, then this is not empty\r\n    return false;\r\n}\r\n\r\n/** Resets the list */\r\nfunction resetCurrentLists(args: WordConverterArguments) {\r\n    for (let i = 0; i < args.currentListIdsByLevels.length; i++) {\r\n        let ll = args.currentListIdsByLevels[i];\r\n        if (ll) {\r\n            ll.currentUniqueListId = -1;\r\n        }\r\n    }\r\n}\r\n","import {\n    WORD_ORDERED_LIST_SELECTOR,\n    WORD_UNORDERED_LIST_SELECTOR,\n    WORD_ONLINE_IDENTIFYING_SELECTOR,\n    LIST_CONTAINER_ELEMENT_CLASS_NAME,\n    ORDERED_LIST_TAG_NAME,\n    UNORDERED_LIST_TAG_NAME\n} from './constants';\n\nimport {\n    splitParentNode,\n    getNextLeafSibling,\n    getFirstLeafNode,\n    getTagOfNode,\n    collapseNodes,\n    unwrap\n} from 'roosterjs-editor-dom';\n\nimport ListItemBlock, { createListItemBlock } from './ListItemBlock';\n\n\nexport function isWordOnlineWithList(node: HTMLElement): boolean {\n    return !!(node && node.querySelector(WORD_ONLINE_IDENTIFYING_SELECTOR));\n}\n\n// Word Online pasted content DOM structure as of July 12th 2019\n//<html>\n//  <body>\n//      <div class='OutlineGroup'>  ----------> this layer may exist depend on the content user paste\n//          <div class=\"OutlineElement\">  ----------> text content\n//              <p></p>\n//          </div>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for unordered list, all the items on the same level is under the same wrapper\n//              <ul>                                       list items in the same list can be divided into different ListItemWrapper\n//                  <li></li>                              list items in the same list can also be divided into different Outline Group;\n//                  <li></li>\n//              </ul>\n//          </div>\n//      </div>\n//      <div class='OutlineGroup'>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for ordered list, each items has it's own wrapper\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//          <div class=\"ListItemWrapper\">\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//      </div>\n//  </body>\n//</html>\n//\n\n/**\n * Convert text copied from word online into text that's workable with rooster editor\n * @param doc Document that is being pasted into editor.\n */\nexport default function convertPastedContentFromWordOnline(doc: HTMLDocument) {\n    sanitizeListItemContainer(doc);\n    const listItemBlocks: ListItemBlock[] = getListItemBlocks(doc);\n\n    listItemBlocks.forEach((itemBlock) => {\n\n        // There are cases where consecutive List Elements are seperated into different divs:\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // in the above case we want to collapse the two root level div into one and unwrap the list item divs.\n        // after the following flattening the list will become following:\n        //\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // Then we are start processing.\n        flattenListBlock(doc.body, itemBlock);\n\n        // Find the node to insertBefore, which is next sibling node of the end of a listItemBlock.\n        itemBlock.insertPositionNode = itemBlock.endElement.nextSibling;\n\n        let convertedListElement: Element;\n        itemBlock.listItemContainers.forEach((listItemContainer) => {\n            let listType: 'OL' | 'UL' = getContainerListType(listItemContainer); // list type that is contained by iterator.\n            // Initialize processed element with propery listType if this is the first element\n            if (!convertedListElement) {\n                convertedListElement = doc.createElement(listType);\n            }\n\n            // Get all list items(<li>) in the current iterator element.\n            const currentListItems = listItemContainer.querySelectorAll('li');\n            currentListItems.forEach((item) => {\n                // If item is in root level and the type of list changes then\n                // insert the current list into body and then reinitialize the convertedListElement\n                // Word Online is using data-aria-level to determine the the depth of the list item.\n                const itemLevel = parseInt(item.getAttribute('data-aria-level'));\n                // In first level list, there are cases where a consecutive list item divs may have different list type\n                // When that happens we need to insert the processed elements into the document, then change the list type\n                // and keep the processing going.\n                if (getTagOfNode(convertedListElement) != listType && itemLevel == 1) {\n                    insertConvertedListToDoc(convertedListElement, doc.body, itemBlock);\n                    convertedListElement = doc.createElement(listType);\n                }\n                insertListItem(convertedListElement, item, listType, doc);\n            });\n        });\n\n        insertConvertedListToDoc(convertedListElement, doc.body, itemBlock);\n\n        // Once we finish the process the list items and put them into a list.\n        // After inserting the processed element,\n        // we need to remove all the non processed node from the parent node.\n        const parentContainer = itemBlock.startElement.parentNode;\n        if (parentContainer) {\n            itemBlock.listItemContainers.forEach((listItemContainer) => {\n                parentContainer.removeChild(listItemContainer);\n            });\n        }\n    });\n}\n\n/**\n * The node processing is based on the premise of only ol/ul is in ListContainerWrapper class\n * However the html might be melformed, this function is to split all the other elements out of ListContainerWrapper\n * @param doc pasted document that contains all the list element.\n */\nfunction sanitizeListItemContainer(doc: HTMLDocument) {\n    const listItemContainerListEl = doc.querySelectorAll(`${WORD_ORDERED_LIST_SELECTOR}, ${WORD_UNORDERED_LIST_SELECTOR}`);\n    listItemContainerListEl.forEach((el) => {\n        const replaceRegex = new RegExp(`\\\\b${LIST_CONTAINER_ELEMENT_CLASS_NAME}\\\\b`, 'g');\n        if (el.previousSibling) {\n            const prevParent = splitParentNode(el, true) as HTMLElement;\n            prevParent.className = prevParent.className.replace(replaceRegex, '');\n        }\n        if (el.nextSibling) {\n            const nextParent = splitParentNode(el, false) as HTMLElement;\n            nextParent.className = nextParent.className.replace(replaceRegex, '');\n        }\n    });\n}\n\n/**\n * Take all the list items in the document, and group the consecutive list times in a list block;\n * @param doc pasted document that contains all the list element.\n */\nfunction getListItemBlocks(doc: HTMLDocument): ListItemBlock[] {\n    const listElements = doc.getElementsByClassName(LIST_CONTAINER_ELEMENT_CLASS_NAME);\n    const result: ListItemBlock[] = [];\n    let curListItemBlock: ListItemBlock;\n    for (let i = 0; i < listElements.length; i++) {\n        let curItem = listElements[i];\n        if (!curListItemBlock) {\n            curListItemBlock = createListItemBlock(curItem)\n        } else {\n            const { listItemContainers } = curListItemBlock;\n            const lastItemInCurBlock = listItemContainers[listItemContainers.length - 1];\n            if (curItem == lastItemInCurBlock.nextSibling\n                || getFirstLeafNode(curItem) == getNextLeafSibling(doc.body, lastItemInCurBlock)) {\n                listItemContainers.push(curItem);\n                curListItemBlock.endElement = curItem\n            } else {\n                curListItemBlock.endElement = lastItemInCurBlock;\n                result.push(curListItemBlock);\n                curListItemBlock = createListItemBlock(curItem);\n            }\n        }\n    }\n\n    if (curListItemBlock.listItemContainers.length > 0) {\n        result.push(curListItemBlock);\n    }\n\n    return result;\n}\n\n/**\n * Flatten the list items, so that all the consecutive list items are under the same parent.\n * @param doc Root element of that contains the element.\n * @param listItemBlock The list item block needed to be flattened.\n */\nfunction flattenListBlock(rootElement: Element, listItemBlock: ListItemBlock) {\n    const collapsedListItemSections = collapseNodes(rootElement, listItemBlock.startElement, listItemBlock.endElement, true);\n    collapsedListItemSections.forEach((section) => {\n        if (getTagOfNode(section.firstChild) == 'DIV') {\n            unwrap(section)\n        }\n    })\n}\n\n/**\n * Get the list type that the container contains. If there is no list in the container\n * return null;\n * @param listItemContainer Container that contains a list\n */\nfunction getContainerListType(listItemContainer: Element): 'OL' | 'UL' | null {\n    const tag = getTagOfNode(listItemContainer.firstChild);\n    return tag == UNORDERED_LIST_TAG_NAME || tag == ORDERED_LIST_TAG_NAME ? tag : null;\n}\n\n/**\n * Insert list item into the correct position of a list\n * @param listRootElement Root element of the list that is accepting a coming element.\n * @param itemToInsert List item that needed to be inserted.\n * @param listType Type of list(ul/ol)\n */\nfunction insertListItem(listRootElement: Element, itemToInsert: HTMLElement, listType: string, doc: HTMLDocument): void {\n    if (!listType) {\n        return\n    }\n    // Get item level from 'data-aria-level' attribute\n    let itemLevel = parseInt(itemToInsert.getAttribute('data-aria-level'));\n    let curListLevel = listRootElement; // Level iterator to find the correct place for the current element.\n    // if the itemLevel is 1 it means the level iterator is at the correct place.\n    while (itemLevel > 1) {\n        if (!curListLevel.firstChild) {\n            // If the current level is empty, create empty list within the current level\n            // then move the level iterator into the next level.\n            curListLevel.append(doc.createElement(listType));\n            curListLevel = curListLevel.firstElementChild;\n        } else {\n            // If the current level is not empty, the last item in the needs to be a UL or OL\n            // and the level iterator should move to the UL/OL at the last position.\n            let lastChild = curListLevel.lastElementChild;\n            let lastChildTag = getTagOfNode(lastChild);\n            if (lastChildTag == UNORDERED_LIST_TAG_NAME || lastChildTag == ORDERED_LIST_TAG_NAME) {\n                // If the last child is a list(UL/OL), then move the level iterator to last child.\n                curListLevel = lastChild;\n            } else {\n                // If the last child is not a list, then append a new list to the level\n                // and move the level iterator to the new level.\n                curListLevel.append(doc.createElement(listType))\n                curListLevel = curListLevel.lastElementChild;\n            }\n        }\n        itemLevel--;\n    }\n\n    // Once the level iterator is at the right place, then append the list item in the level.\n    curListLevel.appendChild(itemToInsert);\n}\n\n/**\n * Insert the converted list item into the correct place.\n * @param convertedListElement List element that is converted from list item block\n * @param rootElement Root element of that contains the converted listItemBlock\n * @param listItemBlock List item block that was converted.\n */\nfunction insertConvertedListToDoc(convertedListElement: Element, rootElement: Element, listItemBlock: ListItemBlock) {\n    if (!convertedListElement) {\n        return;\n    }\n\n    const { insertPositionNode } = listItemBlock;\n    if (insertPositionNode) {\n        const { parentElement } = insertPositionNode;\n        if (parentElement) {\n            parentElement.insertBefore(convertedListElement, insertPositionNode);\n        }\n    } else {\n        const { parentElement } = listItemBlock.startElement;\n        if (parentElement) {\n            parentElement.appendChild(convertedListElement)\n        } else {\n            rootElement.append(convertedListElement);\n        }\n    }\n}","/**\n * Type that holds all the info of a consecutive list item block.\n */\nexport default interface ListItemBlock {\n    /**\n     * The first element in block of list item from pasted word online document.\n     */\n    startElement: Element;\n\n    /**\n     * The last element in block of list item from pasted word online document.\n     */\n    endElement: Element;\n\n    /**\n     * The position where the processed bulleted list should be inserted.\n     */\n    insertPositionNode: Node;\n\n    /**\n     * The list of containers that wraps each list item.\n     */\n    listItemContainers: Element[];\n}\n\n/**\n * Initialize an empty ListItemBlock\n */\nexport function createListItemBlock(listItem: Element = null): ListItemBlock {\n    return {\n        startElement: listItem,\n        endElement: listItem,\n        insertPositionNode: null,\n        listItemContainers: listItem ? [listItem] : [],\n    }\n}","import { Browser } from 'roosterjs-editor-dom';\r\n\r\nvar ZERO_WIDTH_SPACE = '&#8203;';\r\n\r\n/**\r\n * Convert plain to HTML\r\n * @param text The plain text to convert\r\n * @returns HTML string to present the input text\r\n */\r\nexport default function textToHtml(text: string): string {\r\n    text = (text || '')\r\n        .replace(/&/g, '&amp;')\r\n        .replace(/</g, '&lt;')\r\n        .replace(/>/g, '&gt;')\r\n        .replace(/'/g, '&#39;')\r\n        .replace(/\"/g, '&quot;')\r\n        .replace(/^ /gm, '&nbsp;')\r\n        .replace(/\\r/g, '');\r\n    let lines = text.split('\\n');\r\n    if (lines.length == 2) {\r\n        text = `<span>${lines[0]}<br></span><span>${lines[1]}</span>`;\r\n    } else if (lines.length > 2) {\r\n        text = '';\r\n        let lineEnd = Browser.isIEOrEdge ? ZERO_WIDTH_SPACE : '<br>';\r\n        lines.forEach((line, i) => {\r\n            if (i == 0) {\r\n                text += `<span>${line}<br></span>`;\r\n            } else if (i == lines.length - 1) {\r\n                text += `<span>${line}</span>`;\r\n            } else {\r\n                text += `<div>${line}${lineEnd}</div>`;\r\n            }\r\n        });\r\n    }\r\n    text = text.replace(/ {2}/g, ' &nbsp;');\r\n    return text;\r\n}\r\n","import { applyFormat, getTagOfNode, wrap } from 'roosterjs-editor-dom';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport {\r\n    ChangeSource,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    ContentPosition,\r\n    ExtractContentEvent,\r\n    DefaultFormat,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst WATERMARK_SPAN_ID = '_rooster_watermarkSpan';\r\nconst WATERMARK_REGEX = new RegExp(\r\n    `<span[^>]*id=['\"]?${WATERMARK_SPAN_ID}['\"]?[^>]*>[^<]*</span>`,\r\n    'ig'\r\n);\r\nconst SPELLCHECK_ATTR_NAME = 'spellcheck';\r\n\r\n/**\r\n * A watermark plugin to manage watermark string for roosterjs\r\n */\r\nexport default class Watermark implements EditorPlugin {\r\n    private editor: Editor;\r\n    private isWatermarkShowing: boolean;\r\n    private disposer: () => void;\r\n    private spellcheckInitialValue: string;\r\n\r\n    /**\r\n     * Create an instance of Watermark plugin\r\n     * @param watermark The watermark string\r\n     */\r\n    constructor(private watermark: string, private format?: DefaultFormat) {\r\n        this.format = this.format || {\r\n            fontSize: '14px',\r\n            textColor: '#aaa',\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Watermark';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.disposer = this.editor.addDomEventHandler({\r\n            focus: this.handleWatermark,\r\n            blur: this.handleWatermark,\r\n        });\r\n        this.spellcheckInitialValue = this.editor.getEditorDomAttribute(SPELLCHECK_ATTR_NAME);\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.hideWatermark();\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.EditorReady) {\r\n            this.showHideWatermark(false /*ignoreCachedState*/);\r\n        } else if (event.eventType == PluginEventType.ContentChanged) {\r\n            // When content is changed from setContent() API, current cached state\r\n            // may not be accurate, so we ignore it\r\n            this.showHideWatermark(event.source == ChangeSource.SetContent);\r\n        } else if (event.eventType == PluginEventType.ExtractContent && this.isWatermarkShowing) {\r\n            this.removeWartermarkFromHtml(event as ExtractContentEvent);\r\n        }\r\n    }\r\n\r\n    private handleWatermark = () => {\r\n        this.showHideWatermark(false /*ignoreCachedState*/);\r\n    };\r\n\r\n    private showHideWatermark(ignoreCachedState: boolean) {\r\n        if (this.editor.hasFocus() && (ignoreCachedState || this.isWatermarkShowing)) {\r\n            this.hideWatermark();\r\n            this.editor.focus();\r\n        } else if (\r\n            !this.editor.hasFocus() &&\r\n            (ignoreCachedState || !this.isWatermarkShowing) &&\r\n            this.editor.isEmpty(true /*trim*/)\r\n        ) {\r\n            this.showWatermark();\r\n        }\r\n    }\r\n\r\n    private showWatermark() {\r\n        let document = this.editor.getDocument();\r\n        let watermarkNode = wrap(\r\n            document.createTextNode(this.watermark),\r\n            `<span id=\"${WATERMARK_SPAN_ID}\"></span>`\r\n        ) as HTMLElement;\r\n        applyFormat(watermarkNode, this.format, this.editor.isDarkMode());\r\n        this.editor.insertNode(watermarkNode, {\r\n            position: ContentPosition.Begin,\r\n            updateCursor: false,\r\n            replaceSelection: false,\r\n            insertOnNewLine: false,\r\n        });\r\n        this.editor.setEditorDomAttribute(SPELLCHECK_ATTR_NAME, 'false');\r\n        this.isWatermarkShowing = true;\r\n    }\r\n\r\n    private hideWatermark() {\r\n        this.editor.queryElements(`span[id=\"${WATERMARK_SPAN_ID}\"]`, span => {\r\n            let parentNode = span.parentNode;\r\n            this.editor.deleteNode(span);\r\n\r\n            // After remove watermark node, if it leaves an empty DIV, append a BR node into it to make it a regular empty line\r\n            if (\r\n                this.editor.contains(parentNode) &&\r\n                getTagOfNode(parentNode) == 'DIV' &&\r\n                !parentNode.firstChild\r\n            ) {\r\n                parentNode.appendChild(this.editor.getDocument().createElement('BR'));\r\n            }\r\n        });\r\n\r\n        this.editor.setEditorDomAttribute(SPELLCHECK_ATTR_NAME, this.spellcheckInitialValue);\r\n        this.isWatermarkShowing = false;\r\n    }\r\n\r\n    private removeWartermarkFromHtml(event: ExtractContentEvent) {\r\n        let content = event.content;\r\n        content = content.replace(WATERMARK_REGEX, '');\r\n        event.content = content;\r\n    }\r\n}\r\n","import { contains, fromHtml, isRtl, VTable } from 'roosterjs-editor-dom';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport { isNode } from 'roosterjs-cross-window';\r\nimport {\r\n    ContentPosition,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginMouseEvent,\r\n    ChangeSource,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst TABLE_RESIZE_HANDLE_KEY = 'TABLE_RESIZE_HANDLE';\r\nconst HANDLE_WIDTH = 6;\r\nconst CONTAINER_HTML = `<div style=\"position: fixed; cursor: col-resize; width: ${HANDLE_WIDTH}px; border: solid 0 #C6C6C6;\"></div>`;\r\n\r\n/**\r\n * TableResize plugin, provides the ability to resize a table by drag-and-drop\r\n */\r\nexport default class TableResize implements EditorPlugin {\r\n    private editor: Editor;\r\n    private onMouseOverDisposer: () => void;\r\n    private td: HTMLTableCellElement;\r\n    private pageX = -1;\r\n    private initialPageX: number;\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.onMouseOverDisposer = this.editor.addDomEventHandler('mouseover', this.onMouseOver);\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'TableResize';\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.detachMouseEvents();\r\n        this.editor = null;\r\n        this.onMouseOverDisposer();\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (\r\n            this.td &&\r\n            (event.eventType == PluginEventType.KeyDown ||\r\n                event.eventType == PluginEventType.ContentChanged ||\r\n                (event.eventType == PluginEventType.MouseDown && !this.clickIntoCurrentTd(event)))\r\n        ) {\r\n            this.td = null;\r\n            this.calcAndShowHandle();\r\n        }\r\n    }\r\n\r\n    private clickIntoCurrentTd(event: PluginMouseEvent) {\r\n        let mouseEvent = event.rawEvent;\r\n        let target = mouseEvent.target;\r\n        return isNode(target) && contains(this.td, <Node>target, true /*treatSameNodeAsContain*/);\r\n    }\r\n\r\n    private onMouseOver = (e: MouseEvent) => {\r\n        let node = <HTMLElement>(e.srcElement || e.target);\r\n        if (\r\n            this.pageX < 0 &&\r\n            node &&\r\n            (node.tagName == 'TD' || node.tagName == 'TH') &&\r\n            node != this.td\r\n        ) {\r\n            this.td = <HTMLTableCellElement>node;\r\n            this.calcAndShowHandle();\r\n        }\r\n    };\r\n\r\n    private calcAndShowHandle() {\r\n        if (this.td) {\r\n            let tr = <HTMLTableRowElement>this.editor.getElementAtCursor('TR', this.td);\r\n            let table = <HTMLTableElement>this.editor.getElementAtCursor('TABLE', tr);\r\n            if (tr && table) {\r\n                let [left, top] = this.getPosition(table);\r\n                let handle = this.getResizeHandle();\r\n\r\n                left +=\r\n                    this.td.offsetLeft + (isRtl(table) ? 0 : this.td.offsetWidth - HANDLE_WIDTH);\r\n                handle.style.display = '';\r\n                handle.style.top = top + 'px';\r\n                handle.style.height = table.offsetHeight + 'px';\r\n                handle.style.left = left + 'px';\r\n            }\r\n        } else {\r\n            this.getResizeHandle().style.display = 'none';\r\n        }\r\n    }\r\n\r\n    private adjustHandle(pageX: number) {\r\n        let handle = this.getResizeHandle();\r\n        handle.style.left = handle.offsetLeft + pageX - this.pageX + 'px';\r\n        this.pageX = pageX;\r\n    }\r\n\r\n    private getPosition(e: HTMLElement): [number, number] {\r\n        let parent = <HTMLElement>e.offsetParent;\r\n        let [left, top] = parent ? this.getPosition(parent) : [0, 0];\r\n        return [left + e.offsetLeft - e.scrollLeft, top + e.offsetTop - e.scrollTop];\r\n    }\r\n\r\n    private getResizeHandle() {\r\n        return this.editor.getCustomData(\r\n            TABLE_RESIZE_HANDLE_KEY,\r\n            () => {\r\n                let document = this.editor.getDocument();\r\n                let handle = fromHtml(CONTAINER_HTML, document)[0] as HTMLElement;\r\n                this.editor.insertNode(handle, {\r\n                    position: ContentPosition.Outside,\r\n                    updateCursor: false,\r\n                    replaceSelection: false,\r\n                    insertOnNewLine: false,\r\n                });\r\n                handle.addEventListener('mousedown', this.onMouseDown);\r\n                return handle;\r\n            },\r\n            handle => {\r\n                handle.removeEventListener('mousedown', this.onMouseDown);\r\n                handle.parentNode.removeChild(handle);\r\n            }\r\n        );\r\n    }\r\n\r\n    private cancelEvent(e: MouseEvent) {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    }\r\n\r\n    private onMouseDown = (e: MouseEvent) => {\r\n        if (!this.editor || this.editor.isDisposed()) {\r\n            return;\r\n        }\r\n\r\n        this.pageX = e.pageX;\r\n        this.initialPageX = e.pageX;\r\n        this.attachMouseEvents();\r\n\r\n        let handle = this.getResizeHandle();\r\n        handle.style.borderWidth = '0 1px';\r\n\r\n        this.cancelEvent(e);\r\n    };\r\n\r\n    private onMouseMove = (e: MouseEvent) => {\r\n        this.adjustHandle(e.pageX);\r\n        this.cancelEvent(e);\r\n    };\r\n\r\n    private onMouseUp = (e: MouseEvent) => {\r\n        this.detachMouseEvents();\r\n\r\n        let handle = this.getResizeHandle();\r\n        handle.style.borderWidth = '0';\r\n\r\n        let table = this.editor.getElementAtCursor('TABLE', this.td) as HTMLTableElement;\r\n        let cellPadding = parseInt(table.cellPadding);\r\n        cellPadding = isNaN(cellPadding) ? 0 : cellPadding;\r\n\r\n        if (e.pageX != this.initialPageX) {\r\n            let newWidth =\r\n                this.td.clientWidth -\r\n                cellPadding * 2 +\r\n                (e.pageX - this.initialPageX) * (isRtl(table) ? -1 : 1);\r\n            this.editor.addUndoSnapshot((start, end) => {\r\n                this.setTableColumnWidth(newWidth + 'px');\r\n                this.editor.select(start, end);\r\n            }, ChangeSource.Format);\r\n        }\r\n\r\n        this.pageX = -1;\r\n        this.calcAndShowHandle();\r\n        this.editor.focus();\r\n        this.cancelEvent(e);\r\n    };\r\n\r\n    private attachMouseEvents() {\r\n        if (this.editor && !this.editor.isDisposed()) {\r\n            let document = this.editor.getDocument();\r\n            document.addEventListener('mousemove', this.onMouseMove, true);\r\n            document.addEventListener('mouseup', this.onMouseUp, true);\r\n        }\r\n    }\r\n\r\n    private detachMouseEvents() {\r\n        if (this.editor && !this.editor.isDisposed()) {\r\n            let document = this.editor.getDocument();\r\n            document.removeEventListener('mousemove', this.onMouseMove, true);\r\n            document.removeEventListener('mouseup', this.onMouseUp, true);\r\n        }\r\n    }\r\n\r\n    private setTableColumnWidth(width: string) {\r\n        let vtable = new VTable(this.td);\r\n        vtable.table.style.width = '';\r\n        vtable.table.width = '';\r\n        vtable.forEachCellOfCurrentColumn(cell => {\r\n            if (cell.td) {\r\n                cell.td.style.width = cell.td == this.td ? width : '';\r\n            }\r\n        });\r\n        vtable.writeBack();\r\n        return this.editor.contains(this.td) ? this.td : vtable.getCurrentTd();\r\n    }\r\n}\r\n","import { cacheGetContentSearcher, Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport { PluginEvent, PluginEventType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * An interface to define a replacement rule for CustomReplace plugin\r\n */\r\nexport type Replacement = {\r\n    /**\r\n     * Source string to replace from\r\n     */\r\n    sourceString: string;\r\n\r\n    /**\r\n     * HTML string to replace to\r\n     */\r\n    replacementHTML: string;\r\n\r\n    /**\r\n     * Whether the matching should be case sensitive\r\n     */\r\n    matchSourceCaseSensitive: boolean;\r\n};\r\n\r\nconst makeReplacement = (\r\n    sourceString: string,\r\n    replacementHTML: string,\r\n    matchSourceCaseSensitive: boolean\r\n): Replacement => ({ sourceString, replacementHTML, matchSourceCaseSensitive });\r\n\r\nconst defaultReplacements: Replacement[] = [\r\n    makeReplacement(':)', '🙂', true),\r\n    makeReplacement(';)', '😉', true),\r\n    makeReplacement(':O', '😲', true),\r\n    makeReplacement(':o', '😯', true),\r\n    makeReplacement('<3', '❤️', true),\r\n];\r\n\r\n/**\r\n * Wrapper for CustomReplaceContentEditFeature that provides an API for updating the\r\n * content edit feature\r\n */\r\nexport default class CustomReplacePlugin implements EditorPlugin {\r\n    private longestReplacementLength: number;\r\n    private editor: Editor;\r\n    private replacements: Replacement[];\r\n    private replacementEndCharacters: Set<string>;\r\n\r\n    /**\r\n     * Create instance of CustomReplace plugin\r\n     * @param replacements Replacement rules. If not passed, a default replacement rule set will be applied\r\n     */\r\n    constructor(replacements: Replacement[] = defaultReplacements) {\r\n        this.updateReplacements(replacements);\r\n    }\r\n\r\n    /**\r\n     * Set the replacements that this plugin is looking for.\r\n     * @param newReplacements new set of replacements for this plugin\r\n     */\r\n    updateReplacements(newReplacements: Replacement[]) {\r\n        this.replacements = newReplacements;\r\n        this.longestReplacementLength = getLongestReplacementSourceLength(this.replacements);\r\n        this.replacementEndCharacters = getReplacementEndCharacters(this.replacements);\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'CustomReplace';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    public initialize(editor: Editor): void {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose(): void {\r\n        this.editor = null;\r\n    }\r\n\r\n    public onPluginEvent(event: PluginEvent) {\r\n        if (this.editor.isInIME() || event.eventType != PluginEventType.Input) {\r\n            return;\r\n        }\r\n\r\n        // Exit early on input events that do not insert a replacement's final character.\r\n        if (!event.rawEvent.data || !this.replacementEndCharacters.has(event.rawEvent.data)) {\r\n            return;\r\n        }\r\n\r\n        // Get the matching replacement\r\n        const range = this.editor.getSelectionRange();\r\n        if (range == null) {\r\n            return;\r\n        }\r\n        const searcher = cacheGetContentSearcher(event, this.editor);\r\n        const stringToSearch = searcher.getSubStringBefore(this.longestReplacementLength);\r\n\r\n        const replacement = this.getMatchingReplacement(stringToSearch);\r\n        if (replacement == null) {\r\n            return;\r\n        }\r\n\r\n        // Reconstruct a selection of the text on the document that matches the\r\n        // replacement we selected.\r\n        const matchingText = searcher.getSubStringBefore(replacement.sourceString.length);\r\n        const matchingRange = searcher.getRangeFromText(matchingText, true /* exactMatch */);\r\n\r\n        // parse the html string off the dom and inline the resulting element.\r\n        const document = this.editor.getDocument();\r\n        const parsingSpan = document.createElement('span');\r\n        parsingSpan.innerHTML = replacement.replacementHTML;\r\n        const nodeToInsert =\r\n            parsingSpan.childNodes.length == 1 ? parsingSpan.childNodes[0] : parsingSpan;\r\n\r\n        // Switch the node for the selection range\r\n        this.editor.performAutoComplete(() => {\r\n            matchingRange.deleteContents();\r\n            matchingRange.insertNode(nodeToInsert);\r\n            this.editor.select(nodeToInsert, PositionType.End);\r\n        });\r\n    }\r\n\r\n    private getMatchingReplacement(stringToSearch: string): Replacement | null {\r\n        if (stringToSearch.length == 0) {\r\n            return null;\r\n        }\r\n        const lowerCaseStringToSearch = stringToSearch.toLocaleLowerCase();\r\n        for (const replacement of this.replacements) {\r\n            const [sourceMatch, replacementMatch] = replacement.matchSourceCaseSensitive\r\n                ? [stringToSearch, replacement.sourceString]\r\n                : [lowerCaseStringToSearch, replacement.sourceString.toLocaleLowerCase()];\r\n\r\n            if (\r\n                sourceMatch.substring(sourceMatch.length - replacementMatch.length) ==\r\n                replacementMatch\r\n            ) {\r\n                return replacement;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getLongestReplacementSourceLength(replacements: Replacement[]): number {\r\n    return Math.max.apply(null, replacements.map(replacement => replacement.sourceString.length));\r\n}\r\n\r\nfunction getReplacementEndCharacters(replacements: Replacement[]): Set<string> {\r\n    const endChars = new Set<string>();\r\n    for (let replacement of replacements) {\r\n        const sourceString = replacement.sourceString;\r\n        if (sourceString.length == 0) {\r\n            continue;\r\n        }\r\n        const lastChar = sourceString[sourceString.length - 1];\r\n        if (!replacement.matchSourceCaseSensitive) {\r\n            endChars.add(lastChar.toLocaleLowerCase());\r\n            endChars.add(lastChar.toLocaleUpperCase());\r\n        } else {\r\n            endChars.add(lastChar);\r\n        }\r\n    }\r\n    return endChars;\r\n}\r\n","export { default as ImageResize } from './ImageResize';\r\n","import { contains, getTagOfNode, toArray } from 'roosterjs-editor-dom';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport {\r\n    ContentChangedEvent,\r\n    ChangeSource,\r\n    NodeType,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    ExtractContentEvent,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst BEGIN_TAG = 'RoosterJsImageResizingBegin';\r\nconst END_TAG = 'RoosterJsImageResizingEnd';\r\nconst EXTRACT_HTML_REGEX = new RegExp(\r\n    `<!--${BEGIN_TAG}-->[\\\\s\\\\S]*(<img\\\\s[^>]+>)[\\\\s\\\\S]*<!--${END_TAG}-->`,\r\n    'gim'\r\n);\r\nconst DELETE_KEYCODE = 46;\r\nconst BACKSPACE_KEYCODE = 8;\r\nconst SHIFT_KEYCODE = 16;\r\nconst CTRL_KEYCODE = 17;\r\nconst ALT_KEYCODE = 18;\r\n\r\n/**\r\n * ImageResize plugin provides the ability to resize an inline image in editor\r\n */\r\nexport default class ImageResize implements EditorPlugin {\r\n    private editor: Editor;\r\n    private startPageX: number;\r\n    private startPageY: number;\r\n    private startWidth: number;\r\n    private startHeight: number;\r\n    private resizeDiv: HTMLElement;\r\n    private direction: string;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Create a new instance of ImageResize\r\n     * @param minWidth Minimum width of image when resize in pixel, default value is 10\r\n     * @param minHeight Minimum height of image when resize in pixel, default value is 10\r\n     * @param selectionBorderColor Color of resize border and handles, default value is #DB626C\r\n     * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false\r\n     * @param resizableImageSelector Selector for picking which image is resizable (e.g. for all images not placeholders), note\r\n     * that the tag must be IMG regardless what the selector is\r\n     */\r\n    constructor(\r\n        private minWidth: number = 10,\r\n        private minHeight: number = 10,\r\n        private selectionBorderColor: string = '#DB626C',\r\n        private forcePreserveRatio: boolean = false,\r\n        private resizableImageSelector: string = 'img'\r\n    ) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'ImageResize';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.disposer = editor.addDomEventHandler({\r\n            dragstart: this.onDragStart,\r\n            blur: this.onBlur,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        if (this.resizeDiv) {\r\n            this.hideResizeHandle();\r\n        }\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(e: PluginEvent) {\r\n        if (e.eventType == PluginEventType.MouseDown) {\r\n            const event = e.rawEvent;\r\n            const target = <HTMLElement>(event.srcElement || event.target);\r\n\r\n            if (getTagOfNode(target) == 'IMG') {\r\n                const parent = target.parentNode as HTMLElement;\r\n                const elements = parent\r\n                    ? toArray(parent.querySelectorAll(this.resizableImageSelector))\r\n                    : [];\r\n                if (elements.indexOf(target) < 0) {\r\n                    return;\r\n                }\r\n\r\n                target.contentEditable = 'false';\r\n                const currentImg = this.getSelectedImage();\r\n                if (currentImg && currentImg != target) {\r\n                    this.hideResizeHandle();\r\n                }\r\n\r\n                if (!this.resizeDiv) {\r\n                    this.showResizeHandle(<HTMLImageElement>target);\r\n                }\r\n            } else if (this.resizeDiv && !contains(this.resizeDiv, target)) {\r\n                this.hideResizeHandle();\r\n            }\r\n        } else if (e.eventType == PluginEventType.KeyDown && this.resizeDiv) {\r\n            const event = e.rawEvent;\r\n            if (event.which == DELETE_KEYCODE || event.which == BACKSPACE_KEYCODE) {\r\n                this.editor.addUndoSnapshot(() => {\r\n                    this.removeResizeDiv(this.resizeDiv);\r\n                });\r\n                this.resizeDiv = null;\r\n                event.preventDefault();\r\n                this.resizeDiv = null;\r\n            } else if (\r\n                event.which != SHIFT_KEYCODE &&\r\n                event.which != CTRL_KEYCODE &&\r\n                event.which != ALT_KEYCODE\r\n            ) {\r\n                this.hideResizeHandle(true /*selectImage*/);\r\n            }\r\n        } else if (\r\n            e.eventType == PluginEventType.ContentChanged &&\r\n            (<ContentChangedEvent>e).source != ChangeSource.ImageResize\r\n        ) {\r\n            this.editor.queryElements('img', this.removeResizeDivIfAny);\r\n            this.resizeDiv = null;\r\n        } else if (e.eventType == PluginEventType.ExtractContent) {\r\n            const event = <ExtractContentEvent>e;\r\n            event.content = this.extractHtml(event.content);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select a given IMG element, show the resize handle\r\n     * @param img The IMG element to select\r\n     */\r\n    showResizeHandle(img: HTMLImageElement) {\r\n        this.resizeDiv = this.createResizeDiv(img);\r\n        img.contentEditable = 'false';\r\n        this.editor.select(this.resizeDiv, PositionType.After);\r\n    }\r\n\r\n    /**\r\n     * Hide resize handle of current selected image\r\n     * @param selectImageAfterUnSelect Optional, when set to true, select the image element after hide the resize handle\r\n     */\r\n    hideResizeHandle(selectImageAfterUnSelect?: boolean) {\r\n        let img = this.getSelectedImage();\r\n        let parent = this.resizeDiv && this.resizeDiv.parentNode;\r\n        if (parent) {\r\n            if (img) {\r\n                img.removeAttribute('contentEditable');\r\n                let referenceNode =\r\n                    this.resizeDiv.previousSibling &&\r\n                    this.resizeDiv.previousSibling.nodeType == NodeType.Comment\r\n                        ? this.resizeDiv.previousSibling\r\n                        : this.resizeDiv;\r\n                parent.insertBefore(img, referenceNode);\r\n\r\n                if (selectImageAfterUnSelect) {\r\n                    this.editor.select(img);\r\n                } else {\r\n                    this.editor.select(img, PositionType.After);\r\n                }\r\n            }\r\n            this.removeResizeDiv(this.resizeDiv);\r\n            this.resizeDiv = null;\r\n        }\r\n    }\r\n\r\n    private startResize = (e: MouseEvent) => {\r\n        let img = this.getSelectedImage();\r\n        if (this.editor && img) {\r\n            this.startPageX = e.pageX;\r\n            this.startPageY = e.pageY;\r\n            this.startWidth = img.clientWidth;\r\n            this.startHeight = img.clientHeight;\r\n            this.editor.addUndoSnapshot();\r\n\r\n            let document = this.editor.getDocument();\r\n            document.addEventListener('mousemove', this.doResize, true /*useCapture*/);\r\n            document.addEventListener('mouseup', this.finishResize, true /*useCapture*/);\r\n            this.direction = (<HTMLElement>(e.srcElement || e.target)).style.cursor;\r\n        }\r\n\r\n        this.stopEvent(e);\r\n    };\r\n\r\n    private doResize = (e: MouseEvent) => {\r\n        let img = this.getSelectedImage();\r\n        if (this.editor && img) {\r\n            let widthChange = e.pageX - this.startPageX;\r\n            let heightChange = e.pageY - this.startPageY;\r\n            let newWidth = Math.max(\r\n                this.startWidth + (this.isWest(this.direction) ? -widthChange : widthChange),\r\n                this.minWidth\r\n            );\r\n            let newHeight = Math.max(\r\n                this.startHeight + (this.isNorth(this.direction) ? -heightChange : heightChange),\r\n                this.minHeight\r\n            );\r\n\r\n            if (this.forcePreserveRatio || e.shiftKey) {\r\n                let ratio =\r\n                    this.startWidth > 0 && this.startHeight > 0\r\n                        ? (this.startWidth * 1.0) / this.startHeight\r\n                        : 0;\r\n                if (ratio > 0) {\r\n                    if (newWidth < newHeight * ratio) {\r\n                        newWidth = newHeight * ratio;\r\n                    } else {\r\n                        newHeight = newWidth / ratio;\r\n                    }\r\n                }\r\n            }\r\n\r\n            img.style.width = newWidth + 'px';\r\n            img.style.height = newHeight + 'px';\r\n\r\n            // double check\r\n            if (this.forcePreserveRatio || e.shiftKey) {\r\n                let ratio =\r\n                    this.startWidth > 0 && this.startHeight > 0\r\n                        ? (this.startWidth * 1.0) / this.startHeight\r\n                        : 0;\r\n\r\n                const clientWidth = Math.floor(img.clientWidth);\r\n                const clientHeight = Math.floor(img.clientHeight);\r\n                newWidth = Math.floor(newWidth);\r\n                newHeight = Math.floor(newHeight);\r\n                if (clientHeight !== newHeight || clientWidth !== newWidth) {\r\n                    if (clientHeight < newHeight) {\r\n                        newWidth = clientHeight * ratio;\r\n                    } else {\r\n                        newHeight = clientWidth / ratio;\r\n                    }\r\n                    img.style.width = newWidth + 'px';\r\n                    img.style.height = newHeight + 'px';\r\n                }\r\n            }\r\n        }\r\n        this.stopEvent(e);\r\n    };\r\n\r\n    private finishResize = (e: MouseEvent) => {\r\n        var img = this.getSelectedImage() as HTMLImageElement;\r\n        if (this.editor && img) {\r\n            let document = this.editor.getDocument();\r\n            document.removeEventListener('mousemove', this.doResize, true /*useCapture*/);\r\n            document.removeEventListener('mouseup', this.finishResize, true /*useCapture*/);\r\n            let width = img.clientWidth;\r\n            let height = img.clientHeight;\r\n            img.style.width = width + 'px';\r\n            img.style.height = height + 'px';\r\n            img.width = width;\r\n            img.height = height;\r\n            this.resizeDiv.style.width = '';\r\n            this.resizeDiv.style.height = '';\r\n        }\r\n        this.direction = null;\r\n        this.editor.addUndoSnapshot();\r\n        this.editor.triggerContentChangedEvent(ChangeSource.ImageResize);\r\n        this.stopEvent(e);\r\n    };\r\n\r\n    private createResizeDiv(target: HTMLElement) {\r\n        let document = this.editor.getDocument();\r\n        let resizeDiv = document.createElement('DIV');\r\n        let parent = target.parentNode;\r\n        parent.insertBefore(resizeDiv, target);\r\n        parent.insertBefore(document.createComment(BEGIN_TAG), resizeDiv);\r\n        parent.insertBefore(document.createComment(END_TAG), resizeDiv.nextSibling);\r\n\r\n        resizeDiv.style.position = 'relative';\r\n        resizeDiv.style.display = 'inline-flex';\r\n        resizeDiv.contentEditable = 'false';\r\n        resizeDiv.addEventListener('click', this.stopEvent);\r\n        resizeDiv.appendChild(target);\r\n        ['nw', 'ne', 'sw', 'se'].forEach(pos => {\r\n            let div = document.createElement('DIV');\r\n            resizeDiv.appendChild(div);\r\n            div.style.position = 'absolute';\r\n            div.style.width = '7px';\r\n            div.style.height = '7px';\r\n            div.style.backgroundColor = this.selectionBorderColor;\r\n            div.style.cursor = pos + '-resize';\r\n            if (this.isNorth(pos)) {\r\n                div.style.top = '-3px';\r\n            } else {\r\n                div.style.bottom = '-3px';\r\n            }\r\n            if (this.isWest(pos)) {\r\n                div.style.left = '-3px';\r\n            } else {\r\n                div.style.right = '-3px';\r\n            }\r\n            div.addEventListener('mousedown', this.startResize);\r\n        });\r\n        let div = document.createElement('DIV');\r\n        resizeDiv.appendChild(div);\r\n        div.style.position = 'absolute';\r\n        div.style.top = '0';\r\n        div.style.left = '0';\r\n        div.style.right = '0';\r\n        div.style.bottom = '0';\r\n        div.style.border = 'solid 1px ' + this.selectionBorderColor;\r\n        div.style.pointerEvents = 'none';\r\n        return resizeDiv;\r\n    }\r\n\r\n    private stopEvent = (e: UIEvent) => {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    };\r\n\r\n    private removeResizeDiv(resizeDiv: HTMLElement) {\r\n        if (this.editor && this.editor.contains(resizeDiv)) {\r\n            [resizeDiv.previousSibling, resizeDiv.nextSibling].forEach(comment => {\r\n                if (comment && comment.nodeType == NodeType.Comment) {\r\n                    this.editor.deleteNode(comment);\r\n                }\r\n            });\r\n            this.editor.deleteNode(resizeDiv);\r\n        }\r\n    }\r\n\r\n    private removeResizeDivIfAny = (img: HTMLImageElement) => {\r\n        let div = img && (img.parentNode as HTMLElement);\r\n        let previous = div && div.previousSibling;\r\n        let next = div && div.nextSibling;\r\n        if (\r\n            previous &&\r\n            previous.nodeType == NodeType.Comment &&\r\n            previous.nodeValue == BEGIN_TAG &&\r\n            next &&\r\n            next.nodeType == NodeType.Comment &&\r\n            next.nodeValue == END_TAG\r\n        ) {\r\n            div.parentNode.insertBefore(img, div);\r\n            this.removeResizeDiv(div);\r\n        }\r\n    };\r\n\r\n    private onBlur = (e: FocusEvent) => {\r\n        this.hideResizeHandle();\r\n    };\r\n\r\n    private extractHtml(html: string): string {\r\n        return html.replace(EXTRACT_HTML_REGEX, (...groups: string[]) => {\r\n            return groups[1].replace(\r\n                /(\\s*contenteditable=\"false\"(\\/?>)|contenteditable=\"false\"\\s*)/im,\r\n                '$2'\r\n            );\r\n        });\r\n    }\r\n\r\n    private getSelectedImage(): HTMLElement {\r\n        return this.resizeDiv ? <HTMLElement>this.resizeDiv.getElementsByTagName('IMG')[0] : null;\r\n    }\r\n\r\n    private isNorth(direction: string): boolean {\r\n        return direction && direction.substr(0, 1) == 'n';\r\n    }\r\n\r\n    private isWest(direction: string): boolean {\r\n        return direction && direction.substr(1, 1) == 'w';\r\n    }\r\n\r\n    private onDragStart = (e: DragEvent) => {\r\n        if ((e.srcElement || e.target) == this.getSelectedImage()) {\r\n            this.hideResizeHandle(true);\r\n        }\r\n    };\r\n}\r\n","export { default as PickerPlugin, EditorPickerPluginInterface } from './PickerPlugin';\r\nexport { PickerPluginOptions, PickerDataProvider } from './PickerDataProvider';\r\n","import { Browser, createRange, PartialInlineElement } from 'roosterjs-editor-dom';\r\nimport { PickerDataProvider, PickerPluginOptions } from './PickerDataProvider';\r\nimport { replaceWithNode } from 'roosterjs-editor-api';\r\nimport {\r\n    ChangeSource,\r\n    NodePosition,\r\n    PluginDomEvent,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginInputEvent,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    cacheGetContentSearcher,\r\n    Editor,\r\n    EditorPlugin,\r\n    isCharacterValue,\r\n    isModifierKey,\r\n} from 'roosterjs-editor-core';\r\n\r\n// Character codes.\r\n// IE11 uses different character codes. which are noted below.\r\n// If adding a new key, test in IE to figure out what the code is.\r\nconst BACKSPACE_CHARCODE = 'Backspace';\r\nconst TAB_CHARCODE = 'Tab';\r\nconst ENTER_CHARCODE = 'Enter';\r\nconst ESC_CHARCODE = !Browser.isIE ? 'Escape' : 'Esc';\r\nconst LEFT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowLeft' : 'Left';\r\nconst UP_ARROW_CHARCODE = !Browser.isIE ? 'ArrowUp' : 'Up';\r\nconst RIGHT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowRight' : 'Right';\r\nconst DOWN_ARROW_CHARCODE = !Browser.isIE ? 'ArrowDown' : 'Down';\r\nconst DELETE_CHARCODE = !Browser.isIE ? 'Delete' : 'Del';\r\n\r\n// Input event input types.\r\nconst DELETE_CONTENT_BACKWARDS_INPUT_TYPE = 'deleteContentBackwards';\r\n\r\n// Unidentified key, the code for Android keyboard events.\r\nconst UNIDENTIFIED_KEY = 'Unidentified';\r\n\r\n/**\r\n * Interface for PickerPlugin\r\n */\r\nexport interface EditorPickerPluginInterface<T extends PickerDataProvider = PickerDataProvider>\r\n    extends EditorPlugin {\r\n    dataProvider: T;\r\n}\r\n\r\n/**\r\n * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including\r\n * - Show picker when special trigger key is pressed\r\n * - Hide picker\r\n * - Change selection in picker by Up/Down/Left/Right\r\n * - Apply selected item in picker\r\n *\r\n * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.\r\n * To show a picker UI, you need to build your own UI component. Please reference to\r\n * https://github.com/microsoft/roosterjs/tree/master/publish/samplesite/scripts/controls/samplepicker\r\n */\r\nexport default class PickerPlugin<T extends PickerDataProvider = PickerDataProvider>\r\n    implements EditorPickerPluginInterface<T> {\r\n    private editor: Editor;\r\n    private eventHandledOnKeyDown: boolean;\r\n    private blockSuggestions: boolean;\r\n    private isSuggesting: boolean;\r\n    private lastKnownRange: Range;\r\n\r\n    // For detecting backspace in Android\r\n    private isPendingInputEventHandling: boolean = false;\r\n    private currentInputLength: number;\r\n    private newInputLength: number;\r\n\r\n    constructor(public readonly dataProvider: T, private pickerOptions: PickerPluginOptions) {}\r\n\r\n    /**\r\n     * Get a friendly name\r\n     */\r\n    getName() {\r\n        return 'Picker';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.dataProvider.onInitalize(\r\n            (htmlNode: Node) => {\r\n                this.editor.focus();\r\n\r\n                let wordToReplace = this.getWord(null);\r\n\r\n                // Safari drops our focus out so we get an empty word to replace when we call getWord.\r\n                // We fall back to using the lastKnownRange to try to get around this.\r\n                if ((!wordToReplace || wordToReplace.length == 0) && this.lastKnownRange) {\r\n                    this.editor.select(this.lastKnownRange);\r\n                    wordToReplace = this.getWord(null);\r\n                }\r\n\r\n                let insertNode = () => {\r\n                    if (wordToReplace) {\r\n                        replaceWithNode(\r\n                            this.editor,\r\n                            wordToReplace,\r\n                            htmlNode,\r\n                            true /* exactMatch */\r\n                        );\r\n                    } else {\r\n                        this.editor.insertNode(htmlNode);\r\n                    }\r\n                    this.setIsSuggesting(false);\r\n                };\r\n\r\n                if (this.pickerOptions.handleAutoComplete) {\r\n                    this.editor.performAutoComplete(insertNode, this.pickerOptions.changeSource);\r\n                } else {\r\n                    this.editor.addUndoSnapshot(insertNode, this.pickerOptions.changeSource);\r\n                }\r\n            },\r\n            (isSuggesting: boolean) => {\r\n                this.setIsSuggesting(isSuggesting);\r\n            },\r\n            editor\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.editor = null;\r\n        this.dataProvider.onDispose();\r\n    }\r\n\r\n    /**\r\n     * Check if the plugin should handle the given event exclusively.\r\n     * Handle an event exclusively means other plugin will not receive this event in\r\n     * onPluginEvent method.\r\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\r\n     * the final result depends on the order of the plugins are added into editor\r\n     * @param event The event to check\r\n     */\r\n    public willHandleEventExclusively(event: PluginEvent) {\r\n        return (\r\n            this.isSuggesting &&\r\n            (event.eventType == PluginEventType.KeyDown ||\r\n                event.eventType == PluginEventType.KeyUp ||\r\n                event.eventType == PluginEventType.Input)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    public onPluginEvent(event: PluginEvent) {\r\n        switch (event.eventType) {\r\n            case PluginEventType.ContentChanged:\r\n                if (event.source == ChangeSource.SetContent && this.dataProvider.onContentChanged) {\r\n                    // Stop suggesting since content is fully changed\r\n                    if (this.isSuggesting) {\r\n                        this.setIsSuggesting(false);\r\n                    }\r\n\r\n                    // Undos and other major changes to document content fire this type of event.\r\n                    // Inform the data provider of the current picker placed elements in the body.\r\n                    let elementIds: string[] = [];\r\n                    this.editor.queryElements(\r\n                        \"[id^='\" + this.pickerOptions.elementIdPrefix + \"']\",\r\n                        element => {\r\n                            if (element.id) {\r\n                                elementIds.push(element.id);\r\n                            }\r\n                        }\r\n                    );\r\n                    this.dataProvider.onContentChanged(elementIds);\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.KeyDown:\r\n                this.eventHandledOnKeyDown = false;\r\n                if (event.rawEvent.key == UNIDENTIFIED_KEY) {\r\n                    // On Android, the key for KeyboardEvent is \"Unidentified\",\r\n                    // so handling should be done using the input rather than key down event\r\n                    // Since the key down event happens right before the input event, calculate the input\r\n                    // length here in preparation for onAndroidInputEvent\r\n                    this.currentInputLength = this.calcInputLength(event);\r\n                    this.isPendingInputEventHandling = true;\r\n                } else {\r\n                    this.onKeyDownEvent(event);\r\n                    this.isPendingInputEventHandling = false;\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.Input:\r\n                if (this.isPendingInputEventHandling) {\r\n                    this.onAndroidInputEvent(event);\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.KeyUp:\r\n                if (!this.eventHandledOnKeyDown && this.shouldHandleKeyUpEvent(event)) {\r\n                    this.onKeyUpDomEvent(event);\r\n                    this.isPendingInputEventHandling = false;\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.MouseUp:\r\n                if (this.isSuggesting) {\r\n                    this.setIsSuggesting(false);\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.Scroll:\r\n                if (this.dataProvider.onScroll) {\r\n                    // Dispatch scroll event to data provider\r\n                    this.dataProvider.onScroll(event.scrollContainer);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    private setLastKnownRange(range: Range) {\r\n        this.lastKnownRange = range;\r\n    }\r\n\r\n    private setIsSuggesting(isSuggesting: boolean) {\r\n        this.isSuggesting = isSuggesting;\r\n\r\n        if (!isSuggesting) {\r\n            this.setLastKnownRange(null);\r\n        }\r\n        this.dataProvider.onIsSuggestingChanged(isSuggesting);\r\n\r\n        this.setAriaOwns(isSuggesting);\r\n        this.setAriaActiveDescendant(isSuggesting ? 0 : null);\r\n    }\r\n\r\n    private cancelDefaultKeyDownEvent(event: PluginKeyboardEvent) {\r\n        this.eventHandledOnKeyDown = true;\r\n        event.rawEvent.preventDefault();\r\n        event.rawEvent.stopImmediatePropagation();\r\n    }\r\n\r\n    private getIdValue(node: Node): string {\r\n        let element = node as Element;\r\n        return element.attributes && element.attributes.getNamedItem('id')\r\n            ? (element.attributes.getNamedItem('id').value as string)\r\n            : null;\r\n    }\r\n\r\n    private getWordBeforeCursor(event: PluginKeyboardEvent): string {\r\n        let searcher = cacheGetContentSearcher(event, this.editor);\r\n        return searcher ? searcher.getWordBefore() : null;\r\n    }\r\n\r\n    private replaceNode(currentNode: Node, replacementNode: Node) {\r\n        if (currentNode) {\r\n            this.editor.deleteNode(currentNode);\r\n        }\r\n        if (replacementNode) {\r\n            this.editor.insertNode(replacementNode);\r\n        }\r\n    }\r\n\r\n    private getRangeUntilAt(event: PluginKeyboardEvent): Range {\r\n        let PositionContentSearcher = cacheGetContentSearcher(event, this.editor);\r\n        let startPos: NodePosition;\r\n        let endPos: NodePosition;\r\n        PositionContentSearcher.forEachTextInlineElement(textInline => {\r\n            let hasMatched = false;\r\n            let nodeContent = textInline.getTextContent();\r\n            let nodeIndex = nodeContent ? nodeContent.length : -1;\r\n            while (nodeIndex >= 0) {\r\n                if (nodeContent[nodeIndex] == this.pickerOptions.triggerCharacter) {\r\n                    startPos = textInline.getStartPosition().move(nodeIndex);\r\n                    hasMatched = true;\r\n                    break;\r\n                }\r\n                nodeIndex--;\r\n            }\r\n\r\n            if (hasMatched) {\r\n                endPos = textInline.getEndPosition();\r\n            }\r\n\r\n            return hasMatched;\r\n        });\r\n        return createRange(startPos, endPos) || this.editor.getDocument().createRange();\r\n    }\r\n\r\n    private shouldHandleKeyUpEvent(event: PluginKeyboardEvent) {\r\n        // onKeyUpDomEvent should only be called when a key that produces a character value is pressed\r\n        // This check will always fail on Android since the KeyboardEvent's key is \"Unidentified\"\r\n        // However, we don't need to check for modifier events on mobile, so can ignore this check\r\n        return (\r\n            event.rawEvent.key == UNIDENTIFIED_KEY ||\r\n            isCharacterValue(event.rawEvent) ||\r\n            (this.isSuggesting && !isModifierKey(event.rawEvent))\r\n        );\r\n    }\r\n\r\n    private onKeyUpDomEvent(event: PluginKeyboardEvent) {\r\n        if (this.isSuggesting) {\r\n            // Word before cursor represents the text prior to the cursor, up to and including the trigger symbol.\r\n            const wordBeforeCursor = this.getWord(event);\r\n            const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\r\n            const trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\r\n\r\n            // If we hit a case where wordBeforeCursor is just the trigger character,\r\n            // that means we've gotten a onKeyUp event right after it's been typed.\r\n            // Otherwise, update the query string when:\r\n            // 1. There's an actual value\r\n            // 2. That actual value isn't just pure whitespace\r\n            // 3. That actual value isn't more than 4 words long (at which point we assume the person kept typing)\r\n            // Otherwise, we want to dismiss the picker plugin's UX.\r\n            if (\r\n                wordBeforeCursor == this.pickerOptions.triggerCharacter ||\r\n                (trimmedWordBeforeCursor &&\r\n                    trimmedWordBeforeCursor.length > 0 &&\r\n                    trimmedWordBeforeCursor.split(' ').length <= 4)\r\n            ) {\r\n                this.dataProvider.queryStringUpdated(\r\n                    trimmedWordBeforeCursor,\r\n                    wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\r\n                );\r\n                this.setLastKnownRange(this.editor.getSelectionRange());\r\n            } else {\r\n                this.setIsSuggesting(false);\r\n            }\r\n        } else {\r\n            let wordBeforeCursor = this.getWordBeforeCursor(event);\r\n            if (!this.blockSuggestions) {\r\n                if (\r\n                    wordBeforeCursor != null &&\r\n                    wordBeforeCursor.split(' ').length <= 4 &&\r\n                    wordBeforeCursor[0] == this.pickerOptions.triggerCharacter\r\n                ) {\r\n                    this.setIsSuggesting(true);\r\n                    const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\r\n                    let trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\r\n                    this.dataProvider.queryStringUpdated(\r\n                        trimmedWordBeforeCursor,\r\n                        wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\r\n                    );\r\n                    this.setLastKnownRange(this.editor.getSelectionRange());\r\n                    if (this.dataProvider.setCursorPoint) {\r\n                        // Determine the bounding rectangle for the @mention\r\n                        let searcher = cacheGetContentSearcher(event, this.editor);\r\n                        let rangeNode = this.editor.getDocument().createRange();\r\n                        let nodeBeforeCursor = searcher.getInlineElementBefore().getContainerNode();\r\n                        let rangeStartSuccessfullySet = this.setRangeStart(\r\n                            rangeNode,\r\n                            nodeBeforeCursor,\r\n                            wordBeforeCursor\r\n                        );\r\n                        if (!rangeStartSuccessfullySet) {\r\n                            // VSO 24891: Out of range error is occurring because nodeBeforeCursor\r\n                            // is not including the trigger character. In this case, the node before\r\n                            // the node before cursor is the trigger character, and this is where the range should start.\r\n                            let nodeBeforeNodeBeforeCursor = nodeBeforeCursor.previousSibling;\r\n                            this.setRangeStart(\r\n                                rangeNode,\r\n                                nodeBeforeNodeBeforeCursor,\r\n                                this.pickerOptions.triggerCharacter\r\n                            );\r\n                        }\r\n                        let rect = rangeNode.getBoundingClientRect();\r\n\r\n                        // Safari's support for range.getBoundingClientRect is incomplete.\r\n                        // We perform this check to fall back to getClientRects in case it's at the page origin.\r\n                        if (rect.left == 0 && rect.bottom == 0 && rect.top == 0) {\r\n                            rect = rangeNode.getClientRects()[0];\r\n                        }\r\n\r\n                        if (rect) {\r\n                            rangeNode.detach();\r\n\r\n                            // Display the @mention popup in the correct place\r\n                            let targetPoint = { x: rect.left, y: (rect.bottom + rect.top) / 2 };\r\n                            let bufferZone = (rect.bottom - rect.top) / 2;\r\n                            this.dataProvider.setCursorPoint(targetPoint, bufferZone);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (\r\n                    wordBeforeCursor != null &&\r\n                    wordBeforeCursor[0] != this.pickerOptions.triggerCharacter\r\n                ) {\r\n                    this.blockSuggestions = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onKeyDownEvent(event: PluginKeyboardEvent) {\r\n        let keyboardEvent = event.rawEvent;\r\n        if (this.isSuggesting) {\r\n            if (keyboardEvent.key == ESC_CHARCODE) {\r\n                this.setIsSuggesting(false);\r\n                this.blockSuggestions = true;\r\n                this.cancelDefaultKeyDownEvent(event);\r\n            } else if (\r\n                this.dataProvider.shiftHighlight &&\r\n                (this.pickerOptions.isHorizontal\r\n                    ? keyboardEvent.key == LEFT_ARROW_CHARCODE ||\r\n                      keyboardEvent.key == RIGHT_ARROW_CHARCODE\r\n                    : keyboardEvent.key == UP_ARROW_CHARCODE ||\r\n                      keyboardEvent.key == DOWN_ARROW_CHARCODE)\r\n            ) {\r\n                this.dataProvider.shiftHighlight(\r\n                    this.pickerOptions.isHorizontal\r\n                        ? keyboardEvent.key == RIGHT_ARROW_CHARCODE\r\n                        : keyboardEvent.key == DOWN_ARROW_CHARCODE\r\n                );\r\n\r\n                if (this.dataProvider.getSelectedIndex) {\r\n                    this.setAriaActiveDescendant(this.dataProvider.getSelectedIndex());\r\n                }\r\n\r\n                this.cancelDefaultKeyDownEvent(event);\r\n            } else if (\r\n                this.dataProvider.selectOption &&\r\n                (keyboardEvent.key == ENTER_CHARCODE || keyboardEvent.key == TAB_CHARCODE)\r\n            ) {\r\n                this.dataProvider.selectOption();\r\n                this.cancelDefaultKeyDownEvent(event);\r\n            } else {\r\n                // Currently no op.\r\n            }\r\n        } else {\r\n            if (keyboardEvent.key == BACKSPACE_CHARCODE) {\r\n                const nodeRemoved = this.tryRemoveNode(event);\r\n                if (nodeRemoved) {\r\n                    this.cancelDefaultKeyDownEvent(event);\r\n                }\r\n            } else if (keyboardEvent.key == DELETE_CHARCODE) {\r\n                let searcher = cacheGetContentSearcher(event, this.editor);\r\n                let nodeAfterCursor = searcher.getInlineElementAfter()\r\n                    ? searcher.getInlineElementAfter().getContainerNode()\r\n                    : null;\r\n                let nodeId = nodeAfterCursor ? this.getIdValue(nodeAfterCursor) : null;\r\n                if (nodeId && nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0) {\r\n                    let replacementNode = this.dataProvider.onRemove(nodeAfterCursor, false);\r\n                    this.replaceNode(nodeAfterCursor, replacementNode);\r\n                    this.cancelDefaultKeyDownEvent(event);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onAndroidInputEvent(event: PluginInputEvent) {\r\n        this.newInputLength = this.calcInputLength(event);\r\n\r\n        if (\r\n            this.newInputLength < this.currentInputLength ||\r\n            (event.rawEvent as any).inputType === DELETE_CONTENT_BACKWARDS_INPUT_TYPE\r\n        ) {\r\n            const nodeRemoved = this.tryRemoveNode(event);\r\n            if (nodeRemoved) {\r\n                this.eventHandledOnKeyDown = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private calcInputLength(event: PluginEvent) {\r\n        const wordBeforCursor = this.getInlineElementBeforeCursor(event);\r\n        return wordBeforCursor ? wordBeforCursor.length : 0;\r\n    }\r\n\r\n    private tryRemoveNode(event: PluginDomEvent): boolean {\r\n        const searcher = cacheGetContentSearcher(event, this.editor);\r\n        const inlineElementBefore = searcher.getInlineElementBefore();\r\n        const nodeBeforeCursor = inlineElementBefore\r\n            ? inlineElementBefore.getContainerNode()\r\n            : null;\r\n        const nodeId = nodeBeforeCursor ? this.getIdValue(nodeBeforeCursor) : null;\r\n        const inlineElementAfter = searcher.getInlineElementAfter();\r\n\r\n        if (\r\n            nodeId &&\r\n            nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&\r\n            (inlineElementAfter == null || !(inlineElementAfter instanceof PartialInlineElement))\r\n        ) {\r\n            const replacementNode = this.dataProvider.onRemove(nodeBeforeCursor, true);\r\n            if (replacementNode) {\r\n                this.replaceNode(nodeBeforeCursor, replacementNode);\r\n                if (this.isPendingInputEventHandling) {\r\n                    this.editor.runAsync(() => {\r\n                        this.editor.select(replacementNode, PositionType.After);\r\n                    });\r\n                } else {\r\n                    this.editor.select(replacementNode, PositionType.After);\r\n                }\r\n            } else {\r\n                this.editor.deleteNode(nodeBeforeCursor);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private getWord(event: PluginKeyboardEvent) {\r\n        let wordFromRange = this.getRangeUntilAt(event).toString();\r\n        let wordFromCache = this.getWordBeforeCursor(event);\r\n        // VSO 24891: In picker, trigger and mention are separated into two nodes.\r\n        // In this case, wordFromRange is the trigger character while wordFromCache is the whole string,\r\n        // so wordFromCache is what we want to return.\r\n        if (\r\n            wordFromRange == this.pickerOptions.triggerCharacter &&\r\n            wordFromRange != wordFromCache\r\n        ) {\r\n            return wordFromCache;\r\n        }\r\n        return wordFromRange;\r\n    }\r\n\r\n    private setRangeStart(rangeNode: Range, node: Node, target: string) {\r\n        let nodeOffset = node ? node.textContent.lastIndexOf(target) : -1;\r\n        if (nodeOffset > -1) {\r\n            rangeNode.setStart(node, nodeOffset);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private setAriaOwns(isSuggesting: boolean) {\r\n        this.editor.setEditorDomAttribute(\r\n            'aria-owns',\r\n            isSuggesting && this.pickerOptions.suggestionsLabel\r\n                ? this.pickerOptions.suggestionsLabel\r\n                : null\r\n        );\r\n    }\r\n\r\n    private setAriaActiveDescendant(selectedIndex: number) {\r\n        this.editor.setEditorDomAttribute(\r\n            'aria-activedescendant',\r\n            selectedIndex != null && this.pickerOptions.suggestionLabelPrefix\r\n                ? this.pickerOptions.suggestionLabelPrefix + selectedIndex.toString()\r\n                : null\r\n        );\r\n    }\r\n\r\n    private getInlineElementBeforeCursor(event: PluginEvent): string {\r\n        const searcher = cacheGetContentSearcher(event, this.editor);\r\n        const element = searcher ? searcher.getInlineElementBefore() : null;\r\n        return element ? element.getTextContent() : null;\r\n    }\r\n}\r\n"],"sourceRoot":""}